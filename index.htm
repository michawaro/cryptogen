<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <title>Cryptogen - Encodeur / Décodeur ADN</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #222;
        min-height: 100vh;
        padding-bottom: 60px;
      }
      .container {
        max-width: 1440px;
        margin: 0 auto;
        padding: 40px 20px;
      }
      header {
        text-align: center;
        margin-bottom: 60px;
        padding: 40px 20px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
      }
      h1 {
        font-size: 3rem;
        font-weight: 700;
        margin: 0 0 20px 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        letter-spacing: -0.02em;
      }
      .subtitle {
        font-size: 1.3rem;
        color: #666;
        margin: 0;
        font-weight: 400;
        line-height: 1.6;
      }
      .section {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 40px;
        margin-bottom: 40px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
      }
      h2 {
        font-size: 2rem;
        font-weight: 600;
        margin: 0 0 30px 0;
        text-align: center;
        color: #333;
        letter-spacing: -0.01em;
      }
      textarea {
        width: 100%;
        height: 160px;
        font-family: "Courier New", monospace;
        font-size: 1.1rem;
        padding: 20px;
        border-radius: 12px;
        border: 2px solid #e0e0e0;
        resize: vertical;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
        line-height: 1.6;
      }
      textarea::placeholder {
        color: #999;
        opacity: 1;
      }
      textarea:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }
      button {
        margin-top: 20px;
        padding: 16px 32px;
        font-size: 1.1rem;
        font-weight: 600;
        border-radius: 12px;
        border: none;
        cursor: pointer;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
      }
      button:active {
        transform: translateY(0);
      }
      .output {
        margin-top: 30px;
        padding: 25px;
        background: #f8f9fa;
        border-radius: 12px;
        min-height: 80px;
        max-height: 400px;
        overflow-y: auto;
        font-size: 1.2rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        line-height: 2;
        border: 2px solid #e0e0e0;
        font-family: "Courier New", monospace;
      }
      .output:empty:before {
        content: "Le résultat apparaîtra ici...";
        color: #999;
        font-style: italic;
      }
      .word-space {
        background-color: #e0e0e0;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-short {
        background-color: #b3d9ff;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-medium {
        background-color: #b3ffb3;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-long {
        background-color: #fff9b3;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-verylong {
        background-color: #ffb3d9;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-trou {
        background-color: #ff6b6b !important;
        opacity: 0.7;
        cursor: pointer;
        position: relative;
      }
      .word-stop {
        background-color: #ffb3d9;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-trou:hover {
        opacity: 1;
      }
      .word-trou::after {
        content: "✕";
        position: absolute;
        top: -8px;
        right: -8px;
        background: #ff6b6b;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
      }
      .trou-mode-active {
        background: #fff3cd !important;
        border: 2px solid #ffc107 !important;
      }
      #dnaInput {
        width: 100%;
        min-height: 160px;
        font-family: "Courier New", monospace;
        font-size: 1.1rem;
        padding: 20px;
        border-radius: 12px;
        border: 2px solid #e0e0e0;
        background: white;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        transition: border-color 0.3s ease;
        line-height: 1.6;
      }
      #dnaInput:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }
      #dnaInput:empty:before {
        content: attr(placeholder);
        color: #999;
        pointer-events: none;
      }
      table {
        margin: 0 auto;
        width: 100%;
        max-width: 1000px;
        border-collapse: collapse;
        background: white;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
      }
      th,
      td {
        padding: 10px 12px;
        border-bottom: 1px solid #eee;
        border-right: 1px solid #eee;
        text-align: center;
        font-family: "Courier New", monospace;
        font-size: 0.95rem;
        width: 12.5%;
      }
      th {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        font-weight: 600;
        text-transform: uppercase;
        font-size: 0.85rem;
        letter-spacing: 0.05em;
      }
      td:last-child,
      th:last-child {
        border-right: none;
      }
      tr:hover {
        background-color: #f8f9fa;
      }
      tr:last-child td {
        border-bottom: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Cryptogen - Encodeur / Décodeur ADN</h1>
        <p class="subtitle">
          Colle une séquence ADN ou un texte, et encode ou décode avec le même
          code génétique.
        </p>
        <p class="subtitle" style="margin-top: 10px; font-size: 1rem">
          Mode d'emploi de l'encodeur dans
          <a
            href="https://youtu.be/752HGS405eY"
            target="_blank"
            style="color: #667eea; text-decoration: underline"
            >cette vidéo</a
          >. Des exemples d'utilisation seront ajoutés sur
          <a
            href="https://michawaro.github.io/michawaro/"
            target="_blank"
            style="color: #667eea; text-decoration: underline"
            >la page Michawaro</a
          >.
        </p>
        <p class="subtitle" style="margin-top: 10px; font-size: 1rem">
          Pour contacter le créateur de cette page (pour un feedback ou une
          proposition de modification) écrire à
          <a
            href="mailto:michawaro.mail@gmail.com"
            style="color: #667eea; text-decoration: underline"
            >michawaro.mail@gmail.com</a
          >.
        </p>
      </header>

      <div class="section">
        <h2>Décodage</h2>
        <div style="margin-bottom: 15px; text-align: center">
          <label
            for="ediFileInput"
            style="display: inline-block; margin-right: 10px"
          >
            <button
              onclick="document.getElementById('ediFileInput').click()"
              style="background: #4dabf7"
            >
              Importer .edi
            </button>
            <input
              type="file"
              id="ediFileInput"
              accept=".edi"
              style="display: none"
              onchange="importEDIFile(event)"
            />
          </label>
          <label
            for="fastaFileInput"
            style="display: inline-block; margin-right: 10px"
          >
            <button
              onclick="document.getElementById('fastaFileInput').click()"
              style="background: #4dabf7"
            >
              Importer .fasta
            </button>
            <input
              type="file"
              id="fastaFileInput"
              accept=".fasta,.fa,.fas"
              style="display: none"
              onchange="importFASTAFile(event)"
            />
          </label>
          <button onclick="loadTestSequence()" style="background: #b3ffb3">
            Tester
          </button>
        </div>
        <div
          id="dnaInput"
          contenteditable="true"
          placeholder="Ecris ou colle ici une séquence d'ADN. L'ADN contient des informations codées sous forme de séquence de nucléotides. Peut-être qu'un message est caché dans la séquence que tu vas étudier ?"
        ></div>
        <button onclick="decodeDNA()">Décoder</button>
        <p
          style="
            margin-top: 15px;
            margin-bottom: 10px;
            color: #666;
            font-style: italic;
            text-align: center;
          "
        >
          Dans le cas où certains mots s'affichent sous forme de séquence de
          nucléotides, double cliquez dessus pour les déchiffrer.
        </p>
        <div
          class="output"
          id="output"
          style="word-wrap: break-word; overflow-wrap: break-word"
        ></div>
      </div>

      <div class="section">
        <h2>Encodage</h2>
        <textarea
          id="textInput"
          placeholder="Ecris ou colle un texte que tu souhaites encoder dans de l'ADN. Anecdote : il est aujourd'hui possible d'encapsuler l'ADN dans des nanobilles de silice. En les stockant dans des capsules en acier inoxydable, on estime pouvoir obtenir une durée de vie de 50.000 ans. Source : Académie des technologies - Wikipedia"
        ></textarea>
        <button onclick="encodeText()">Encoder</button>
        <button
          id="trouModeBtn"
          onclick="toggleTrouMode()"
          style="margin-left: 10px; background: #ff6b6b"
        >
          Encodage à trou
        </button>
        <button
          id="copyBtn"
          onclick="copyDNAWithTrous()"
          style="margin-left: 10px; background: #51cf66; display: none"
        >
          Copier la séquence
        </button>
        <button
          id="exportEDIBtn"
          onclick="exportEDIFile()"
          style="margin-left: 10px; background: #ffa94d; display: none"
        >
          Exporter .edi
        </button>
        <button
          id="exportFASTABtn"
          onclick="exportFASTAFile()"
          style="margin-left: 10px; background: #ffa94d; display: none"
        >
          Exporter .fasta
        </button>
        <div class="output" id="dnaOutput"></div>
      </div>

      <div class="section">
        <h2>Code génétique fictif - Triplet de nucléotides / texte</h2>
        <div style="margin-bottom: 20px; text-align: center">
          <button
            onclick="exportGeneticCode()"
            style="margin-right: 10px; background: #51cf66"
          >
            Exporter CSV
          </button>
          <label for="csvFileInput" style="display: inline-block">
            <button
              onclick="document.getElementById('csvFileInput').click()"
              style="background: #4dabf7"
            >
              Importer CSV
            </button>
            <input
              type="file"
              id="csvFileInput"
              accept=".csv"
              style="display: none"
              onchange="importGeneticCode(event)"
            />
          </label>
        </div>
        <p
          style="
            margin-top: 10px;
            margin-bottom: 15px;
            color: #666;
            font-style: italic;
            text-align: center;
            font-size: 0.9rem;
          "
        >
          L'import CSV permet à chaque utilisateur de personnaliser
          temporairement le code génétique pour sa session.
        </p>
        <table>
          <thead>
            <tr>
              <th>Codon</th>
              <th>Symbole</th>
              <th>Codon</th>
              <th>Symbole</th>
              <th>Codon</th>
              <th>Symbole</th>
              <th>Codon</th>
              <th>Symbole</th>
            </tr>
          </thead>
          <tbody id="codeTable"></tbody>
        </table>
      </div>
    </div>

    <!-- Fenêtre modale pour le décodage interactif -->
    <div
      id="decodeModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 50px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 90%;
          max-height: 90vh;
          overflow-y: auto;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
          "
        >
          <h2 style="margin: 0; color: #667eea">Décodage interactif</h2>
          <button
            id="closeModal"
            style="
              background: #ff6b6b;
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 1.2rem;
            "
          >
            ✕ Fermer
          </button>
        </div>
        <div id="modalContent"></div>
      </div>
    </div>

    <script>
      const geneticCode = {
        ATG: "START",
        // AAA : marqueur de majuscule (pour le triplet suivant)
        AAA: "Majuscule",
        // Ordre alphabétique des triplets
        // A : 1 triplet
        AAC: "A",
        // B : 2 triplets
        AAG: "B",
        AAT: "B",
        // C : 2 triplets
        ACA: "C",
        ACC: "C",
        // D : 2 triplets
        ACG: "D",
        ACT: "D",
        // E : 1 triplet
        AGC: "E",
        // É (é en majuscule) : 1 triplet
        AGG: "É",
        // È (è en majuscule) : 1 triplet
        AGT: "È",
        // Ê (ê en majuscule) : 1 triplet
        ATA: "Ê",
        // Ë (ë en majuscule) : 1 triplet
        ATC: "Ë",
        // F : 2 triplets
        ATT: "F",
        CAA: "F",
        // G : 2 triplets
        CAC: "G",
        CAG: "G",
        // H : 2 triplets
        CAT: "H",
        CCA: "H",
        // I : 1 triplet
        CCC: "I",
        // Ï (ï en majuscule) : 1 triplet
        CCG: "Ï",
        // J : 2 triplets
        CCT: "J",
        CGA: "J",
        // K : 2 triplets
        CGC: "K",
        CGG: "K",
        // L : 2 triplets
        CGT: "L",
        CTA: "L",
        // M : 2 triplets
        CTC: "M",
        CTG: "M",
        // N : 2 triplets
        CTT: "N",
        GAA: "N",
        // O : 2 triplets
        GAC: "O",
        GAG: "O",
        // P : 2 triplets
        GAT: "P",
        GCA: "P",
        // Q : 2 triplets
        GCC: "Q",
        GCG: "Q",
        // R : 2 triplets
        GCT: "R",
        GGA: "R",
        // S : 2 triplets
        GGC: "S",
        GGT: "S",
        // T : 2 triplets
        GTA: "T",
        GTC: "T",
        // U : 2 triplets
        GTG: "U",
        GTT: "U",
        // V : 2 triplets
        TAC: "V",
        TAT: "V",
        // W : 2 triplets
        TCA: "W",
        TCC: "W",
        // X : 2 triplets
        TCG: "X",
        TCT: "X",
        // Point (fin de phrase) - uniquement les 3 stop codons classiques
        TAA: ".",
        TAG: ".",
        TGA: ".",
        // Utiliser les triplets restants pour des redondances
        TGC: "Y", // Y : 1 triplet
        TGG: "Z", // Z : 1 triplet
        // Caractères spéciaux (derniers triplets)
        TTA: ",", // Virgule
        TTC: "'", // Apostrophe
        TTG: ",", // Virgule (tous types)
        TTT: " ", // Espace
      };

      const reverseCode = {};
      for (let [codon, char] of Object.entries(geneticCode)) {
        if (char !== "START" && char !== "Majuscule") {
          if (!reverseCode[char]) reverseCode[char] = [];
          reverseCode[char].push(codon);
        }
      }

      // Variables pour le mode "encodage à trou"
      let trouModeActive = false;
      let selectedWordIndices = new Set(); // Indices des mots sélectionnés (0-based)
      let currentWordPositions = []; // Positions des mots dans la séquence actuelle

      // Fonction pour activer/désactiver le mode "à trou"
      function toggleTrouMode() {
        trouModeActive = !trouModeActive;
        const btn = document.getElementById("trouModeBtn");
        const output = document.getElementById("dnaOutput");
        const textInput = document.getElementById("textInput");

        if (trouModeActive) {
          btn.classList.add("trou-mode-active");
          btn.textContent = "Mode à trou actif (double-cliquez sur les mots)";
          // Réencoder pour permettre la sélection
          if (textInput.value.trim()) {
            encodeText();
          } else {
            // Si aucun texte n'est encodé, afficher un message
            output.innerHTML =
              '<span style="color: #666; font-style: italic;">Veuillez d\'abord encoder un texte pour utiliser le mode "à trou".</span>';
          }
        } else {
          btn.classList.remove("trou-mode-active");
          btn.textContent = "Encodage à trou";
          selectedWordIndices.clear();
          // Réencoder pour enlever les sélections
          if (textInput.value.trim()) {
            encodeText();
          } else {
            // Si aucun texte n'est encodé, vider l'affichage
            output.innerHTML = "";
          }
        }
      }

      // Marqueur spécial pour les positions "à trou" : TGGTGG (double stop codon)
      const TROU_MARKER = "TGGTGG";

      // Fonction pour encoder les positions des mots sélectionnés
      function encodeTrouPositions(indices) {
        if (indices.size === 0) return "";
        // Format: TGGTGG (marqueur) + positions encodées en base 4 (A=0, T=1, C=2, G=3)
        // Utiliser TAG comme séparateur entre les positions (TAG est maintenant un point, mais utilisé ici comme marqueur technique)
        const positions = Array.from(indices).sort((a, b) => a - b);
        let encoded = TROU_MARKER; // Marqueur de début

        for (let i = 0; i < positions.length; i++) {
          if (i > 0) {
            encoded += "TAG"; // Utiliser TAG comme séparateur
          }
          // Encoder la position en base 4 avec A, T, C, G
          let pos = positions[i];
          if (pos === 0) {
            encoded += "A"; // Position 0 = A
          } else {
            let posStr = pos.toString(4);
            let dnaStr = "";
            for (let digit of posStr) {
              const d = parseInt(digit);
              dnaStr += ["A", "T", "C", "G"][d];
            }
            encoded += dnaStr;
          }
        }

        return encoded;
      }

      // Fonction pour décoder les positions des mots à trou
      function decodeTrouPositions(dna) {
        const indices = new Set();
        // Chercher le marqueur TGGTGG
        const startIdx = dna.indexOf(TROU_MARKER);
        if (startIdx === -1) return indices;

        // Extraire la partie après le marqueur
        const encoded = dna.substring(startIdx + TROU_MARKER.length);
        // Séparer par "TAG"
        const parts = encoded.split("TAG").filter((p) => p.length > 0);

        for (let part of parts) {
          // Décoder de base 4 (A=0, T=1, C=2, G=3) vers décimal
          let pos = 0;
          for (let i = 0; i < part.length; i++) {
            const char = part[i];
            const digit = ["A", "T", "C", "G"].indexOf(char);
            if (digit === -1) continue;
            pos = pos * 4 + digit;
          }
          indices.add(pos);
        }

        return indices;
      }

      // Fonction pour obtenir la classe CSS selon la longueur du mot
      function getWordClass(length) {
        if (length <= 4) return "word-short";
        if (length <= 6) return "word-medium";
        if (length <= 9) return "word-long";
        return "word-verylong";
      }

      // Fonction pour colorer le texte selon la longueur des mots
      function colorizeText(text, wordToDNA = null) {
        const words = text.split(/(\s+)/);
        let html = "";
        for (let word of words) {
          if (word.trim() === "") {
            // Espace
            html += `<span class="word-space">${word}</span>`;
          } else {
            const length = word.length;
            const className = getWordClass(length);
            const tooltip =
              wordToDNA && wordToDNA[word] ? ` title="${wordToDNA[word]}"` : "";
            html += `<span class="${className}"${tooltip}>${word}</span>`;
          }
        }
        return html;
      }

      // Fonction pour décoder une séquence ADN en texte
      function decodeDNASequence(dnaSequence) {
        let decoded = "";
        let nextIsCapital = false;
        for (let i = 0; i <= dnaSequence.length - 3; i += 3) {
          const codon = dnaSequence.substring(i, i + 3);

          // Vérifier si c'est le marqueur de majuscule AAA
          if (codon === "AAA") {
            nextIsCapital = true;
            continue; // Passer au codon suivant
          }

          const decodedChar = geneticCode[codon];
          if (decodedChar) {
            let displayChar = decodedChar;
            if (decodedChar === "é") displayChar = "É";
            if (decodedChar === "è") displayChar = "È";
            if (decodedChar === "ê") displayChar = "Ê";
            if (decodedChar === "ë") displayChar = "Ë";
            if (decodedChar === "ï") displayChar = "Ï";

            // Appliquer la majuscule si AAA a été rencontré avant
            if (nextIsCapital && displayChar && displayChar.length === 1) {
              displayChar = displayChar.toUpperCase();
              nextIsCapital = false;
            }

            decoded += displayChar;
          }
        }
        return decoded;
      }

      // Fonction pour colorer la séquence ADN selon les mots (pour le décodage)
      function colorizeDNAForDecode(dna) {
        if (!dna || dna.length === 0) return "";

        // Vérifier s'il y a un marqueur "à trou" (TGGTGG)
        const markerIndex = dna.indexOf(TROU_MARKER);
        let sequenceToColorize = dna;
        let markerAndPositions = "";

        if (markerIndex !== -1) {
          // Séparer la séquence principale et le marqueur avec les positions
          sequenceToColorize = dna.substring(0, markerIndex);
          markerAndPositions = dna.substring(markerIndex);
        }

        let html = "";
        let i = 0;
        const startIndex = sequenceToColorize.indexOf("ATG");

        if (startIndex === -1) {
          // Pas de ATG, commencer au début
          i = 0;
        } else {
          // Ajouter tout ce qui précède ATG et ATG lui-même
          html += `<span>${sequenceToColorize.substring(
            0,
            startIndex + 3
          )}</span>`;
          i = startIndex + 3;
        }

        let currentWordStart = i;
        let inWord = true;

        // Traiter toute la séquence sans s'arrêter aux codons stop
        while (i <= sequenceToColorize.length - 3) {
          const codon = sequenceToColorize.substring(i, i + 3);

          if (codon === "TTT") {
            // Espace
            if (inWord) {
              // Finir le mot précédent
              const wordLength = i - currentWordStart;
              const className = getNucleotideClass(wordLength);
              const wordDNA = sequenceToColorize.substring(currentWordStart, i);
              const decodedWord = decodeDNASequence(wordDNA);
              const tooltip = decodedWord ? ` title="${decodedWord}"` : "";
              html += `<span class="${className}"${tooltip}>${wordDNA}</span>`;
              inWord = false;
            }
            html += `<span class="word-space">${codon}</span>`;
            i += 3;
            currentWordStart = i;
            inWord = true;
          } else if (["TAA", "TAG", "TGA"].includes(codon)) {
            // Codon stop = point (mais continuer après)
            if (inWord) {
              const wordLength = i - currentWordStart;
              const className = getNucleotideClass(wordLength);
              const wordDNA = sequenceToColorize.substring(currentWordStart, i);
              const decodedWord = decodeDNASequence(wordDNA);
              const tooltip = decodedWord ? ` title="${decodedWord}"` : "";
              html += `<span class="${className}"${tooltip}>${wordDNA}</span>`;
              inWord = false;
            }
            html += `<span class="word-stop" title="Point">${codon}</span>`;
            i += 3;
            currentWordStart = i;
            inWord = true;
          } else {
            i += 3;
          }
        }

        // Ajouter le dernier mot s'il existe
        if (inWord && i > currentWordStart) {
          const wordLength = i - currentWordStart;
          const className = getNucleotideClass(wordLength);
          const wordDNA = sequenceToColorize.substring(currentWordStart, i);
          const decodedWord = decodeDNASequence(wordDNA);
          const tooltip = decodedWord ? ` title="${decodedWord}"` : "";
          html += `<span class="${className}"${tooltip}>${wordDNA}</span>`;
        }

        // Ajouter le reste de la séquence (ce qui reste après le dernier triplet complet)
        if (i < sequenceToColorize.length) {
          html += `<span>${sequenceToColorize.substring(i)}</span>`;
        }

        // Ajouter le marqueur et les positions "à trou" s'ils existent
        if (markerAndPositions) {
          html += `<span style="color: #999; font-size: 0.9em;">${markerAndPositions}</span>`;
        }

        return html;
      }

      // Fonction pour coloriser le textarea de décodage
      function colorizeDNAInput() {
        const dnaInput = document.getElementById("dnaInput");
        const text = dnaInput.innerText || dnaInput.textContent || "";
        const cleaned = text.toUpperCase().replace(/[^ATCG]/g, "");

        if (cleaned.length === 0) {
          if (text.length === 0) {
            dnaInput.innerHTML = "";
          }
          return;
        }

        const colored = colorizeDNAForDecode(cleaned);
        // Ne mettre à jour que si le contenu a changé pour éviter les problèmes de curseur
        if (dnaInput.innerHTML !== colored) {
          dnaInput.innerHTML = colored;
        }
      }

      function decodeDNA() {
        const dnaInput = document.getElementById("dnaInput");
        // Récupérer le texte brut
        const rawInput = dnaInput.innerText || dnaInput.textContent || "";
        // Nettoyer pour le décodage (enlever tout sauf A, T, C, G)
        let input = rawInput.toUpperCase().replace(/[^ATCG]/g, "");

        // Extraire les positions "à trou" AVANT de retirer le marqueur (chercher TGGTGG)
        const trouIndices = decodeTrouPositions(input);

        // Retirer le marqueur et les positions de la séquence à décoder
        const markerIndex = input.indexOf(TROU_MARKER);
        if (markerIndex !== -1) {
          input = input.substring(0, markerIndex);
        }

        const output = document.getElementById("output");
        output.innerHTML = "";
        const startIndex = input.indexOf("ATG");
        if (startIndex === -1) {
          output.textContent = "Aucun codon START (ATG) trouvé.";
          return;
        }

        // Décoder le message et créer la correspondance mot -> séquence ADN
        const words = []; // Liste des mots (décodés ou ADN)
        const wordToDNA = {}; // Correspondance mot -> séquence ADN
        let currentWord = "";
        let currentWordDNA = "";
        let wordIndex = 0; // Index du mot actuel
        let foundStopCodon = false; // Indicateur si on a trouvé un codon stop

        let nextIsCapital = false; // Indique si le prochain caractère doit être en majuscule

        for (let i = startIndex + 3; i <= input.length - 3; i += 3) {
          const codon = input.substring(i, i + 3);

          // Vérifier si c'est le marqueur de majuscule AAA
          if (codon === "AAA") {
            nextIsCapital = true;
            continue; // Passer au codon suivant
          }

          if (["TAA", "TAG", "TGA"].includes(codon)) {
            if (currentWord || currentWordDNA) {
              if (trouIndices.has(wordIndex)) {
                // Mot "à trou" : garder la séquence ADN
                words.push({
                  type: "trou",
                  content: currentWordDNA,
                  dna: currentWordDNA,
                });
              } else {
                // Mot normal : décoder
                if (currentWord) {
                  wordToDNA[currentWord] = currentWordDNA;
                  words.push({
                    type: "normal",
                    content: currentWord,
                    dna: currentWordDNA,
                  });
                }
              }
              currentWord = "";
              currentWordDNA = "";
            }
            // Ajouter un point seulement si le dernier élément ajouté n'est pas déjà un point
            // Ignorer les codons stop consécutifs
            let shouldAddPoint = true;
            if (words.length > 0) {
              const lastElement = words[words.length - 1];
              // Ne pas ajouter de point si le dernier élément est déjà un point
              if (
                lastElement.type === "punctuation" &&
                lastElement.content === "."
              ) {
                shouldAddPoint = false;
              }
            }

            if (shouldAddPoint) {
              words.push({ type: "punctuation", content: "." });
            }
            foundStopCodon = true;
            // Ne pas break, continuer après le codon stop
            // Ignorer les codons stop consécutifs en sautant directement au prochain codon non-stop
            while (i + 3 <= input.length - 3) {
              const nextCodon = input.substring(i + 3, i + 6);
              if (["TAA", "TAG", "TGA"].includes(nextCodon)) {
                i += 3; // Sauter ce codon stop aussi
              } else {
                break; // Prochain codon n'est pas un stop, continuer normalement
              }
            }
            wordIndex++; // Passer au mot suivant après le point
          }

          if (codon === "TTT") {
            // Espace
            if (currentWord || currentWordDNA) {
              if (trouIndices.has(wordIndex)) {
                // Mot "à trou" : garder la séquence ADN
                words.push({
                  type: "trou",
                  content: currentWordDNA,
                  dna: currentWordDNA,
                });
              } else {
                // Mot normal : décoder
                if (currentWord) {
                  wordToDNA[currentWord] = currentWordDNA;
                  words.push({
                    type: "normal",
                    content: currentWord,
                    dna: currentWordDNA,
                  });
                }
              }
              currentWord = "";
              currentWordDNA = "";
            }
            words.push({ type: "space", content: " " });
            wordIndex++; // Passer au mot suivant
          } else {
            const decodedChar = geneticCode[codon];
            if (decodedChar) {
              // Forcer les minuscules accentuées à s'afficher en majuscules
              let displayChar = decodedChar;
              if (decodedChar === "é") displayChar = "É";
              if (decodedChar === "è") displayChar = "È";
              if (decodedChar === "ê") displayChar = "Ê";
              if (decodedChar === "ë") displayChar = "Ë";
              if (decodedChar === "ï") displayChar = "Ï";

              // Appliquer la majuscule si AAA a été rencontré avant
              if (nextIsCapital && displayChar && displayChar.length === 1) {
                displayChar = displayChar.toUpperCase();
                nextIsCapital = false;
              }

              currentWordDNA += codon;
              // Si ce mot est "à trou", ne pas décoder
              if (!trouIndices.has(wordIndex)) {
                currentWord += displayChar;
              }
            }
          }
        }

        // Ajouter le dernier mot s'il existe (même après un codon stop, car on peut avoir plusieurs phrases)
        if (currentWord || currentWordDNA) {
          if (trouIndices.has(wordIndex)) {
            // Mot "à trou" : garder la séquence ADN
            words.push({
              type: "trou",
              content: currentWordDNA,
              dna: currentWordDNA,
            });
          } else {
            // Mot normal : décoder
            if (currentWord) {
              wordToDNA[currentWord] = currentWordDNA;
              words.push({
                type: "normal",
                content: currentWord,
                dna: currentWordDNA,
              });
            }
          }
        }

        // Fonction pour vérifier si une chaîne est une séquence ADN pure
        function isDNASequence(str) {
          return /^[ATCG]+$/i.test(str) && str.length >= 3;
        }

        // Afficher le texte décodé avec les mots "à trou" en séquence ADN
        let html = "";
        for (let word of words) {
          if (word.type === "space") {
            html += `<span class="word-space">${word.content}</span>`;
          } else if (word.type === "punctuation") {
            html += `<span>${word.content}</span>`;
          } else if (word.type === "trou") {
            // Afficher la séquence ADN avec double-clic
            html += `<span class="word-trou decode-dna" data-dna="${word.content}" style="font-family: monospace; background: #ff6b6b; padding: 4px 6px; border-radius: 4px; cursor: pointer;" title="Double-cliquez pour décoder">${word.content}</span>`;
          } else {
            // Mot normal - vérifier si c'est une séquence ADN pure
            if (isDNASequence(word.content)) {
              html += `<span class="decode-dna" data-dna="${word.content}" style="font-family: monospace; background: #ffb3d9; padding: 4px 6px; border-radius: 4px; cursor: pointer;" title="Double-cliquez pour décoder">${word.content}</span>`;
            } else {
              const length = word.content.length;
              const className = getWordClass(length);
              const tooltip = wordToDNA[word.content]
                ? ` title="${wordToDNA[word.content]}"`
                : "";
              html += `<span class="${className}"${tooltip}>${word.content}</span>`;
            }
          }
        }

        output.innerHTML = html;

        // Ajouter les événements double-clic sur les séquences ADN
        output.querySelectorAll(".decode-dna").forEach((span) => {
          span.addEventListener("dblclick", function () {
            const dnaSequence = this.getAttribute("data-dna");
            openDecodeModal(dnaSequence, this);
          });
        });
      }

      // Fonction pour ouvrir la modale de décodage interactif
      function openDecodeModal(dnaSequence, originalSpan = null) {
        const modal = document.getElementById("decodeModal");
        const modalContent = document.getElementById("modalContent");

        // Nettoyer la séquence (enlever tout sauf A, T, C, G)
        const cleaned = dnaSequence.toUpperCase().replace(/[^ATCG]/g, "");

        if (cleaned.length < 3) {
          alert("Séquence ADN trop courte pour être décodée.");
          return;
        }

        // Stocker la référence au span original pour pouvoir le remplacer
        window.modalOriginalSpan = originalSpan;
        window.modalDNASequence = cleaned;

        // Récupérer le mot déjà saisi s'il existe (pour préremplir)
        let existingWord = "";
        if (originalSpan && originalSpan.classList.contains("decode-filled")) {
          existingWord = originalSpan.textContent || "";
        }

        // Diviser en triplets et décoder avec gestion de AAA
        const triplets = [];
        const decodedChars = [];
        let nextIsCapital = false;
        let correctWord = ""; // Mot correct décodé

        for (let i = 0; i <= cleaned.length - 3; i += 3) {
          const triplet = cleaned.substring(i, i + 3);
          triplets.push(triplet);

          if (triplet === "AAA") {
            decodedChars.push({ char: "Majuscule", isMarker: true });
            nextIsCapital = true;
          } else {
            const decodedChar = geneticCode[triplet];
            if (decodedChar) {
              let displayChar = decodedChar;
              // Forcer les minuscules accentuées à s'afficher en majuscules
              if (decodedChar === "é") displayChar = "É";
              if (decodedChar === "è") displayChar = "È";
              if (decodedChar === "ê") displayChar = "Ê";
              if (decodedChar === "ë") displayChar = "Ë";
              if (decodedChar === "ï") displayChar = "Ï";

              // Appliquer la majuscule si AAA a été rencontré avant
              if (
                nextIsCapital &&
                displayChar &&
                displayChar.length === 1 &&
                displayChar !== "Majuscule"
              ) {
                displayChar = displayChar.toUpperCase();
                nextIsCapital = false;
              }

              decodedChars.push({ char: displayChar, isMarker: false });
              // Construire le mot correct (sans les marqueurs)
              correctWord += displayChar;
            } else {
              decodedChars.push({ char: "?", isMarker: false });
            }
          }
        }

        // Stocker le mot correct pour la validation
        window.modalCorrectWord = correctWord;

        // Créer le contenu de la modale
        let html = '<div style="margin-bottom: 30px;">';
        html +=
          '<h3 style="color: #667eea; margin-bottom: 15px;">Séquence ADN : ' +
          cleaned +
          "</h3>";

        // Première ligne : inputs pour les lettres (ou marqueur pour AAA)
        html +=
          '<div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px; justify-content: center; align-items: center;">';
        let existingWordIndex = 0; // Index pour parcourir le mot existant
        decodedChars.forEach((item, index) => {
          if (item.isMarker) {
            // Afficher "Maj" pour le marqueur AAA
            html += `<div style="width: 40px; height: 40px; text-align: center; font-size: 0.8rem; border: 2px solid #ffa94d; border-radius: 6px; background: #fff4e6; display: flex; align-items: center; justify-content: center; font-weight: bold; color: #ffa94d;">Maj</div>`;
          } else {
            // Préremplir avec la lettre existante si disponible
            const existingLetter =
              existingWord && existingWordIndex < existingWord.length
                ? existingWord[existingWordIndex].toUpperCase()
                : "";
            existingWordIndex++;

            html += `<input type="text" 
                            id="letter-${index}" 
                            maxlength="1" 
                            value="${existingLetter}"
                            style="width: 40px; height: 40px; text-align: center; font-size: 1.5rem; border: 2px solid #667eea; border-radius: 6px; font-weight: bold; text-transform: uppercase;"
                            placeholder="?"
                            oninput="this.value = this.value.toUpperCase()">`;
          }
        });
        html += "</div>";

        // Bouton de validation
        html += '<div style="text-align: center; margin: 20px 0;">';
        html +=
          '<button id="validateDecode" style="background: #51cf66; color: white; border: none; padding: 15px 30px; border-radius: 8px; cursor: pointer; font-size: 1.1rem; font-weight: bold;">Valider</button>';
        html += "</div>";

        // Deuxième ligne : les triplets
        html +=
          '<div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 30px; justify-content: center; font-family: monospace;">';
        triplets.forEach((triplet, index) => {
          const isStop = ["TAA", "TAG", "TGA"].includes(triplet);
          const isAAA = triplet === "AAA";
          let bgColor = "#e0e0e0";
          if (isStop) bgColor = "#ffb3d9";
          else if (isAAA) bgColor = "#fff4e6";
          html += `<div style="width: 40px; height: 30px; text-align: center; padding-top: 5px; background: ${bgColor}; border-radius: 4px; font-size: 0.9rem; border: ${
            isAAA ? "2px solid #ffa94d" : "none"
          };">${triplet}</div>`;
        });
        html += "</div>";

        // Troisième ligne : code génétique (tableau)
        html +=
          '<div style="margin-top: 30px; border-top: 2px solid #e0e0e0; padding-top: 20px;">';
        html +=
          '<h3 style="color: #667eea; margin-bottom: 15px;">Code Génétique</h3>';
        html += '<div style="overflow-x: auto;">';
        html +=
          '<table style="width: 100%; border-collapse: collapse; margin: 0 auto;">';
        html += "<thead><tr>";
        for (let i = 0; i < 4; i++) {
          html +=
            '<th style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px; text-align: center;">Codon</th>';
          html +=
            '<th style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px; text-align: center;">Symbole</th>';
        }
        html += "</tr></thead><tbody>";

        // Remplir le tableau avec le code génétique (même logique que la page principale)
        const entries = Object.entries(geneticCode)
          .filter(([k, v]) => v !== "START")
          .sort(([a], [b]) => a.localeCompare(b));
        const numColumns = 4;
        const entriesPerColumn = Math.ceil(entries.length / numColumns);

        // Créer les lignes
        const tableRows = [];
        for (let i = 0; i < entriesPerColumn; i++) {
          const rowData = [];
          for (let j = 0; j < numColumns * 2; j++) {
            rowData.push(null);
          }
          tableRows.push(rowData);
        }

        // Remplir colonne par colonne (verticalement)
        entries.forEach(([codon, symbol], index) => {
          const columnIndex = Math.floor(index / entriesPerColumn);
          const rowIndex = index % entriesPerColumn;

          if (columnIndex >= numColumns) return;

          const codonCellIndex = columnIndex * 2;
          const symbolCellIndex = codonCellIndex + 1;

          tableRows[rowIndex][codonCellIndex] = codon;
          tableRows[rowIndex][symbolCellIndex] = symbol;
        });

        // Générer le HTML des lignes
        tableRows.forEach((row) => {
          html += "<tr>";
          for (let i = 0; i < row.length; i += 2) {
            const codon = row[i];
            const symbol = row[i + 1];
            if (codon && symbol) {
              const isStop = ["TAA", "TAG", "TGA"].includes(codon);
              const bgColor = isStop ? "#ffb3d9" : "";
              html += `<td style="padding: 8px; text-align: center; border: 1px solid #ddd; background: ${bgColor}; font-family: monospace;">${codon}</td>`;
              html += `<td style="padding: 8px; text-align: center; border: 1px solid #ddd; background: ${bgColor};">${symbol}</td>`;
            } else {
              html += '<td style="padding: 8px; border: 1px solid #ddd;"></td>';
              html += '<td style="padding: 8px; border: 1px solid #ddd;"></td>';
            }
          }
          html += "</tr>";
        });

        html += "</tbody></table>";
        html += "</div>";
        html += "</div>";

        modalContent.innerHTML = html;
        modal.style.display = "block";

        // Stocker les données pour la fonction de validation
        window.modalDecodedChars = decodedChars;

        // Fonction pour valider et remplacer la séquence ADN par le mot saisi
        window.validateDecode = function () {
          let userWord = "";

          // Récupérer toutes les lettres saisies
          if (window.modalDecodedChars) {
            window.modalDecodedChars.forEach((item, index) => {
              if (item.isMarker) {
                // Pour AAA, on ne met rien (c'est juste un marqueur)
              } else {
                const input = document.getElementById(`letter-${index}`);
                if (input) {
                  const letter = input.value.trim().toUpperCase();
                  userWord += letter || "?";
                }
              }
            });
          }

          // Remplacer le span original par le mot saisi
          if (window.modalOriginalSpan && userWord) {
            // Créer un nouveau span avec le mot saisi
            const newSpan = document.createElement("span");
            newSpan.textContent = userWord;
            newSpan.className =
              window.modalOriginalSpan.className + " decode-filled";
            // Stocker la séquence ADN originale pour pouvoir la modifier à nouveau
            newSpan.setAttribute("data-dna", window.modalDNASequence);

            // Comparer le mot saisi avec le mot correct
            const correctWord = window.modalCorrectWord || "";

            // Normaliser les deux chaînes pour la comparaison
            // Convertir en majuscules et normaliser les caractères accentués
            function normalizeForComparison(str) {
              return str.toUpperCase().normalize("NFC"); // Normaliser en forme composée canonique
            }

            const normalizedUser = normalizeForComparison(userWord);
            const normalizedCorrect = normalizeForComparison(correctWord);

            // Comparaison avec debug (peut être retiré après)
            console.log(
              "User word:",
              userWord,
              "-> Normalized:",
              normalizedUser
            );
            console.log(
              "Correct word:",
              correctWord,
              "-> Normalized:",
              normalizedCorrect
            );
            console.log("Match:", normalizedUser === normalizedCorrect);

            // Comparaison directe en majuscules (fallback)
            const directComparison =
              userWord.toUpperCase() === correctWord.toUpperCase();
            console.log("Direct comparison:", directComparison);

            // Utiliser les deux méthodes de comparaison
            const isCorrect =
              normalizedUser === normalizedCorrect || directComparison;

            console.log("Final isCorrect:", isCorrect);

            // Appliquer la couleur selon la justesse
            if (isCorrect) {
              // Vert pastel si correct
              console.log("Applying green color");
              newSpan.style.setProperty("background", "#b3ffb3", "important");
              newSpan.style.setProperty(
                "background-color",
                "#b3ffb3",
                "important"
              );
            } else {
              // Rouge pastel si incorrect
              console.log("Applying red color");
              newSpan.style.setProperty("background", "#ffb3b3", "important");
              newSpan.style.setProperty(
                "background-color",
                "#ffb3b3",
                "important"
              );
            }

            console.log("Final background color:", newSpan.style.background);
            console.log(
              "Final computed style:",
              window.getComputedStyle(newSpan).backgroundColor
            );

            newSpan.style.cursor = "pointer";
            newSpan.title = "Double-cliquez pour modifier";

            // Ajouter l'événement de double-clic pour permettre de modifier à nouveau
            newSpan.addEventListener("dblclick", function () {
              const dnaSequence = this.getAttribute("data-dna");
              openDecodeModal(dnaSequence, this);
            });

            // Remplacer l'ancien span par le nouveau
            window.modalOriginalSpan.parentNode.replaceChild(
              newSpan,
              window.modalOriginalSpan
            );
          }

          // Fermer la modale
          const modal = document.getElementById("decodeModal");
          if (modal) {
            modal.style.display = "none";
          }
        };

        // Ajouter l'événement sur le bouton de validation
        setTimeout(() => {
          const validateBtn = document.getElementById("validateDecode");
          if (validateBtn) {
            validateBtn.addEventListener("click", window.validateDecode);
          }

          // Fonction pour trouver l'index de la prochaine case (en sautant les marqueurs)
          function findNextInputIndex(currentIndex, direction) {
            let nextIndex = currentIndex;
            const maxIndex = window.modalDecodedChars.length - 1;
            const startIndex = currentIndex;
            let iterations = 0;

            do {
              if (direction === 1) {
                // Vers la droite
                nextIndex = (nextIndex + 1) % (maxIndex + 1);
              } else {
                // Vers la gauche
                nextIndex = (nextIndex - 1 + maxIndex + 1) % (maxIndex + 1);
              }
              iterations++;
              // Protection contre les boucles infinies
              if (iterations > maxIndex + 1) {
                return currentIndex; // Retourner l'index actuel si on ne trouve rien
              }
            } while (
              window.modalDecodedChars[nextIndex] &&
              window.modalDecodedChars[nextIndex].isMarker &&
              nextIndex !== startIndex
            );

            return nextIndex;
          }

          // Ajouter la gestion du clavier sur tous les inputs
          window.modalDecodedChars.forEach((item, index) => {
            if (!item.isMarker) {
              const input = document.getElementById(`letter-${index}`);
              if (input) {
                input.addEventListener("keydown", function (e) {
                  if (e.key === "Enter") {
                    e.preventDefault();
                    // Passer à la case suivante
                    const nextIndex = findNextInputIndex(index, 1);
                    const nextInput = document.getElementById(
                      `letter-${nextIndex}`
                    );
                    if (nextInput) {
                      nextInput.focus();
                      nextInput.select();
                    }
                  } else if (e.key === "ArrowRight") {
                    e.preventDefault();
                    // Aller à la case suivante
                    const nextIndex = findNextInputIndex(index, 1);
                    const nextInput = document.getElementById(
                      `letter-${nextIndex}`
                    );
                    if (nextInput) {
                      nextInput.focus();
                      nextInput.select();
                    }
                  } else if (e.key === "ArrowLeft") {
                    e.preventDefault();
                    // Aller à la case précédente
                    const prevIndex = findNextInputIndex(index, -1);
                    const prevInput = document.getElementById(
                      `letter-${prevIndex}`
                    );
                    if (prevInput) {
                      prevInput.focus();
                      prevInput.select();
                    }
                  }
                });
              }
            }
          });
        }, 10);
      }

      // Fermer la modale
      document
        .getElementById("closeModal")
        .addEventListener("click", function () {
          document.getElementById("decodeModal").style.display = "none";
        });

      // Fermer la modale en cliquant en dehors
      document
        .getElementById("decodeModal")
        .addEventListener("click", function (e) {
          if (e.target === this) {
            this.style.display = "none";
          }
        });

      // Fonction pour normaliser le texte (tous les types d'apostrophes -> apostrophe standard)
      function normalizeText(text) {
        if (!text) return text;
        // Normaliser tous les types d'apostrophes vers l'apostrophe standard
        // Utiliser les codes Unicode pour capturer tous les types possibles
        // U+0027: ' (apostrophe droite)
        // U+2018: ' (guillemet simple ouvrant)
        // U+2019: ' (apostrophe typographique)
        // U+201A: ‚ (guillemet-virgule inférieur)
        // U+201B: ‛ (guillemet simple ouvrant renversé)
        // U+2032: ′ (prime)
        // U+2035: ‵ (prime renversée)
        // U+02BC: ʼ (lettre modificative apostrophe)
        // U+02BB: ʻ (lettre modificative guillemet simple)
        // U+0060: ` (accent grave)
        // U+00B4: ´ (accent aigu)
        // Utiliser une approche plus permissive pour capturer tous les caractères similaires
        let normalized = text;
        // Normaliser tous les types d'espaces vers l'espace standard (U+0020)
        // U+0020: espace standard
        // U+00A0: espace insécable
        // U+2000-U+200B: différents types d'espaces (en quadratin, cadratin, etc.)
        // U+202F: espace insécable étroit
        // U+205F: espace mathématique moyen
        // U+3000: espace idéographique
        normalized = normalized.replace(
          /[\u00A0\u2000-\u200B\u202F\u205F\u3000]/g,
          " "
        );
        // Remplacer tous les types d'apostrophes par l'apostrophe standard
        normalized = normalized.replace(/[''‚‛′‵ʼʻ`´]/g, "'");
        // Remplacer aussi par code Unicode pour être sûr
        normalized = normalized.replace(
          /[\u0027\u2018\u2019\u201A\u201B\u2032\u2035\u02BC\u02BB\u0060\u00B4]/g,
          "'"
        );
        // Guillemets typographiques
        normalized = normalized.replace(/[""]/g, '"');
        normalized = normalized.replace(/[""]/g, '"');
        return normalized;
      }

      // Fonction pour obtenir la classe CSS selon le nombre de nucléotides
      function getNucleotideClass(nucleotideCount) {
        if (nucleotideCount <= 12) return "word-short";
        if (nucleotideCount <= 18) return "word-medium";
        if (nucleotideCount <= 27) return "word-long";
        return "word-verylong";
      }

      // Fonction pour colorer la séquence ADN selon la longueur des mots
      function colorizeDNA(dna, wordPositions, dnaToText = null) {
        currentWordPositions = wordPositions.filter((w) => w.type === "word");
        let wordIndex = 0;
        let html = `<span>${dna.substring(0, 3)}</span>`; // ATG au début
        let lastEnd = 3; // Position après ATG

        for (let word of wordPositions) {
          // Vérifier s'il y a des codons stop entre lastEnd et word.start
          for (let i = lastEnd; i < word.start; i += 3) {
            const codon = dna.substring(i, i + 3);
            if (["TAA", "TAG", "TGA"].includes(codon)) {
              html += `<span class="word-stop" title="Point">${codon}</span>`;
              lastEnd = i + 3;
            }
          }

          if (word.type === "space") {
            // Espace (TTT = 3 nucléotides)
            html += `<span class="word-space">${dna.substring(
              word.start,
              word.end
            )}</span>`;
            lastEnd = word.end;
          } else {
            // Mot
            const nucleotideCount = word.end - word.start;
            let className = getNucleotideClass(nucleotideCount);
            const wordDNA = dna.substring(word.start, word.end);
            const tooltip =
              dnaToText && dnaToText[wordDNA]
                ? ` title="${dnaToText[wordDNA]}"`
                : "";

            // Ajouter la classe "word-trou" si le mot est sélectionné
            if (trouModeActive && selectedWordIndices.has(wordIndex)) {
              className += " word-trou";
            }

            // Ajouter l'événement de double-clic si le mode est actif
            const dataIndex = trouModeActive
              ? ` data-word-index="${wordIndex}" ondblclick="toggleWordTrou(${wordIndex})" style="cursor: pointer;"`
              : "";

            html += `<span class="${className}"${tooltip}${dataIndex}>${wordDNA}</span>`;
            lastEnd = word.end;
            wordIndex++;
          }
        }

        // Vérifier s'il y a des codons stop après le dernier mot
        for (let i = lastEnd; i <= dna.length - 3; i += 3) {
          const codon = dna.substring(i, i + 3);
          if (["TAA", "TAG", "TGA"].includes(codon)) {
            html += `<span class="word-stop" title="Point">${codon}</span>`;
            lastEnd = i + 3;
          } else {
            break; // Arrêter si on rencontre un autre codon
          }
        }

        // Ajouter le reste de la séquence (s'il y en a)
        if (lastEnd < dna.length) {
          html += `<span>${dna.substring(lastEnd)}</span>`;
        }

        return html;
      }

      // Fonction pour basculer un mot en mode "à trou"
      function toggleWordTrou(wordIndex) {
        if (!trouModeActive) return;

        if (selectedWordIndices.has(wordIndex)) {
          selectedWordIndices.delete(wordIndex);
        } else {
          selectedWordIndices.add(wordIndex);
        }

        // Réencoder pour mettre à jour l'affichage
        encodeText();
      }

      function encodeText() {
        const input = document.getElementById("textInput").value;
        const normalized = normalizeText(input);
        const output = document.getElementById("dnaOutput");
        let dna = "ATG";
        const wordPositions = [];
        const dnaToText = {}; // Correspondance ADN -> texte
        let currentWordStart = 3; // Après ATG
        let currentWordText = ""; // Texte du mot en cours
        let inWord = false;
        let isStartOfSentence = true; // Pour détecter le début de phrase

        for (let char of normalized) {
          let codonLength = 0;
          let needsCapital = false; // Indique si le caractère doit être en majuscule
          // Gérer les caractères spéciaux en premier (ponctuation)
          if (char === ".") {
            dna += "TAA";
            codonLength = 3;
            isStartOfSentence = true; // Après un point, on est au début d'une phrase
          }
          // Gérer l'apostrophe (tous les types normalisés vers ')
          // Vérifier aussi directement les codes Unicode au cas où la normalisation n'a pas fonctionné
          else if (
            char === "'" ||
            char === "'" ||
            char === "'" ||
            char === "'" ||
            char.charCodeAt(0) === 0x0027 ||
            char.charCodeAt(0) === 0x2019 ||
            char.charCodeAt(0) === 0x2018
          ) {
            dna += "TTC";
            codonLength = 3;
            if (inWord) {
              currentWordText += "'";
            }
          }
          // Gérer les espaces (tous les types normalisés vers espace standard)
          // Vérifier aussi directement les codes Unicode au cas où la normalisation n'a pas fonctionné
          else if (
            char === " " ||
            char.charCodeAt(0) === 0x0020 ||
            char.charCodeAt(0) === 0x00a0 ||
            (char.charCodeAt(0) >= 0x2000 && char.charCodeAt(0) <= 0x200b) ||
            char.charCodeAt(0) === 0x202f ||
            char.charCodeAt(0) === 0x205f ||
            char.charCodeAt(0) === 0x3000
          ) {
            if (inWord) {
              // Finir le mot précédent
              const wordDNA = dna.substring(currentWordStart, dna.length);
              if (currentWordText) {
                dnaToText[wordDNA] = currentWordText;
              }
              wordPositions.push({
                type: "word",
                start: currentWordStart,
                end: dna.length,
              });
              inWord = false;
              currentWordText = "";
            }
            const spaceStart = dna.length;
            dna += "TTT";
            wordPositions.push({
              type: "space",
              start: spaceStart,
              end: dna.length,
            });
            currentWordStart = dna.length;
            continue;
          }
          // Gérer les caractères accentués (toujours en majuscule)
          else if (char === "é" || char === "É") {
            // É est toujours en majuscule, donc ajouter AAA
            dna += "AAAAGG"; // AAA (majuscule) + AGG (É)
            codonLength = 6;
            if (inWord) currentWordText += "É";
            needsCapital = false;
            isStartOfSentence = false;
          } else if (char === "è" || char === "È") {
            dna += "AAAAGT"; // AAA (majuscule) + AGT (È)
            codonLength = 6;
            if (inWord) currentWordText += "È";
            needsCapital = false;
            isStartOfSentence = false;
          } else if (char === "ê" || char === "Ê") {
            dna += "AAAATA"; // AAA (majuscule) + ATA (Ê)
            codonLength = 6;
            if (inWord) currentWordText += "Ê";
            needsCapital = false;
            isStartOfSentence = false;
          } else if (char === "ë" || char === "Ë") {
            dna += "AAAATC"; // AAA (majuscule) + ATC (Ë)
            codonLength = 6;
            if (inWord) currentWordText += "Ë";
            needsCapital = false;
            isStartOfSentence = false;
          } else if (char === "ï" || char === "Ï") {
            dna += "AAACCG"; // AAA (majuscule) + CCG (Ï)
            codonLength = 6;
            if (inWord) currentWordText += "Ï";
            needsCapital = false;
            isStartOfSentence = false;
          }
          // Pour les autres caractères
          else {
            let upperChar = char.toUpperCase();
            let lowerChar = char.toLowerCase();
            // Détecter si c'est une majuscule ou le début d'une phrase
            needsCapital =
              (char === upperChar && char !== lowerChar) || isStartOfSentence;

            if (reverseCode[upperChar]) {
              if (needsCapital) {
                dna += "AAA"; // Marqueur de majuscule
              }
              dna += reverseCode[upperChar][0];
              codonLength = needsCapital ? 6 : 3;
              if (inWord) currentWordText += upperChar;
              isStartOfSentence = false;
            }
            // Les caractères non codables sont simplement ignorés
          }

          if (codonLength > 0) {
            if (!inWord) {
              currentWordStart = dna.length - codonLength;
              inWord = true;
              // Initialiser le texte du mot avec le premier caractère
              if (char === "é" || char === "É") {
                currentWordText = "É";
              } else if (char === "è" || char === "È") {
                currentWordText = "È";
              } else if (char === "ê" || char === "Ê") {
                currentWordText = "Ê";
              } else if (char === "ë" || char === "Ë") {
                currentWordText = "Ë";
              } else if (char === "ï" || char === "Ï") {
                currentWordText = "Ï";
              } else if (
                char === "'" ||
                char === "'" ||
                char === "'" ||
                char === "'"
              ) {
                currentWordText = "'";
              } else if (char !== ".") {
                currentWordText = char.toUpperCase();
              } else {
                currentWordText = "";
              }
            }
          }
        }

        // Ajouter le dernier mot s'il existe
        if (inWord) {
          const wordDNA = dna.substring(currentWordStart, dna.length);
          if (currentWordText) {
            dnaToText[wordDNA] = currentWordText;
          }
          wordPositions.push({
            type: "word",
            start: currentWordStart,
            end: dna.length,
          });
        }

        // Ajouter les positions des mots "à trou" à la fin de la séquence si le mode est actif
        const copyBtn = document.getElementById("copyBtn");
        const exportEDIBtn = document.getElementById("exportEDIBtn");
        const exportFASTABtn = document.getElementById("exportFASTABtn");

        // Stocker la séquence de base (sans marqueurs "à trou")
        output.setAttribute("data-dna-base", dna);

        // Toujours afficher la séquence ADN colorisée
        const coloredDNA = colorizeDNA(dna, wordPositions, dnaToText);

        if (trouModeActive && selectedWordIndices.size > 0) {
          const trouPositions = encodeTrouPositions(selectedWordIndices);
          const fullSequence = dna + trouPositions;
          // Stocker la séquence complète avec les positions dans un attribut data
          output.setAttribute("data-dna-sequence", fullSequence);
          output.setAttribute("data-trou-positions", trouPositions);
          // Afficher la séquence ADN colorisée (le texte reste visible)
          output.innerHTML =
            coloredDNA ||
            '<span style="color: #666;">Aucune séquence à afficher.</span>';
          // Afficher les boutons
          copyBtn.style.display = "inline-block";
          exportEDIBtn.style.display = "inline-block";
          exportFASTABtn.style.display = "inline-block";
        } else if (trouModeActive) {
          // Mode "à trou" actif mais aucun mot sélectionné - afficher quand même la séquence
          output.setAttribute("data-dna-sequence", dna);
          output.removeAttribute("data-trou-positions");
          output.innerHTML =
            coloredDNA ||
            '<span style="color: #666;">Aucune séquence à afficher. Double-cliquez sur les mots pour les sélectionner.</span>';
          // Afficher les boutons d'export
          copyBtn.style.display = "none";
          exportEDIBtn.style.display = "inline-block";
          exportFASTABtn.style.display = "inline-block";
        } else {
          // Mode "à trou" désactivé
          output.setAttribute("data-dna-sequence", dna);
          output.removeAttribute("data-trou-positions");
          output.innerHTML = coloredDNA || "";
          // Afficher les boutons d'export même sans "à trou"
          copyBtn.style.display = "none";
          exportEDIBtn.style.display = "inline-block";
          exportFASTABtn.style.display = "inline-block";
        }
      }

      // Fonction pour copier la séquence ADN avec les marqueurs "à trou"
      function copyDNAWithTrous() {
        const output = document.getElementById("dnaOutput");
        const fullSequence = output.getAttribute("data-dna-sequence");

        if (fullSequence) {
          // Copier la séquence complète (déjà avec le marqueur et les positions)
          navigator.clipboard
            .writeText(fullSequence)
            .then(() => {
              const btn = document.getElementById("copyBtn");
              const originalText = btn.textContent;
              btn.textContent = "✓ Copié !";
              btn.style.background = "#51cf66";
              setTimeout(() => {
                btn.textContent = originalText;
              }, 2000);
            })
            .catch((err) => {
              console.error("Erreur lors de la copie:", err);
              alert(
                "Erreur lors de la copie. Veuillez sélectionner manuellement la séquence."
              );
            });
        }
      }

      // Fonction pour exporter la séquence ADN en format .edi
      function exportEDIFile() {
        const output = document.getElementById("dnaOutput");
        const fullSequence = output.getAttribute("data-dna-sequence");

        if (!fullSequence) {
          alert(
            "Aucune séquence à exporter. Veuillez d'abord encoder un texte."
          );
          return;
        }

        // Format .edi : format simple avec la séquence ADN (peut être réimporté)
        // On exporte juste la séquence ADN, le format .edi sera reconnu par l'import
        const ediFile = fullSequence;

        // Créer un blob et télécharger
        const blob = new Blob([ediFile], { type: "text/plain;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "sequence_encodée.edi");
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // Fonction pour exporter la séquence ADN en format .fasta
      function exportFASTAFile() {
        const output = document.getElementById("dnaOutput");
        const fullSequence = output.getAttribute("data-dna-sequence");

        if (!fullSequence) {
          alert(
            "Aucune séquence à exporter. Veuillez d'abord encoder un texte."
          );
          return;
        }

        // Format FASTA : en-tête suivi de la séquence (60 caractères par ligne)
        const fastaContent = `>Sequence_ADN_encodee\n`;
        const sequenceLines = fullSequence.match(/.{1,60}/g) || [fullSequence];
        const fastaFile = fastaContent + sequenceLines.join("\n") + "\n";

        // Créer un blob et télécharger
        const blob = new Blob([fastaFile], {
          type: "text/plain;charset=utf-8;",
        });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "sequence_encodée.fasta");
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      const tbody = document.getElementById("codeTable");
      const entries = Object.entries(geneticCode)
        .filter(([k, v]) => v !== "START")
        .sort(([a], [b]) => a.localeCompare(b));

      // Organiser en 4 colonnes, remplir verticalement (colonne par colonne)
      const numColumns = 4; // 4 colonnes de paires Codon/Symbole
      const entriesPerColumn = Math.ceil(entries.length / numColumns);

      // Créer toutes les lignes nécessaires avec toutes les cellules vides
      const rows = [];
      for (let i = 0; i < entriesPerColumn; i++) {
        const row = document.createElement("tr");
        // Créer 8 cellules vides (4 paires Codon/Symbole)
        for (let j = 0; j < numColumns * 2; j++) {
          const cell = document.createElement("td");
          row.appendChild(cell);
        }
        rows.push(row);
        tbody.appendChild(row);
      }

      // Remplir colonne par colonne (verticalement)
      // Colonne 0 : entrées 0, 1, 2, 3, ...
      // Colonne 1 : entrées entriesPerColumn, entriesPerColumn+1, ...
      // Colonne 2 : entrées 2*entriesPerColumn, 2*entriesPerColumn+1, ...
      // Colonne 3 : entrées 3*entriesPerColumn, 3*entriesPerColumn+1, ...
      entries.forEach(([codon, symbol], index) => {
        // Calculer la colonne et la ligne pour un remplissage vertical
        const columnIndex = Math.floor(index / entriesPerColumn);
        const rowIndex = index % entriesPerColumn;

        // S'assurer qu'on ne dépasse pas le nombre de colonnes
        if (columnIndex >= numColumns) return;

        const row = rows[rowIndex];

        // Trouver la position dans la ligne (chaque colonne = 2 cellules : Codon + Symbole)
        const codonCellIndex = columnIndex * 2;
        const symbolCellIndex = codonCellIndex + 1;

        // Remplir les cellules
        row.cells[codonCellIndex].textContent = codon;
        row.cells[symbolCellIndex].textContent = symbol;

        // Colorer les codons stop en rose pastel
        if (["TAA", "TAG", "TGA"].includes(codon)) {
          row.cells[codonCellIndex].style.backgroundColor = "#ffb3d9";
          row.cells[symbolCellIndex].style.backgroundColor = "#ffb3d9";
        }
      });

      // Coloriser le textarea de décodage en temps réel
      const dnaInput = document.getElementById("dnaInput");
      dnaInput.addEventListener("input", function () {
        setTimeout(colorizeDNAInput, 10);
      });
      dnaInput.addEventListener("paste", function () {
        setTimeout(colorizeDNAInput, 10); // Attendre que le collage soit terminé
      });

      // Fonction pour importer un fichier .edi
      function importEDIFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const text = e.target.result;
            const dnaInput = document.getElementById("dnaInput");

            // Format .edi : extraire la séquence ADN complète (y compris les marqueurs "à trou" TGGTGG)
            // On extrait toutes les séquences de nucléotides (A, T, C, G) pour préserver TGGTGG et les positions
            const sequences = text.match(/[ATCG]+/gi);

            if (sequences && sequences.length > 0) {
              // Concaténer toutes les séquences trouvées pour préserver les marqueurs "à trou"
              const dnaSequence = sequences.join("").toUpperCase();
              dnaInput.textContent = dnaSequence;
              colorizeDNAInput();
              alert("Fichier .edi importé avec succès !");
            } else {
              alert("Aucune séquence ADN trouvée dans le fichier .edi");
            }

            event.target.value = "";
          } catch (error) {
            alert(
              "Erreur lors de la lecture du fichier .edi : " + error.message
            );
            event.target.value = "";
          }
        };
        reader.readAsText(file);
      }

      // Fonction pour importer un fichier .fasta
      function importFASTAFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const text = e.target.result;
            const dnaInput = document.getElementById("dnaInput");

            // Format FASTA : les lignes commençant par > sont des en-têtes, les autres sont des séquences
            const lines = text.split("\n");
            let sequences = [];

            for (let line of lines) {
              line = line.trim();
              // Ignorer les lignes d'en-tête (commencent par >)
              if (line && !line.startsWith(">")) {
                // Extraire uniquement les caractères A, T, C, G (ignorer les espaces, retours à la ligne, etc.)
                const sequence = line.replace(/[^ATCGatcg]/g, "").toUpperCase();
                if (sequence.length > 0) {
                  sequences.push(sequence);
                }
              }
            }

            if (sequences.length > 0) {
              // Concaténer toutes les séquences trouvées
              const dnaSequence = sequences.join("");
              dnaInput.textContent = dnaSequence;
              colorizeDNAInput();
              alert("Fichier .fasta importé avec succès !");
            } else {
              alert("Aucune séquence ADN trouvée dans le fichier .fasta");
            }

            event.target.value = "";
          } catch (error) {
            alert(
              "Erreur lors de la lecture du fichier .fasta : " + error.message
            );
            event.target.value = "";
          }
        };
        reader.readAsText(file);
      }

      // Fonction pour charger la séquence de test
      function loadTestSequence() {
        const testText =
          "Science sans conscience n'est que ruine de l'âme. François Rabelais";

        // Mots à garder en séquence ADN (à trou)
        const wordsToKeepAsDNA = ["conscience", "ruine", "rabelais"];

        // Mettre le texte dans le champ d'encodage
        const textInput = document.getElementById("textInput");
        textInput.value = testText;

        // Vérifier que le texte est bien stocké
        console.log("Texte original, longueur:", testText.length);
        console.log("Texte dans input, longueur:", textInput.value.length);

        // Activer le mode "à trou"
        if (!trouModeActive) {
          toggleTrouMode();
        }

        // Encoder le texte
        encodeText();

        // Attendre un peu pour que l'encodage soit terminé
        setTimeout(() => {
          // Vérifier que le texte est toujours complet
          if (textInput.value.length !== testText.length) {
            console.warn("Le texte a été modifié, restauration...");
            textInput.value = testText;
          }
          // Trouver les indices des mots à marquer comme "à trou"
          const output = document.getElementById("dnaOutput");
          const wordPositions = currentWordPositions;

          // Vérifier la séquence de base
          const baseSequence = output.getAttribute("data-dna-base");
          console.log(
            "Séquence de base, longueur:",
            baseSequence ? baseSequence.length : 0
          );
          // Vérifier que la séquence de base est valide (commence par ATG et a une longueur minimale raisonnable)
          const isBaseValid =
            baseSequence &&
            baseSequence.length >= 6 && // Au moins ATG + un codon
            baseSequence.startsWith("ATG");

          if (!isBaseValid) {
            console.error(
              "Séquence de base invalide, attente supplémentaire..."
            );
            // Attendre un peu plus et réessayer
            setTimeout(() => {
              const retryBase = output.getAttribute("data-dna-base");
              const isRetryValid =
                retryBase &&
                retryBase.length >= 6 &&
                retryBase.startsWith("ATG");

              if (!isRetryValid) {
                alert(
                  "Erreur : la séquence n'a pas pu être encodée complètement. Veuillez réessayer."
                );
                return;
              }
            }, 300);
          }

          // Réinitialiser les sélections
          selectedWordIndices.clear();

          // Normaliser le texte original pour la comparaison
          const normalizedText = normalizeText(testText).toLowerCase();

          // Trouver les mots à marquer en comparant avec le texte original
          wordPositions.forEach((wordPos, index) => {
            if (wordPos.type === "word") {
              // Extraire le texte du mot depuis la séquence ADN
              const wordDNA = output
                .getAttribute("data-dna-base")
                .substring(wordPos.start, wordPos.end);
              // Décoder le mot pour comparer
              let decodedWord = "";
              let nextIsCapital = false;
              for (let i = 0; i <= wordDNA.length - 3; i += 3) {
                const codon = wordDNA.substring(i, i + 3);
                if (codon === "AAA") {
                  nextIsCapital = true;
                  continue;
                }
                const char = geneticCode[codon];
                if (char && char !== "START" && char !== "Majuscule") {
                  let displayChar = char;
                  if (char === "é") displayChar = "É";
                  if (char === "è") displayChar = "È";
                  if (char === "ê") displayChar = "Ê";
                  if (char === "ë") displayChar = "Ë";
                  if (char === "ï") displayChar = "Ï";
                  if (nextIsCapital && displayChar.length === 1) {
                    displayChar = displayChar.toUpperCase();
                    nextIsCapital = false;
                  }
                  decodedWord += displayChar;
                }
              }

              // Normaliser le mot décodé pour la comparaison
              const normalizedDecoded = normalizeText(decodedWord)
                .toLowerCase()
                .trim();

              // Vérifier si ce mot doit être gardé en ADN
              for (const wordToKeep of wordsToKeepAsDNA) {
                const normalizedWordToKeep =
                  normalizeText(wordToKeep).toLowerCase();
                if (normalizedDecoded === normalizedWordToKeep) {
                  selectedWordIndices.add(index);
                  break;
                }
              }
            }
          });

          // S'assurer que le texte est toujours complet avant le deuxième encodage
          if (textInput.value.length !== testText.length) {
            console.warn(
              "Texte modifié avant deuxième encodage, restauration..."
            );
            textInput.value = testText;
          }

          // Réencoder avec les mots sélectionnés
          encodeText();

          // Attendre un peu plus pour que l'encodage soit complètement terminé
          setTimeout(() => {
            // Vérifier à nouveau que le texte est complet
            if (textInput.value.length !== testText.length) {
              console.warn(
                "Texte modifié après deuxième encodage, restauration..."
              );
              textInput.value = testText;
            }

            // Récupérer la séquence complète avec les marqueurs "à trou"
            let fullSequence = output.getAttribute("data-dna-sequence");
            const baseSeq = output.getAttribute("data-dna-base");
            console.log(
              "Séquence de base après 2e encodage, longueur:",
              baseSeq ? baseSeq.length : 0
            );
            console.log(
              "Séquence complète après 2e encodage, longueur:",
              fullSequence ? fullSequence.length : 0
            );

            // S'assurer que la séquence se termine correctement par un point avant le marqueur "à trou"
            const markerIndex = fullSequence.indexOf(TROU_MARKER);
            if (markerIndex !== -1) {
              const beforeMarker = fullSequence.substring(0, markerIndex);
              const afterMarker = fullSequence.substring(markerIndex);

              // Trouver le dernier codon stop (point) dans la séquence avant le marqueur
              let lastStopIndex = -1;
              for (let i = beforeMarker.length - 3; i >= 0; i -= 3) {
                const codon = beforeMarker.substring(i, i + 3);
                if (["TAA", "TAG", "TGA"].includes(codon)) {
                  lastStopIndex = i;
                  break;
                }
              }

              // Si on a trouvé un point, s'assurer qu'il n'y a rien après (sauf le marqueur)
              if (lastStopIndex !== -1) {
                // Retirer tout ce qui est après le dernier point (espaces, etc.)
                const stopCodon = beforeMarker.substring(
                  lastStopIndex,
                  lastStopIndex + 3
                );
                fullSequence =
                  beforeMarker.substring(0, lastStopIndex) +
                  stopCodon +
                  afterMarker;
              } else {
                // Aucun point trouvé, ajouter TAA avant le marqueur
                fullSequence = beforeMarker + "TAA" + afterMarker;
              }
            } else {
              // Pas de marqueur, s'assurer que la séquence se termine par un point
              const lastCodon = fullSequence.substring(fullSequence.length - 3);
              if (!["TAA", "TAG", "TGA"].includes(lastCodon)) {
                // Retirer les espaces à la fin et ajouter un point
                let trimmed = fullSequence.replace(/TTT+$/, "");
                if (
                  !["TAA", "TAG", "TGA"].includes(
                    trimmed.substring(trimmed.length - 3)
                  )
                ) {
                  trimmed += "TAA";
                }
                fullSequence = trimmed;
              }
            }

            // Vérifier que la séquence est valide (contient au moins ATG et se termine correctement)
            const isValidSequence =
              fullSequence &&
              fullSequence.length >= 6 && // Au moins ATG + un codon
              fullSequence.startsWith("ATG") &&
              (fullSequence.includes(TROU_MARKER) ||
                ["TAA", "TAG", "TGA"].includes(
                  fullSequence.substring(fullSequence.length - 3)
                ));

            if (!isValidSequence) {
              console.warn("Séquence invalide, réencodage...");
              textInput.value = testText;
              encodeText();
              setTimeout(() => {
                fullSequence = output.getAttribute("data-dna-sequence");
                const retryIsValid =
                  fullSequence &&
                  fullSequence.length >= 6 &&
                  fullSequence.startsWith("ATG") &&
                  (fullSequence.includes(TROU_MARKER) ||
                    ["TAA", "TAG", "TGA"].includes(
                      fullSequence.substring(fullSequence.length - 3)
                    ));

                if (retryIsValid) {
                  console.log(
                    "Séquence valide récupérée après réessai, longueur:",
                    fullSequence.length
                  );
                  const dnaInput = document.getElementById("dnaInput");
                  dnaInput.textContent = fullSequence;
                  colorizeDNAInput();

                  // Désactiver le mode "à trou" pour revenir à l'état normal
                  if (trouModeActive) {
                    toggleTrouMode();
                  }
                } else {
                  console.error(
                    "Séquence toujours invalide, longueur:",
                    fullSequence ? fullSequence.length : 0
                  );
                  alert(
                    "Erreur : la séquence n'a pas pu être encodée correctement."
                  );
                }
              }, 200);
              return;
            }

            console.log(
              "Séquence complète récupérée, longueur:",
              fullSequence.length
            );

            // Insérer dans le champ de décodage
            const dnaInput = document.getElementById("dnaInput");
            dnaInput.textContent = fullSequence;
            colorizeDNAInput();

            // Désactiver le mode "à trou" pour revenir à l'état normal
            if (trouModeActive) {
              toggleTrouMode();
            }
          }, 300);
        }, 100);
      }

      // Fonction pour exporter le code génétique en CSV
      function exportGeneticCode() {
        const entries = Object.entries(geneticCode)
          .filter(([k, v]) => v !== "START")
          .sort(([a], [b]) => a.localeCompare(b));

        // Créer le contenu CSV
        let csvContent = "Codon,Symbole\n";
        entries.forEach(([codon, symbol]) => {
          // Échapper les virgules et guillemets dans les symboles
          const escapedSymbol =
            symbol.includes(",") || symbol.includes('"')
              ? `"${symbol.replace(/"/g, '""')}"`
              : symbol;
          csvContent += `${codon},${escapedSymbol}\n`;
        });

        // Créer un blob et télécharger
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "code_genetique.csv");
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // Fonction pour importer le code génétique depuis un CSV
      function importGeneticCode(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const text = e.target.result;
            const lines = text.split("\n").filter((line) => line.trim() !== "");

            // Ignorer la première ligne (en-tête)
            const dataLines = lines.slice(1);

            // Créer un nouveau code génétique
            const newGeneticCode = { ATG: "START" };
            let hasError = false;
            let errorMessage = "";

            dataLines.forEach((line, index) => {
              // Parser la ligne CSV (gérer les virgules dans les valeurs)
              const match = line.match(/^([^,]+),(".*"|[^,]*)$/);
              if (match) {
                const codon = match[1].trim();
                let symbol = match[2].trim();

                // Enlever les guillemets si présents
                if (symbol.startsWith('"') && symbol.endsWith('"')) {
                  symbol = symbol.slice(1, -1).replace(/""/g, '"');
                }

                // Valider le codon (3 lettres A, T, C, G)
                if (/^[ATCG]{3}$/.test(codon)) {
                  newGeneticCode[codon] = symbol;
                } else {
                  hasError = true;
                  errorMessage += `Ligne ${
                    index + 2
                  }: Codon invalide "${codon}"\n`;
                }
              } else if (line.trim() !== "") {
                hasError = true;
                errorMessage += `Ligne ${index + 2}: Format invalide\n`;
              }
            });

            if (hasError) {
              alert("Erreurs lors de l'importation :\n" + errorMessage);
              return;
            }

            // Demander confirmation avant de remplacer
            if (
              confirm(
                "Voulez-vous remplacer le code génétique actuel par celui du fichier CSV ?"
              )
            ) {
              // Remplacer le code génétique
              Object.keys(geneticCode).forEach((key) => {
                if (key !== "ATG") delete geneticCode[key];
              });
              Object.assign(geneticCode, newGeneticCode);

              // Reconstruire le reverseCode global
              Object.keys(reverseCode).forEach(
                (key) => delete reverseCode[key]
              );
              for (let [codon, char] of Object.entries(geneticCode)) {
                if (char !== "START" && char !== "Majuscule") {
                  if (!reverseCode[char]) reverseCode[char] = [];
                  reverseCode[char].push(codon);
                }
              }

              // Recharger le tableau
              const tbody = document.getElementById("codeTable");
              tbody.innerHTML = "";
              const entries = Object.entries(geneticCode)
                .filter(([k, v]) => v !== "START")
                .sort(([a], [b]) => a.localeCompare(b));

              const numColumns = 4;
              const entriesPerColumn = Math.ceil(entries.length / numColumns);

              const rows = [];
              for (let i = 0; i < entriesPerColumn; i++) {
                const row = document.createElement("tr");
                for (let j = 0; j < numColumns * 2; j++) {
                  const cell = document.createElement("td");
                  row.appendChild(cell);
                }
                rows.push(row);
                tbody.appendChild(row);
              }

              entries.forEach(([codon, symbol], index) => {
                const columnIndex = Math.floor(index / entriesPerColumn);
                const rowIndex = index % entriesPerColumn;
                if (columnIndex >= numColumns) return;
                const row = rows[rowIndex];
                const codonCellIndex = columnIndex * 2;
                const symbolCellIndex = codonCellIndex + 1;
                row.cells[codonCellIndex].textContent = codon;
                row.cells[symbolCellIndex].textContent = symbol;

                // Colorer les codons stop en rose pastel
                if (["TAA", "TAG", "TGA"].includes(codon)) {
                  row.cells[codonCellIndex].style.backgroundColor = "#ffb3d9";
                  row.cells[symbolCellIndex].style.backgroundColor = "#ffb3d9";
                }
              });

              alert("Code génétique importé avec succès !");
            }

            // Réinitialiser l'input file
            event.target.value = "";
          } catch (error) {
            alert("Erreur lors de la lecture du fichier : " + error.message);
            event.target.value = "";
          }
        };
        reader.readAsText(file);
      }
    </script>
  </body>
</html>
