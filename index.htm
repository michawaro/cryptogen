<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <title>Cryptogen - Encodeur / D√©codeur ADN</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&family=Comfortaa:wght@400;500;600;700&family=Quicksand:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #222;
        min-height: 100vh;
        padding-bottom: 60px;
      }
      .container {
        max-width: 1440px;
        margin: 0 auto;
        padding: 40px 20px;
      }
      header {
        text-align: center;
        margin-bottom: 60px;
        padding: 40px 20px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
      }
      h1 {
        font-size: 3rem;
        font-weight: 900;
        margin: 0 0 20px 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        letter-spacing: 0.02em;
        font-family: "Nunito", "Comfortaa", "Quicksand", -apple-system,
          BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial,
          sans-serif;
      }
      .subtitle {
        font-size: 1.3rem;
        color: #666;
        margin: 0;
        font-weight: 400;
        line-height: 1.6;
      }
      .section {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 40px;
        margin-bottom: 40px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
      }
      h2 {
        font-size: 2.4rem;
        font-weight: 800;
        margin: 0 0 30px 0;
        text-align: center;
        color: #333;
        letter-spacing: 0.02em;
        font-family: "Nunito", "Comfortaa", "Quicksand", -apple-system,
          BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial,
          sans-serif;
      }
      textarea {
        width: 100%;
        height: 160px;
        font-family: "Courier New", monospace;
        font-size: 1.1rem;
        padding: 20px;
        border-radius: 12px;
        border: 2px solid #e0e0e0;
        resize: vertical;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
        line-height: 1.6;
      }
      textarea::placeholder {
        color: #999;
        opacity: 1;
      }
      textarea:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }
      button {
        margin-top: 20px;
        padding: 16px 32px;
        font-size: 1.1rem;
        font-weight: 600;
        border-radius: 12px;
        border: none;
        cursor: pointer;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        text-shadow: -0.5px -0.5px 0 rgba(0, 0, 0, 0.5),
          0.5px -0.5px 0 rgba(0, 0, 0, 0.5), -0.5px 0.5px 0 rgba(0, 0, 0, 0.5),
          0.5px 0.5px 0 rgba(0, 0, 0, 0.5), 0 0 1px rgba(0, 0, 0, 0.3);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
      }
      button:active {
        transform: translateY(0);
      }
      .output {
        margin-top: 30px;
        padding: 25px;
        background: #f8f9fa;
        border-radius: 12px;
        min-height: 80px;
        max-height: 400px;
        overflow-y: auto;
        font-size: 1.2rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        line-height: 2;
        border: 2px solid #e0e0e0;
        font-family: "Courier New", monospace;
      }
      .output:empty:before {
        content: "Le r√©sultat appara√Ætra ici...";
        color: #999;
        font-style: italic;
      }
      .word-space {
        background-color: #e0e0e0;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-short {
        background-color: #b3d9ff;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-medium {
        background-color: #b3ffb3;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-long {
        background-color: #fff9b3;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-verylong {
        background-color: #ffb3d9;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-trou {
        background-color: #ff6b6b !important;
        opacity: 0.7;
        cursor: pointer;
        position: relative;
      }
      .word-stop {
        background-color: #ffb3d9;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-trou:hover {
        opacity: 1;
      }
      .word-trou::after {
        content: "‚úï";
        position: absolute;
        top: -8px;
        right: -8px;
        background: #ff6b6b;
        color: white;
        text-shadow: -0.3px -0.3px 0 rgba(0, 0, 0, 0.5),
          0.3px -0.3px 0 rgba(0, 0, 0, 0.5), -0.3px 0.3px 0 rgba(0, 0, 0, 0.5),
          0.3px 0.3px 0 rgba(0, 0, 0, 0.5), 0 0 0.5px rgba(0, 0, 0, 0.3);
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
      }
      .trou-mode-active {
        background: #fff3cd !important;
        border: 2px solid #ffc107 !important;
      }
      #dnaInput {
        width: 100%;
        min-height: 160px;
        font-family: "Courier New", monospace;
        font-size: 1.1rem;
        padding: 20px;
        border-radius: 12px;
        border: 2px solid #e0e0e0;
        background: white;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        transition: border-color 0.3s ease;
        line-height: 1.6;
      }
      #dnaInput:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }
      #dnaInput:empty:before {
        content: attr(placeholder);
        color: #999;
        pointer-events: none;
      }
      table {
        margin: 0 auto;
        width: 100%;
        max-width: 1000px;
        border-collapse: collapse;
        background: white;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
      }
      th,
      td {
        padding: 10px 12px;
        border-bottom: 1px solid #eee;
        border-right: 1px solid #eee;
        text-align: center;
        font-family: "Courier New", monospace;
        font-size: 0.95rem;
        width: 12.5%;
      }
      th {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        text-shadow: -0.5px -0.5px 0 rgba(0, 0, 0, 0.5),
          0.5px -0.5px 0 rgba(0, 0, 0, 0.5), -0.5px 0.5px 0 rgba(0, 0, 0, 0.5),
          0.5px 0.5px 0 rgba(0, 0, 0, 0.5), 0 0 1px rgba(0, 0, 0, 0.3);
        font-weight: 600;
        text-transform: uppercase;
        font-size: 0.85rem;
        letter-spacing: 0.05em;
      }
      td:last-child,
      th:last-child {
        border-right: none;
      }
      tr:hover {
        background-color: #f8f9fa;
      }
      tr:last-child td {
        border-bottom: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Cryptogen - Encodeur / D√©codeur ADN</h1>
        <p class="subtitle">
          Colle une s√©quence ADN ou un texte, et encode ou d√©code avec le m√™me
          code g√©n√©tique.
        </p>
        <p class="subtitle" style="margin-top: 10px; font-size: 1rem">
          Mode d'emploi de l'encodeur dans
          <a
            href="https://youtu.be/752HGS405eY"
            target="_blank"
            style="color: #667eea; text-decoration: underline"
            >cette vid√©o</a
          >. Des exemples d'utilisation seront ajout√©s sur
          <a
            href="https://michawaro.github.io/michawaro/"
            target="_blank"
            style="color: #667eea; text-decoration: underline"
            >la page Michawaro</a
          >.
        </p>
        <p class="subtitle" style="margin-top: 10px; font-size: 1rem">
          Retour ou suggestions ?
          <span
            id="emailIcon"
            style="
              display: inline-block;
              margin-left: 8px;
              font-size: 1.2rem;
              cursor: pointer;
              transition: transform 0.2s ease, opacity 0.2s ease;
              opacity: 0.8;
            "
            title="michawaro.mail@gmail.com"
            onclick="copyEmailToClipboard()"
            onmouseover="this.style.opacity='1'; this.style.transform='scale(1.15)'"
            onmouseout="this.style.opacity='0.8'; this.style.transform='scale(1)'"
            >üìß</span
          >
        </p>
      </header>

      <div class="section">
        <h2>D√©codage</h2>
        <div style="margin-bottom: 15px; text-align: center">
          <label
            for="ediFileInput"
            style="display: inline-block; margin-right: 10px"
          >
            <button
              onclick="document.getElementById('ediFileInput').click()"
              style="background: #4dabf7"
            >
              Importer .edi
            </button>
            <input
              type="file"
              id="ediFileInput"
              accept=".edi"
              style="display: none"
              onchange="importEDIFile(event)"
            />
          </label>
          <label
            for="fastaFileInput"
            style="display: inline-block; margin-right: 10px"
          >
            <button
              onclick="document.getElementById('fastaFileInput').click()"
              style="background: #4dabf7"
            >
              Importer .fasta
            </button>
            <input
              type="file"
              id="fastaFileInput"
              accept=".fasta,.fa,.fas"
              style="display: none"
              onchange="importFASTAFile(event)"
            />
          </label>
          <button onclick="loadTestSequence()" style="background: #b3ffb3">
            Tester
          </button>
        </div>
        <div
          id="dnaInput"
          contenteditable="true"
          placeholder="Ecris ou colle ici une s√©quence d'ADN. L'ADN contient des informations cod√©es sous forme de s√©quence de nucl√©otides. Peut-√™tre qu'un message est cach√© dans la s√©quence que tu vas √©tudier ?"
        ></div>
        <button onclick="decodeDNA()">D√©coder</button>
        <p
          style="
            margin-top: 15px;
            margin-bottom: 10px;
            color: #666;
            font-style: italic;
            text-align: center;
          "
        >
          Dans le cas o√π certains mots s'affichent sous forme de s√©quence de
          nucl√©otides, double cliquez dessus pour les d√©chiffrer.
        </p>
        <div
          class="output"
          id="output"
          style="word-wrap: break-word; overflow-wrap: break-word"
        ></div>
      </div>

      <div class="section">
        <h2>Encodage</h2>
        <textarea
          id="textInput"
          placeholder="Ecris ou colle un texte que tu souhaites encoder dans de l'ADN. Anecdote : il est aujourd'hui possible d'encapsuler l'ADN dans des nanobilles de silice. En les stockant dans des capsules en acier inoxydable, on estime pouvoir obtenir une dur√©e de vie de 50.000 ans. Source : Acad√©mie des technologies - Wikipedia"
        ></textarea>
        <button onclick="encodeText()">Encoder</button>
        <button
          id="trouModeBtn"
          onclick="toggleTrouMode()"
          style="margin-left: 10px; background: #ff6b6b"
        >
          Encodage √† trou
        </button>
        <button
          id="copyBtn"
          onclick="copyDNAWithTrous()"
          style="margin-left: 10px; background: #51cf66; display: none"
        >
          Copier la s√©quence
        </button>
        <button
          id="exportEDIBtn"
          onclick="exportEDIFile()"
          style="margin-left: 10px; background: #ffa94d; display: none"
        >
          Exporter .edi
        </button>
        <button
          id="exportFASTABtn"
          onclick="exportFASTAFile()"
          style="margin-left: 10px; background: #ffa94d; display: none"
        >
          Exporter .fasta
        </button>
        <div class="output" id="dnaOutput"></div>
      </div>

      <div class="section">
        <h2>Code g√©n√©tique fictif - Triplet de nucl√©otides / texte</h2>
        <div style="margin-bottom: 20px; text-align: center">
          <button
            onclick="exportGeneticCode()"
            style="margin-right: 10px; background: #51cf66"
          >
            Exporter CSV
          </button>
          <label for="csvFileInput" style="display: inline-block">
            <button
              onclick="document.getElementById('csvFileInput').click()"
              style="background: #4dabf7"
            >
              Importer CSV
            </button>
            <input
              type="file"
              id="csvFileInput"
              accept=".csv"
              style="display: none"
              onchange="importGeneticCode(event)"
            />
          </label>
        </div>
        <p
          style="
            margin-top: 10px;
            margin-bottom: 15px;
            color: #666;
            font-style: italic;
            text-align: center;
            font-size: 0.9rem;
          "
        >
          L'import CSV permet √† chaque utilisateur de personnaliser
          temporairement le code g√©n√©tique pour sa session.
        </p>
        <table>
          <thead>
            <tr>
              <th>Codon</th>
              <th>Symbole</th>
              <th>Codon</th>
              <th>Symbole</th>
              <th>Codon</th>
              <th>Symbole</th>
              <th>Codon</th>
              <th>Symbole</th>
            </tr>
          </thead>
          <tbody id="codeTable"></tbody>
        </table>
      </div>
    </div>

    <!-- Fen√™tre modale pour le d√©codage interactif -->
    <div
      id="decodeModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 50px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 90%;
          max-height: 90vh;
          overflow-y: auto;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
          "
        >
          <h2 style="margin: 0; color: #667eea">D√©codage interactif</h2>
          <button
            id="closeModal"
            style="
              background: #ff6b6b;
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 1.2rem;
            "
          >
            ‚úï Fermer
          </button>
        </div>
        <div id="modalContent"></div>
      </div>
    </div>

    <script>
      const geneticCode = {
        ATG: "START",
        AAA: "A",
        // Ordre alphab√©tique des triplets
        // A : 1 triplet
        AAC: "√Ä",
        AAG: "√Ç",
        // B : 1 triplet
        AAT: "B",
        // C : 2 triplets
        ACA: "C",
        ACC: "√á",
        // D : 2 triplets
        ACG: "D",
        // E : 1 triplet
        ACT: "E",
        AGC: "≈í",
        // √â (√© en majuscule) : 1 triplet
        AGG: "√â",
        // √à (√® en majuscule) : 1 triplet
        AGT: "√à",
        // √ä (√™ en majuscule) : 1 triplet
        ATA: "√ä",
        // √ã (√´ en majuscule) : 1 triplet
        ATC: "√ã",
        // F : 2 triplets
        ATT: "F",
        CAA: "F",
        // G : 2 triplets
        CAC: "G",
        CAG: "G",
        // H : 2 triplets
        CAT: "H",
        CCA: "H",
        // I : 1 triplet
        CCC: "I",
        // √è (√Ø en majuscule) : 1 triplet
        CCG: "√è",
        // J : 2 triplets
        CCT: "J",
        CGA: "J",
        // K : 2 triplets
        CGC: "K",
        CGG: "K",
        // L : 2 triplets
        CGT: "L",
        CTA: "L",
        // M : 2 triplets
        CTC: "M",
        CTG: "M",
        // N : 2 triplets
        CTT: "N",
        GAA: "N",
        // O : 2 triplets
        GAC: "O",
        GAG: "O",
        // P : 2 triplets
        GAT: "P",
        GCA: "P",
        // Q : 2 triplets
        GCC: "Q",
        GCG: "Q",
        // R : 2 triplets
        GCT: "R",
        GGA: "R",
        // S : 2 triplets
        GGC: "S",
        GGT: "S",
        // T : 2 triplets
        GTA: "T",
        GTC: "T",
        // U : 2 triplets
        GTG: "U",
        GTT: "U",
        // V : 2 triplets
        TAC: "V",
        TAT: "V",
        // W : 2 triplets
        TCA: "W",
        TCC: "W",
        // X : 2 triplets
        TCG: "X",
        TCT: "X",
        // Point (fin de phrase) - uniquement les 3 stop codons classiques
        TAA: ".",
        TAG: ".",
        TGA: ".",
        // Utiliser les triplets restants pour des redondances
        TGC: "Y", // Y : 1 triplet
        TGG: "Z", // Z : 1 triplet
        // Caract√®res sp√©ciaux (derniers triplets)
        TTA: ",", // Virgule
        TTC: "'", // Apostrophe
        TTG: ",", // Virgule (tous types)
        TTT: " ", // Espace
      };

      const reverseCode = {};
      for (let [codon, char] of Object.entries(geneticCode)) {
        if (char !== "START") {
          if (!reverseCode[char]) reverseCode[char] = [];
          reverseCode[char].push(codon);
        }
      }

      // Variables pour le mode "encodage √† trou"
      let trouModeActive = false;
      let selectedWordIndices = new Set(); // Indices des mots s√©lectionn√©s (0-based)
      let currentWordPositions = []; // Positions des mots dans la s√©quence actuelle

      // Fonction pour activer/d√©sactiver le mode "√† trou"
      function toggleTrouMode() {
        trouModeActive = !trouModeActive;
        const btn = document.getElementById("trouModeBtn");
        const output = document.getElementById("dnaOutput");
        const textInput = document.getElementById("textInput");

        if (trouModeActive) {
          btn.classList.add("trou-mode-active");
          btn.textContent = "Mode √† trou actif (double-cliquez sur les mots)";
          // R√©encoder pour permettre la s√©lection
          if (textInput.value.trim()) {
            encodeText();
          } else {
            // Si aucun texte n'est encod√©, afficher un message
            output.innerHTML =
              '<span style="color: #666; font-style: italic;">Veuillez d\'abord encoder un texte pour utiliser le mode "√† trou".</span>';
          }
        } else {
          btn.classList.remove("trou-mode-active");
          btn.textContent = "Encodage √† trou";
          selectedWordIndices.clear();
          // R√©encoder pour enlever les s√©lections
          if (textInput.value.trim()) {
            encodeText();
          } else {
            // Si aucun texte n'est encod√©, vider l'affichage
            output.innerHTML = "";
          }
        }
      }

      // Marqueur sp√©cial pour les positions "√† trou" : TGGTGG (double stop codon)
      const TROU_MARKER = "TGGTGG";

      // Fonction pour encoder les positions des mots s√©lectionn√©s
      function encodeTrouPositions(indices) {
        if (indices.size === 0) return "";
        // Format: TGGTGG (marqueur) + positions encod√©es en base 4 (A=0, T=1, C=2, G=3)
        // Utiliser TAG comme s√©parateur entre les positions (TAG est maintenant un point, mais utilis√© ici comme marqueur technique)
        const positions = Array.from(indices).sort((a, b) => a - b);
        let encoded = TROU_MARKER; // Marqueur de d√©but

        for (let i = 0; i < positions.length; i++) {
          if (i > 0) {
            encoded += "TAG"; // Utiliser TAG comme s√©parateur
          }
          // Encoder la position en base 4 avec A, T, C, G
          let pos = positions[i];
          if (pos === 0) {
            encoded += "A"; // Position 0 = A
          } else {
            let posStr = pos.toString(4);
            let dnaStr = "";
            for (let digit of posStr) {
              const d = parseInt(digit);
              dnaStr += ["A", "T", "C", "G"][d];
            }
            encoded += dnaStr;
          }
        }

        return encoded;
      }

      // Fonction pour d√©coder les positions des mots √† trou
      function decodeTrouPositions(dna) {
        const indices = new Set();
        // Chercher le marqueur TGGTGG
        const startIdx = dna.indexOf(TROU_MARKER);
        if (startIdx === -1) return indices;

        // Extraire la partie apr√®s le marqueur
        const encoded = dna.substring(startIdx + TROU_MARKER.length);
        // S√©parer par "TAG"
        const parts = encoded.split("TAG").filter((p) => p.length > 0);

        for (let part of parts) {
          // D√©coder de base 4 (A=0, T=1, C=2, G=3) vers d√©cimal
          let pos = 0;
          for (let i = 0; i < part.length; i++) {
            const char = part[i];
            const digit = ["A", "T", "C", "G"].indexOf(char);
            if (digit === -1) continue;
            pos = pos * 4 + digit;
          }
          indices.add(pos);
        }

        return indices;
      }

      // Fonction pour obtenir la classe CSS selon la longueur du mot
      function getWordClass(length) {
        if (length <= 4) return "word-short";
        if (length <= 6) return "word-medium";
        if (length <= 9) return "word-long";
        return "word-verylong";
      }

      // Fonction pour colorer le texte selon la longueur des mots
      function colorizeText(text, wordToDNA = null) {
        const words = text.split(/(\s+)/);
        let html = "";
        for (let word of words) {
          if (word.trim() === "") {
            // Espace
            html += `<span class="word-space">${word}</span>`;
          } else {
            const length = word.length;
            const className = getWordClass(length);
            const tooltip =
              wordToDNA && wordToDNA[word] ? ` title="${wordToDNA[word]}"` : "";
            html += `<span class="${className}"${tooltip}>${word}</span>`;
          }
        }
        return html;
      }

      // Fonction pour d√©coder une s√©quence ADN en texte
      function decodeDNASequence(dnaSequence) {
        let decoded = "";
        for (let i = 0; i <= dnaSequence.length - 3; i += 3) {
          const codon = dnaSequence.substring(i, i + 3);
          const decodedChar = geneticCode[codon];
          if (decodedChar && decodedChar !== "START") {
            let displayChar = decodedChar;
            if (decodedChar === "√©") displayChar = "√â";
            if (decodedChar === "√®") displayChar = "√à";
            if (decodedChar === "√™") displayChar = "√ä";
            if (decodedChar === "√´") displayChar = "√ã";
            if (decodedChar === "√Ø") displayChar = "√è";
            decoded += displayChar;
          }
        }
        return decoded;
      }

      // Fonction pour colorer la s√©quence ADN selon les mots (pour le d√©codage)
      function colorizeDNAForDecode(dna) {
        if (!dna || dna.length === 0) return "";

        // V√©rifier s'il y a un marqueur "√† trou" (TGGTGG)
        const markerIndex = dna.indexOf(TROU_MARKER);
        let sequenceToColorize = dna;
        let markerAndPositions = "";

        if (markerIndex !== -1) {
          // S√©parer la s√©quence principale et le marqueur avec les positions
          sequenceToColorize = dna.substring(0, markerIndex);
          markerAndPositions = dna.substring(markerIndex);
        }

        let html = "";
        let i = 0;
        const startIndex = sequenceToColorize.indexOf("ATG");

        if (startIndex === -1) {
          // Pas de ATG, commencer au d√©but
          i = 0;
        } else {
          // Ajouter tout ce qui pr√©c√®de ATG et ATG lui-m√™me
          html += `<span>${sequenceToColorize.substring(
            0,
            startIndex + 3
          )}</span>`;
          i = startIndex + 3;
        }

        let currentWordStart = i;
        let inWord = true;

        // Traiter toute la s√©quence sans s'arr√™ter aux codons stop
        while (i <= sequenceToColorize.length - 3) {
          const codon = sequenceToColorize.substring(i, i + 3);

          if (codon === "TTT") {
            // Espace
            if (inWord) {
              // Finir le mot pr√©c√©dent
              const wordLength = i - currentWordStart;
              const className = getNucleotideClass(wordLength);
              const wordDNA = sequenceToColorize.substring(currentWordStart, i);
              const decodedWord = decodeDNASequence(wordDNA);
              const tooltip = decodedWord ? ` title="${decodedWord}"` : "";
              html += `<span class="${className}"${tooltip}>${wordDNA}</span>`;
              inWord = false;
            }
            html += `<span class="word-space">${codon}</span>`;
            i += 3;
            currentWordStart = i;
            inWord = true;
          } else if (["TAA", "TAG", "TGA"].includes(codon)) {
            // Codon stop = point (mais continuer apr√®s)
            if (inWord) {
              const wordLength = i - currentWordStart;
              const className = getNucleotideClass(wordLength);
              const wordDNA = sequenceToColorize.substring(currentWordStart, i);
              const decodedWord = decodeDNASequence(wordDNA);
              const tooltip = decodedWord ? ` title="${decodedWord}"` : "";
              html += `<span class="${className}"${tooltip}>${wordDNA}</span>`;
              inWord = false;
            }
            html += `<span class="word-stop" title="Point">${codon}</span>`;
            i += 3;
            currentWordStart = i;
            inWord = true;
          } else {
            i += 3;
          }
        }

        // Ajouter le dernier mot s'il existe
        if (inWord && i > currentWordStart) {
          const wordLength = i - currentWordStart;
          const className = getNucleotideClass(wordLength);
          const wordDNA = sequenceToColorize.substring(currentWordStart, i);
          const decodedWord = decodeDNASequence(wordDNA);
          const tooltip = decodedWord ? ` title="${decodedWord}"` : "";
          html += `<span class="${className}"${tooltip}>${wordDNA}</span>`;
        }

        // Ajouter le reste de la s√©quence (ce qui reste apr√®s le dernier triplet complet)
        if (i < sequenceToColorize.length) {
          html += `<span>${sequenceToColorize.substring(i)}</span>`;
        }

        // Ajouter le marqueur et les positions "√† trou" s'ils existent
        if (markerAndPositions) {
          html += `<span style="color: #999; font-size: 0.9em;">${markerAndPositions}</span>`;
        }

        return html;
      }

      // Fonction pour coloriser le textarea de d√©codage
      function colorizeDNAInput() {
        const dnaInput = document.getElementById("dnaInput");
        const text = dnaInput.innerText || dnaInput.textContent || "";
        const cleaned = text.toUpperCase().replace(/[^ATCG]/g, "");

        if (cleaned.length === 0) {
          if (text.length === 0) {
            dnaInput.innerHTML = "";
          }
          return;
        }

        const colored = colorizeDNAForDecode(cleaned);
        // Ne mettre √† jour que si le contenu a chang√© pour √©viter les probl√®mes de curseur
        if (dnaInput.innerHTML !== colored) {
          dnaInput.innerHTML = colored;
        }
      }

      function decodeDNA() {
        const dnaInput = document.getElementById("dnaInput");
        // R√©cup√©rer le texte brut
        const rawInput = dnaInput.innerText || dnaInput.textContent || "";
        // Nettoyer pour le d√©codage (enlever tout sauf A, T, C, G)
        let input = rawInput.toUpperCase().replace(/[^ATCG]/g, "");

        // Extraire les positions "√† trou" AVANT de retirer le marqueur (chercher TGGTGG)
        const trouIndices = decodeTrouPositions(input);

        // Retirer le marqueur et les positions de la s√©quence √† d√©coder
        const markerIndex = input.indexOf(TROU_MARKER);
        if (markerIndex !== -1) {
          input = input.substring(0, markerIndex);
        }

        const output = document.getElementById("output");
        output.innerHTML = "";
        const startIndex = input.indexOf("ATG");
        if (startIndex === -1) {
          output.textContent = "Aucun codon START (ATG) trouv√©.";
          return;
        }

        // D√©coder le message et cr√©er la correspondance mot -> s√©quence ADN
        const words = []; // Liste des mots (d√©cod√©s ou ADN)
        const wordToDNA = {}; // Correspondance mot -> s√©quence ADN
        let currentWord = "";
        let currentWordDNA = "";
        let wordIndex = 0; // Index du mot actuel
        let foundStopCodon = false; // Indicateur si on a trouv√© un codon stop

        for (let i = startIndex + 3; i <= input.length - 3; i += 3) {
          const codon = input.substring(i, i + 3);

          if (["TAA", "TAG", "TGA"].includes(codon)) {
            // D'abord, finaliser et ajouter le mot actuel s'il existe
            if (currentWord || currentWordDNA) {
              if (trouIndices.has(wordIndex)) {
                // Mot "√† trou" : garder la s√©quence ADN
                words.push({
                  type: "trou",
                  content: currentWordDNA,
                  dna: currentWordDNA,
                });
              } else {
                // Mot normal : d√©coder
                if (currentWord) {
                  wordToDNA[currentWord] = currentWordDNA;
                  words.push({
                    type: "normal",
                    content: currentWord,
                    dna: currentWordDNA,
                  });
                }
              }
            }

            // R√©initialiser IMM√âDIATEMENT pour √©viter que le point soit int√©gr√© au mot suivant
            currentWord = "";
            currentWordDNA = "";

            // Ignorer les codons stop cons√©cutifs en sautant directement au prochain codon non-stop
            while (i + 3 <= input.length - 3) {
              const nextCodon = input.substring(i + 3, i + 6);
              if (["TAA", "TAG", "TGA"].includes(nextCodon)) {
                i += 3; // Sauter ce codon stop aussi
              } else {
                break; // Prochain codon n'est pas un stop, continuer normalement
              }
            }

            // Ajouter un point seulement si le dernier √©l√©ment ajout√© n'est pas d√©j√† un point
            let shouldAddPoint = true;
            if (words.length > 0) {
              const lastElement = words[words.length - 1];
              // Ne pas ajouter de point si le dernier √©l√©ment est d√©j√† un point
              if (
                lastElement.type === "punctuation" &&
                lastElement.content === "."
              ) {
                shouldAddPoint = false;
              }
            }

            if (shouldAddPoint) {
              words.push({ type: "punctuation", content: "." });
            }
            foundStopCodon = true;
            wordIndex++; // Passer au mot suivant apr√®s le point
            // CONTINUER dans la boucle pour traiter le prochain codon (qui sera le d√©but du mot suivant)
            continue;
          }

          if (codon === "TTT") {
            // Espace
            if (currentWord || currentWordDNA) {
              if (trouIndices.has(wordIndex)) {
                // Mot "√† trou" : garder la s√©quence ADN
                words.push({
                  type: "trou",
                  content: currentWordDNA,
                  dna: currentWordDNA,
                });
              } else {
                // Mot normal : d√©coder
                if (currentWord) {
                  wordToDNA[currentWord] = currentWordDNA;
                  words.push({
                    type: "normal",
                    content: currentWord,
                    dna: currentWordDNA,
                  });
                }
              }
              currentWord = "";
              currentWordDNA = "";
            }
            // Ne pas ajouter d'espace si le dernier √©l√©ment est d√©j√† un point (√©vite l'espace entre point et mot suivant)
            if (words.length > 0) {
              const lastElement = words[words.length - 1];
              if (
                lastElement.type === "punctuation" &&
                lastElement.content === "."
              ) {
                // Ne pas ajouter d'espace apr√®s un point
                wordIndex++; // Passer au mot suivant quand m√™me
                continue;
              }
            }
            words.push({ type: "space", content: " " });
            wordIndex++; // Passer au mot suivant
          } else {
            const decodedChar = geneticCode[codon];
            if (decodedChar && decodedChar !== "START") {
              // Forcer les minuscules accentu√©es √† s'afficher en majuscules
              let displayChar = decodedChar;
              if (decodedChar === "√©") displayChar = "√â";
              if (decodedChar === "√®") displayChar = "√à";
              if (decodedChar === "√™") displayChar = "√ä";
              if (decodedChar === "√´") displayChar = "√ã";
              if (decodedChar === "√Ø") displayChar = "√è";

              currentWordDNA += codon;
              // Si ce mot est "√† trou", ne pas d√©coder
              if (!trouIndices.has(wordIndex)) {
                currentWord += displayChar;
              }
            }
          }
        }

        // Ajouter le dernier mot s'il existe (m√™me apr√®s un codon stop, car on peut avoir plusieurs phrases)
        // Mais seulement si on n'a pas d√©j√† trait√© un codon stop √† la fin qui aurait vid√© currentWord
        if (currentWord || currentWordDNA) {
          // V√©rifier si le dernier codon de la s√©quence est un stop
          const lastCodon = input.substring(input.length - 3);
          const isLastCodonStop = ["TAA", "TAG", "TGA"].includes(lastCodon);

          // Si le dernier codon est un stop, il a d√©j√† √©t√© trait√© dans la boucle
          // et le mot a d√©j√† √©t√© ajout√©, donc on ne doit pas l'ajouter √† nouveau
          if (!isLastCodonStop) {
            if (trouIndices.has(wordIndex)) {
              // Mot "√† trou" : garder la s√©quence ADN
              words.push({
                type: "trou",
                content: currentWordDNA,
                dna: currentWordDNA,
              });
            } else {
              // Mot normal : d√©coder
              if (currentWord) {
                wordToDNA[currentWord] = currentWordDNA;
                words.push({
                  type: "normal",
                  content: currentWord,
                  dna: currentWordDNA,
                });
              }
            }
          }
        }

        // Fonction pour v√©rifier si une cha√Æne est une s√©quence ADN pure
        function isDNASequence(str) {
          return /^[ATCG]+$/i.test(str) && str.length >= 3;
        }

        // Afficher le texte d√©cod√© avec les mots "√† trou" en s√©quence ADN
        let html = "";
        for (let word of words) {
          if (word.type === "space") {
            html += `<span class="word-space">${word.content}</span>`;
          } else if (word.type === "punctuation") {
            // Les points doivent avoir la couleur d'arri√®re-plan rose pastel
            html += `<span class="word-stop">${word.content}</span>`;
          } else if (word.type === "trou") {
            // Afficher la s√©quence ADN avec double-clic
            html += `<span class="word-trou decode-dna" data-dna="${word.content}" style="font-family: monospace; background: #ff6b6b; padding: 4px 6px; border-radius: 4px; cursor: pointer;" title="Double-cliquez pour d√©coder">${word.content}</span>`;
          } else {
            // Mot normal - v√©rifier si c'est une s√©quence ADN pure
            if (isDNASequence(word.content)) {
              html += `<span class="decode-dna" data-dna="${word.content}" style="font-family: monospace; background: #ffb3d9; padding: 4px 6px; border-radius: 4px; cursor: pointer;" title="Double-cliquez pour d√©coder">${word.content}</span>`;
            } else {
              const length = word.content.length;
              const className = getWordClass(length);
              const tooltip = wordToDNA[word.content]
                ? ` title="${wordToDNA[word.content]}"`
                : "";
              html += `<span class="${className}"${tooltip}>${word.content}</span>`;
            }
          }
        }

        output.innerHTML = html;

        // Ajouter les √©v√©nements double-clic sur les s√©quences ADN
        output.querySelectorAll(".decode-dna").forEach((span) => {
          span.addEventListener("dblclick", function () {
            const dnaSequence = this.getAttribute("data-dna");
            openDecodeModal(dnaSequence, this);
          });
        });
      }

      // Fonction pour ouvrir la modale de d√©codage interactif
      function openDecodeModal(dnaSequence, originalSpan = null) {
        const modal = document.getElementById("decodeModal");
        const modalContent = document.getElementById("modalContent");

        // Nettoyer la s√©quence (enlever tout sauf A, T, C, G)
        const cleaned = dnaSequence.toUpperCase().replace(/[^ATCG]/g, "");

        if (cleaned.length < 3) {
          alert("S√©quence ADN trop courte pour √™tre d√©cod√©e.");
          return;
        }

        // Stocker la r√©f√©rence au span original pour pouvoir le remplacer
        window.modalOriginalSpan = originalSpan;
        window.modalDNASequence = cleaned;

        // R√©cup√©rer le mot d√©j√† saisi s'il existe (pour pr√©remplir)
        let existingWord = "";
        if (originalSpan && originalSpan.classList.contains("decode-filled")) {
          existingWord = originalSpan.textContent || "";
        }

        // Diviser en triplets et d√©coder
        const triplets = [];
        const decodedChars = [];
        let correctWord = ""; // Mot correct d√©cod√©

        for (let i = 0; i <= cleaned.length - 3; i += 3) {
          const triplet = cleaned.substring(i, i + 3);
          triplets.push(triplet);

          const decodedChar = geneticCode[triplet];
          if (decodedChar && decodedChar !== "START") {
            let displayChar = decodedChar;
            // Forcer les minuscules accentu√©es √† s'afficher en majuscules
            if (decodedChar === "√©") displayChar = "√â";
            if (decodedChar === "√®") displayChar = "√à";
            if (decodedChar === "√™") displayChar = "√ä";
            if (decodedChar === "√´") displayChar = "√ã";
            if (decodedChar === "√Ø") displayChar = "√è";

            decodedChars.push({ char: displayChar, isMarker: false });
            // Construire le mot correct
            correctWord += displayChar;
          } else {
            decodedChars.push({ char: "?", isMarker: false });
          }
        }

        // Stocker le mot correct pour la validation
        window.modalCorrectWord = correctWord;

        // Cr√©er le contenu de la modale
        let html = '<div style="margin-bottom: 30px;">';
        html +=
          '<h3 style="color: #667eea; margin-bottom: 15px;">S√©quence ADN : ' +
          cleaned +
          "</h3>";

        // Premi√®re ligne : inputs pour les lettres
        html +=
          '<div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px; justify-content: center; align-items: center;">';
        let existingWordIndex = 0; // Index pour parcourir le mot existant
        decodedChars.forEach((item, index) => {
          // Pr√©remplir avec la lettre existante si disponible
          const existingLetter =
            existingWord && existingWordIndex < existingWord.length
              ? existingWord[existingWordIndex].toUpperCase()
              : "";
          existingWordIndex++;

          html += `<input type="text" 
                          id="letter-${index}" 
                          maxlength="1" 
                          value="${existingLetter}"
                          style="width: 40px; height: 40px; text-align: center; font-size: 1.5rem; border: 2px solid #667eea; border-radius: 6px; font-weight: bold; text-transform: uppercase;"
                          placeholder="?"
                          oninput="this.value = this.value.toUpperCase()">`;
        });
        html += "</div>";

        // Bouton de validation
        html += '<div style="text-align: center; margin: 20px 0;">';
        html +=
          '<button id="validateDecode" style="background: #51cf66; color: white; text-shadow: -0.5px -0.5px 0 rgba(0, 0, 0, 0.5), 0.5px -0.5px 0 rgba(0, 0, 0, 0.5), -0.5px 0.5px 0 rgba(0, 0, 0, 0.5), 0.5px 0.5px 0 rgba(0, 0, 0, 0.5), 0 0 1px rgba(0, 0, 0, 0.3); border: none; padding: 15px 30px; border-radius: 8px; cursor: pointer; font-size: 1.1rem; font-weight: bold;">Valider</button>';
        html += "</div>";

        // Deuxi√®me ligne : les triplets
        html +=
          '<div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 30px; justify-content: center; font-family: monospace;">';
        triplets.forEach((triplet, index) => {
          const isStop = ["TAA", "TAG", "TGA"].includes(triplet);
          let bgColor = "#e0e0e0";
          if (isStop) bgColor = "#ffb3d9";
          html += `<div style="width: 40px; height: 30px; text-align: center; padding-top: 5px; background: ${bgColor}; border-radius: 4px; font-size: 0.9rem;">${triplet}</div>`;
        });
        html += "</div>";

        // Troisi√®me ligne : code g√©n√©tique (tableau)
        html +=
          '<div style="margin-top: 30px; border-top: 2px solid #e0e0e0; padding-top: 20px;">';
        html +=
          '<h3 style="color: #667eea; margin-bottom: 15px;">Code G√©n√©tique</h3>';
        html += '<div style="overflow-x: auto;">';
        html +=
          '<table style="width: 100%; border-collapse: collapse; margin: 0 auto;">';
        html += "<thead><tr>";
        for (let i = 0; i < 4; i++) {
          html +=
            '<th style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-shadow: -0.5px -0.5px 0 rgba(0, 0, 0, 0.5), 0.5px -0.5px 0 rgba(0, 0, 0, 0.5), -0.5px 0.5px 0 rgba(0, 0, 0, 0.5), 0.5px 0.5px 0 rgba(0, 0, 0, 0.5), 0 0 1px rgba(0, 0, 0, 0.3); padding: 10px; text-align: center;">Codon</th>';
          html +=
            '<th style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-shadow: -0.5px -0.5px 0 rgba(0, 0, 0, 0.5), 0.5px -0.5px 0 rgba(0, 0, 0, 0.5), -0.5px 0.5px 0 rgba(0, 0, 0, 0.5), 0.5px 0.5px 0 rgba(0, 0, 0, 0.5), 0 0 1px rgba(0, 0, 0, 0.3); padding: 10px; text-align: center;">Symbole</th>';
        }
        html += "</tr></thead><tbody>";

        // Remplir le tableau avec le code g√©n√©tique (m√™me logique que la page principale)
        const entries = Object.entries(geneticCode)
          .filter(([k, v]) => v !== "START")
          .sort(([a], [b]) => a.localeCompare(b));
        const numColumns = 4;
        const entriesPerColumn = Math.ceil(entries.length / numColumns);

        // Cr√©er les lignes
        const tableRows = [];
        for (let i = 0; i < entriesPerColumn; i++) {
          const rowData = [];
          for (let j = 0; j < numColumns * 2; j++) {
            rowData.push(null);
          }
          tableRows.push(rowData);
        }

        // Remplir colonne par colonne (verticalement)
        entries.forEach(([codon, symbol], index) => {
          const columnIndex = Math.floor(index / entriesPerColumn);
          const rowIndex = index % entriesPerColumn;

          if (columnIndex >= numColumns) return;

          const codonCellIndex = columnIndex * 2;
          const symbolCellIndex = codonCellIndex + 1;

          tableRows[rowIndex][codonCellIndex] = codon;
          tableRows[rowIndex][symbolCellIndex] = symbol;
        });

        // G√©n√©rer le HTML des lignes
        tableRows.forEach((row) => {
          html += "<tr>";
          for (let i = 0; i < row.length; i += 2) {
            const codon = row[i];
            const symbol = row[i + 1];
            if (codon && symbol) {
              const isStop = ["TAA", "TAG", "TGA"].includes(codon);
              const bgColor = isStop ? "#ffb3d9" : "";
              html += `<td style="padding: 8px; text-align: center; border: 1px solid #ddd; background: ${bgColor}; font-family: monospace;">${codon}</td>`;
              html += `<td style="padding: 8px; text-align: center; border: 1px solid #ddd; background: ${bgColor};">${symbol}</td>`;
            } else {
              html += '<td style="padding: 8px; border: 1px solid #ddd;"></td>';
              html += '<td style="padding: 8px; border: 1px solid #ddd;"></td>';
            }
          }
          html += "</tr>";
        });

        html += "</tbody></table>";
        html += "</div>";
        html += "</div>";

        modalContent.innerHTML = html;
        modal.style.display = "block";

        // Stocker les donn√©es pour la fonction de validation
        window.modalDecodedChars = decodedChars;

        // Fonction pour valider et remplacer la s√©quence ADN par le mot saisi
        window.validateDecode = function () {
          let userWord = "";

          // R√©cup√©rer toutes les lettres saisies
          if (window.modalDecodedChars) {
            window.modalDecodedChars.forEach((item, index) => {
              const input = document.getElementById(`letter-${index}`);
              if (input) {
                const letter = input.value.trim().toUpperCase();
                userWord += letter || "?";
              }
            });
          }

          // Remplacer le span original par le mot saisi
          if (window.modalOriginalSpan && userWord) {
            // Cr√©er un nouveau span avec le mot saisi
            const newSpan = document.createElement("span");
            newSpan.textContent = userWord;
            newSpan.className =
              window.modalOriginalSpan.className + " decode-filled";
            // Stocker la s√©quence ADN originale pour pouvoir la modifier √† nouveau
            newSpan.setAttribute("data-dna", window.modalDNASequence);

            // Comparer le mot saisi avec le mot correct
            const correctWord = window.modalCorrectWord || "";

            // Normaliser les deux cha√Ænes pour la comparaison
            // Convertir en majuscules et normaliser les caract√®res accentu√©s
            function normalizeForComparison(str) {
              return str.toUpperCase().normalize("NFC"); // Normaliser en forme compos√©e canonique
            }

            const normalizedUser = normalizeForComparison(userWord);
            const normalizedCorrect = normalizeForComparison(correctWord);

            // Comparaison avec debug (peut √™tre retir√© apr√®s)
            console.log(
              "User word:",
              userWord,
              "-> Normalized:",
              normalizedUser
            );
            console.log(
              "Correct word:",
              correctWord,
              "-> Normalized:",
              normalizedCorrect
            );
            console.log("Match:", normalizedUser === normalizedCorrect);

            // Comparaison directe en majuscules (fallback)
            const directComparison =
              userWord.toUpperCase() === correctWord.toUpperCase();
            console.log("Direct comparison:", directComparison);

            // Utiliser les deux m√©thodes de comparaison
            const isCorrect =
              normalizedUser === normalizedCorrect || directComparison;

            console.log("Final isCorrect:", isCorrect);

            // Appliquer la couleur selon la justesse
            if (isCorrect) {
              // Vert pastel si correct
              console.log("Applying green color");
              newSpan.style.setProperty("background", "#b3ffb3", "important");
              newSpan.style.setProperty(
                "background-color",
                "#b3ffb3",
                "important"
              );
            } else {
              // Rouge pastel si incorrect
              console.log("Applying red color");
              newSpan.style.setProperty("background", "#ffb3b3", "important");
              newSpan.style.setProperty(
                "background-color",
                "#ffb3b3",
                "important"
              );
            }

            console.log("Final background color:", newSpan.style.background);
            console.log(
              "Final computed style:",
              window.getComputedStyle(newSpan).backgroundColor
            );

            newSpan.style.cursor = "pointer";
            newSpan.title = "Double-cliquez pour modifier";

            // Ajouter l'√©v√©nement de double-clic pour permettre de modifier √† nouveau
            newSpan.addEventListener("dblclick", function () {
              const dnaSequence = this.getAttribute("data-dna");
              openDecodeModal(dnaSequence, this);
            });

            // Remplacer l'ancien span par le nouveau
            window.modalOriginalSpan.parentNode.replaceChild(
              newSpan,
              window.modalOriginalSpan
            );
          }

          // Fermer la modale
          const modal = document.getElementById("decodeModal");
          if (modal) {
            modal.style.display = "none";
          }
        };

        // Ajouter l'√©v√©nement sur le bouton de validation
        setTimeout(() => {
          const validateBtn = document.getElementById("validateDecode");
          if (validateBtn) {
            validateBtn.addEventListener("click", window.validateDecode);
          }

          // Fonction pour trouver l'index de la prochaine case
          function findNextInputIndex(currentIndex, direction) {
            const maxIndex = window.modalDecodedChars.length - 1;
            let nextIndex;
            if (direction === 1) {
              // Vers la droite
              nextIndex = (currentIndex + 1) % (maxIndex + 1);
            } else {
              // Vers la gauche
              nextIndex = (currentIndex - 1 + maxIndex + 1) % (maxIndex + 1);
            }
            return nextIndex;
          }

          // Ajouter la gestion du clavier sur tous les inputs
          window.modalDecodedChars.forEach((item, index) => {
            const input = document.getElementById(`letter-${index}`);
            if (input) {
              input.addEventListener("keydown", function (e) {
                if (e.key === "Enter") {
                  e.preventDefault();
                  // Passer √† la case suivante
                  const nextIndex = findNextInputIndex(index, 1);
                  const nextInput = document.getElementById(
                    `letter-${nextIndex}`
                  );
                  if (nextInput) {
                    nextInput.focus();
                    nextInput.select();
                  }
                } else if (e.key === "ArrowRight") {
                  e.preventDefault();
                  // Aller √† la case suivante
                  const nextIndex = findNextInputIndex(index, 1);
                  const nextInput = document.getElementById(
                    `letter-${nextIndex}`
                  );
                  if (nextInput) {
                    nextInput.focus();
                    nextInput.select();
                  }
                } else if (e.key === "ArrowLeft") {
                  e.preventDefault();
                  // Aller √† la case pr√©c√©dente
                  const prevIndex = findNextInputIndex(index, -1);
                  const prevInput = document.getElementById(
                    `letter-${prevIndex}`
                  );
                  if (prevInput) {
                    prevInput.focus();
                    prevInput.select();
                  }
                }
              });

              // Passer automatiquement √† la case suivante quand une lettre est entr√©e
              input.addEventListener("input", function (e) {
                const value = this.value.trim().toUpperCase();
                // Si une lettre a √©t√© entr√©e (pas vide, pas juste supprim√©e)
                if (
                  value.length === 1 &&
                  /[A-Z√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ò√ô√ö√õ√ú√ù√û√ü]/.test(value)
                ) {
                  // Passer √† la case suivante
                  const nextIndex = findNextInputIndex(index, 1);
                  const nextInput = document.getElementById(
                    `letter-${nextIndex}`
                  );
                  if (nextInput) {
                    // Petit d√©lai pour s'assurer que la valeur est bien mise √† jour
                    setTimeout(() => {
                      nextInput.focus();
                      nextInput.select();
                    }, 10);
                  }
                }
              });
            }
          });
        }, 10);
      }

      // Fermer la modale
      document
        .getElementById("closeModal")
        .addEventListener("click", function () {
          document.getElementById("decodeModal").style.display = "none";
        });

      // Fermer la modale en cliquant en dehors
      document
        .getElementById("decodeModal")
        .addEventListener("click", function (e) {
          if (e.target === this) {
            this.style.display = "none";
          }
        });

      // Fonction pour normaliser le texte (tous les types d'apostrophes -> apostrophe standard)
      function normalizeText(text) {
        if (!text) return text;
        // Normaliser tous les types d'apostrophes vers l'apostrophe standard
        // Utiliser les codes Unicode pour capturer tous les types possibles
        // U+0027: ' (apostrophe droite)
        // U+2018: ' (guillemet simple ouvrant)
        // U+2019: ' (apostrophe typographique)
        // U+201A: ‚Äö (guillemet-virgule inf√©rieur)
        // U+201B: ‚Äõ (guillemet simple ouvrant renvers√©)
        // U+2032: ‚Ä≤ (prime)
        // U+2035: ‚Äµ (prime renvers√©e)
        // U+02BC:  º (lettre modificative apostrophe)
        // U+02BB:  ª (lettre modificative guillemet simple)
        // U+0060: ` (accent grave)
        // U+00B4: ¬¥ (accent aigu)
        // Utiliser une approche plus permissive pour capturer tous les caract√®res similaires
        let normalized = text;
        // Normaliser tous les types d'espaces vers l'espace standard (U+0020)
        // U+0020: espace standard
        // U+00A0: espace ins√©cable
        // U+2000-U+200B: diff√©rents types d'espaces (en quadratin, cadratin, etc.)
        // U+202F: espace ins√©cable √©troit
        // U+205F: espace math√©matique moyen
        // U+3000: espace id√©ographique
        normalized = normalized.replace(
          /[\u00A0\u2000-\u200B\u202F\u205F\u3000]/g,
          " "
        );
        // Remplacer tous les types d'apostrophes par l'apostrophe standard
        normalized = normalized.replace(/[''‚Äö‚Äõ‚Ä≤‚Äµ º ª`¬¥]/g, "'");
        // Remplacer aussi par code Unicode pour √™tre s√ªr
        normalized = normalized.replace(
          /[\u0027\u2018\u2019\u201A\u201B\u2032\u2035\u02BC\u02BB\u0060\u00B4]/g,
          "'"
        );
        // Guillemets typographiques
        normalized = normalized.replace(/[""]/g, '"');
        normalized = normalized.replace(/[""]/g, '"');
        return normalized;
      }

      // Fonction pour obtenir la classe CSS selon le nombre de nucl√©otides
      function getNucleotideClass(nucleotideCount) {
        if (nucleotideCount <= 12) return "word-short";
        if (nucleotideCount <= 18) return "word-medium";
        if (nucleotideCount <= 27) return "word-long";
        return "word-verylong";
      }

      // Fonction pour colorer la s√©quence ADN selon la longueur des mots
      function colorizeDNA(dna, wordPositions, dnaToText = null) {
        currentWordPositions = wordPositions.filter((w) => w.type === "word");
        let wordIndex = 0;
        let html = `<span>${dna.substring(0, 3)}</span>`; // ATG au d√©but
        let lastEnd = 3; // Position apr√®s ATG

        for (let word of wordPositions) {
          // V√©rifier s'il y a des codons stop entre lastEnd et word.start
          for (let i = lastEnd; i < word.start; i += 3) {
            const codon = dna.substring(i, i + 3);
            if (["TAA", "TAG", "TGA"].includes(codon)) {
              html += `<span class="word-stop" title="Point">${codon}</span>`;
              lastEnd = i + 3;
            }
          }

          if (word.type === "space") {
            // Espace (TTT = 3 nucl√©otides)
            html += `<span class="word-space">${dna.substring(
              word.start,
              word.end
            )}</span>`;
            lastEnd = word.end;
          } else {
            // Mot
            const nucleotideCount = word.end - word.start;
            let className = getNucleotideClass(nucleotideCount);
            const wordDNA = dna.substring(word.start, word.end);
            const tooltip =
              dnaToText && dnaToText[wordDNA]
                ? ` title="${dnaToText[wordDNA]}"`
                : "";

            // Ajouter la classe "word-trou" si le mot est s√©lectionn√©
            if (trouModeActive && selectedWordIndices.has(wordIndex)) {
              className += " word-trou";
            }

            // Ajouter l'√©v√©nement de double-clic si le mode est actif
            const dataIndex = trouModeActive
              ? ` data-word-index="${wordIndex}" ondblclick="toggleWordTrou(${wordIndex})" style="cursor: pointer;"`
              : "";

            html += `<span class="${className}"${tooltip}${dataIndex}>${wordDNA}</span>`;
            lastEnd = word.end;
            wordIndex++;
          }
        }

        // V√©rifier s'il y a des codons stop apr√®s le dernier mot
        for (let i = lastEnd; i <= dna.length - 3; i += 3) {
          const codon = dna.substring(i, i + 3);
          if (["TAA", "TAG", "TGA"].includes(codon)) {
            html += `<span class="word-stop" title="Point">${codon}</span>`;
            lastEnd = i + 3;
          } else {
            break; // Arr√™ter si on rencontre un autre codon
          }
        }

        // Ajouter le reste de la s√©quence (s'il y en a)
        if (lastEnd < dna.length) {
          html += `<span>${dna.substring(lastEnd)}</span>`;
        }

        return html;
      }

      // Fonction pour basculer un mot en mode "√† trou"
      function toggleWordTrou(wordIndex) {
        if (!trouModeActive) return;

        if (selectedWordIndices.has(wordIndex)) {
          selectedWordIndices.delete(wordIndex);
        } else {
          selectedWordIndices.add(wordIndex);
        }

        // R√©encoder pour mettre √† jour l'affichage
        encodeText();
      }

      function encodeText() {
        const input = document.getElementById("textInput").value;
        const normalized = normalizeText(input);
        const output = document.getElementById("dnaOutput");
        let dna = "ATG";
        const wordPositions = [];
        const dnaToText = {}; // Correspondance ADN -> texte
        let currentWordStart = 3; // Apr√®s ATG
        let currentWordText = ""; // Texte du mot en cours
        let inWord = false;
        let isStartOfSentence = true; // Pour d√©tecter le d√©but de phrase

        for (let char of normalized) {
          let codonLength = 0;
          // G√©rer les caract√®res sp√©ciaux en premier (ponctuation)
          if (char === ".") {
            // Finaliser le mot actuel AVANT d'ajouter le point
            if (inWord) {
              const wordDNA = dna.substring(currentWordStart, dna.length);
              if (currentWordText) {
                dnaToText[wordDNA] = currentWordText;
              }
              wordPositions.push({
                type: "word",
                start: currentWordStart,
                end: dna.length,
              });
              inWord = false;
              currentWordText = "";
            }
            // Maintenant ajouter le point (qui ne fait pas partie du mot)
            dna += "TAA";
            // Ne pas mettre codonLength pour √©viter que le point initialise un nouveau mot
            isStartOfSentence = true; // Apr√®s un point, on est au d√©but d'une phrase
            continue; // Passer au caract√®re suivant sans traiter le point comme un codon de mot
          }
          // G√©rer l'apostrophe (tous les types normalis√©s vers ')
          // V√©rifier aussi directement les codes Unicode au cas o√π la normalisation n'a pas fonctionn√©
          else if (
            char === "'" ||
            char === "'" ||
            char === "'" ||
            char === "'" ||
            char.charCodeAt(0) === 0x0027 ||
            char.charCodeAt(0) === 0x2019 ||
            char.charCodeAt(0) === 0x2018
          ) {
            dna += "TTC";
            codonLength = 3;
            if (inWord) {
              currentWordText += "'";
            }
          }
          // G√©rer les espaces (tous les types normalis√©s vers espace standard)
          // V√©rifier aussi directement les codes Unicode au cas o√π la normalisation n'a pas fonctionn√©
          else if (
            char === " " ||
            char.charCodeAt(0) === 0x0020 ||
            char.charCodeAt(0) === 0x00a0 ||
            (char.charCodeAt(0) >= 0x2000 && char.charCodeAt(0) <= 0x200b) ||
            char.charCodeAt(0) === 0x202f ||
            char.charCodeAt(0) === 0x205f ||
            char.charCodeAt(0) === 0x3000
          ) {
            if (inWord) {
              // Finir le mot pr√©c√©dent
              const wordDNA = dna.substring(currentWordStart, dna.length);
              if (currentWordText) {
                dnaToText[wordDNA] = currentWordText;
              }
              wordPositions.push({
                type: "word",
                start: currentWordStart,
                end: dna.length,
              });
              inWord = false;
              currentWordText = "";
            }
            const spaceStart = dna.length;
            dna += "TTT";
            wordPositions.push({
              type: "space",
              start: spaceStart,
              end: dna.length,
            });
            currentWordStart = dna.length;
            continue;
          }
          // G√©rer les caract√®res accentu√©s (toujours en majuscule)
          else if (char === "√©" || char === "√â") {
            dna += "AGG"; // AGG (√â)
            codonLength = 3;
            if (inWord) currentWordText += "√â";
            isStartOfSentence = false;
          } else if (char === "√®" || char === "√à") {
            dna += "AGT"; // AGT (√à)
            codonLength = 3;
            if (inWord) currentWordText += "√à";
            isStartOfSentence = false;
          } else if (char === "√™" || char === "√ä") {
            dna += "ATA"; // ATA (√ä)
            codonLength = 3;
            if (inWord) currentWordText += "√ä";
            isStartOfSentence = false;
          } else if (char === "√´" || char === "√ã") {
            dna += "ATC"; // ATC (√ã)
            codonLength = 3;
            if (inWord) currentWordText += "√ã";
            isStartOfSentence = false;
          } else if (char === "√Ø" || char === "√è") {
            dna += "CCG"; // CCG (√è)
            codonLength = 3;
            if (inWord) currentWordText += "√è";
            isStartOfSentence = false;
          }
          // Pour les autres caract√®res
          else {
            let upperChar = char.toUpperCase();

            if (reverseCode[upperChar]) {
              dna += reverseCode[upperChar][0];
              codonLength = 3;
              if (inWord) currentWordText += upperChar;
              isStartOfSentence = false;
            }
            // Les caract√®res non codables sont simplement ignor√©s
          }

          if (codonLength > 0) {
            if (!inWord) {
              currentWordStart = dna.length - codonLength;
              inWord = true;
              // Initialiser le texte du mot avec le premier caract√®re
              if (char === "√©" || char === "√â") {
                currentWordText = "√â";
              } else if (char === "√®" || char === "√à") {
                currentWordText = "√à";
              } else if (char === "√™" || char === "√ä") {
                currentWordText = "√ä";
              } else if (char === "√´" || char === "√ã") {
                currentWordText = "√ã";
              } else if (char === "√Ø" || char === "√è") {
                currentWordText = "√è";
              } else if (
                char === "'" ||
                char === "'" ||
                char === "'" ||
                char === "'"
              ) {
                currentWordText = "'";
              } else if (char !== ".") {
                currentWordText = char.toUpperCase();
              } else {
                currentWordText = "";
              }
            }
          }
        }

        // Ajouter le dernier mot s'il existe
        if (inWord) {
          const wordDNA = dna.substring(currentWordStart, dna.length);
          if (currentWordText) {
            dnaToText[wordDNA] = currentWordText;
          }
          wordPositions.push({
            type: "word",
            start: currentWordStart,
            end: dna.length,
          });
        }

        // Ajouter les positions des mots "√† trou" √† la fin de la s√©quence si le mode est actif
        const copyBtn = document.getElementById("copyBtn");
        const exportEDIBtn = document.getElementById("exportEDIBtn");
        const exportFASTABtn = document.getElementById("exportFASTABtn");

        // Stocker la s√©quence de base (sans marqueurs "√† trou")
        output.setAttribute("data-dna-base", dna);

        // Toujours afficher la s√©quence ADN coloris√©e
        const coloredDNA = colorizeDNA(dna, wordPositions, dnaToText);

        if (trouModeActive && selectedWordIndices.size > 0) {
          const trouPositions = encodeTrouPositions(selectedWordIndices);
          const fullSequence = dna + trouPositions;
          // Stocker la s√©quence compl√®te avec les positions dans un attribut data
          output.setAttribute("data-dna-sequence", fullSequence);
          output.setAttribute("data-trou-positions", trouPositions);
          // Afficher la s√©quence ADN coloris√©e (le texte reste visible)
          output.innerHTML =
            coloredDNA ||
            '<span style="color: #666;">Aucune s√©quence √† afficher.</span>';
          // Afficher les boutons
          copyBtn.style.display = "inline-block";
          exportEDIBtn.style.display = "inline-block";
          exportFASTABtn.style.display = "inline-block";
        } else if (trouModeActive) {
          // Mode "√† trou" actif mais aucun mot s√©lectionn√© - afficher quand m√™me la s√©quence
          output.setAttribute("data-dna-sequence", dna);
          output.removeAttribute("data-trou-positions");
          output.innerHTML =
            coloredDNA ||
            '<span style="color: #666;">Aucune s√©quence √† afficher. Double-cliquez sur les mots pour les s√©lectionner.</span>';
          // Afficher les boutons d'export
          copyBtn.style.display = "none";
          exportEDIBtn.style.display = "inline-block";
          exportFASTABtn.style.display = "inline-block";
        } else {
          // Mode "√† trou" d√©sactiv√©
          output.setAttribute("data-dna-sequence", dna);
          output.removeAttribute("data-trou-positions");
          output.innerHTML = coloredDNA || "";
          // Afficher les boutons d'export m√™me sans "√† trou"
          copyBtn.style.display = "none";
          exportEDIBtn.style.display = "inline-block";
          exportFASTABtn.style.display = "inline-block";
        }
      }

      // Fonction pour copier la s√©quence ADN avec les marqueurs "√† trou"
      function copyDNAWithTrous() {
        const output = document.getElementById("dnaOutput");
        const fullSequence = output.getAttribute("data-dna-sequence");

        if (fullSequence) {
          // Copier la s√©quence compl√®te (d√©j√† avec le marqueur et les positions)
          navigator.clipboard
            .writeText(fullSequence)
            .then(() => {
              const btn = document.getElementById("copyBtn");
              const originalText = btn.textContent;
              btn.textContent = "‚úì Copi√© !";
              btn.style.background = "#51cf66";
              setTimeout(() => {
                btn.textContent = originalText;
              }, 2000);
            })
            .catch((err) => {
              console.error("Erreur lors de la copie:", err);
              alert(
                "Erreur lors de la copie. Veuillez s√©lectionner manuellement la s√©quence."
              );
            });
        }
      }

      // Fonction pour exporter la s√©quence ADN en format .edi
      function exportEDIFile() {
        const output = document.getElementById("dnaOutput");
        const fullSequence = output.getAttribute("data-dna-sequence");

        if (!fullSequence) {
          alert(
            "Aucune s√©quence √† exporter. Veuillez d'abord encoder un texte."
          );
          return;
        }

        // Format .edi : format simple avec la s√©quence ADN (peut √™tre r√©import√©)
        // On exporte juste la s√©quence ADN, le format .edi sera reconnu par l'import
        const ediFile = fullSequence;

        // Cr√©er un blob et t√©l√©charger
        const blob = new Blob([ediFile], { type: "text/plain;charset=utf-8;" });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "sequence_encod√©e.edi");
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // Fonction pour exporter la s√©quence ADN en format .fasta
      function exportFASTAFile() {
        const output = document.getElementById("dnaOutput");
        const fullSequence = output.getAttribute("data-dna-sequence");

        if (!fullSequence) {
          alert(
            "Aucune s√©quence √† exporter. Veuillez d'abord encoder un texte."
          );
          return;
        }

        // Format FASTA : en-t√™te suivi de la s√©quence (60 caract√®res par ligne)
        const fastaContent = `>Sequence_ADN_encodee\n`;
        const sequenceLines = fullSequence.match(/.{1,60}/g) || [fullSequence];
        const fastaFile = fastaContent + sequenceLines.join("\n") + "\n";

        // Cr√©er un blob et t√©l√©charger
        const blob = new Blob([fastaFile], {
          type: "text/plain;charset=utf-8;",
        });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "sequence_encod√©e.fasta");
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      const tbody = document.getElementById("codeTable");
      const entries = Object.entries(geneticCode)
        .filter(([k, v]) => v !== "START")
        .sort(([a], [b]) => a.localeCompare(b));

      // Organiser en 4 colonnes, remplir verticalement (colonne par colonne)
      const numColumns = 4; // 4 colonnes de paires Codon/Symbole
      const entriesPerColumn = Math.ceil(entries.length / numColumns);

      // Cr√©er toutes les lignes n√©cessaires avec toutes les cellules vides
      const rows = [];
      for (let i = 0; i < entriesPerColumn; i++) {
        const row = document.createElement("tr");
        // Cr√©er 8 cellules vides (4 paires Codon/Symbole)
        for (let j = 0; j < numColumns * 2; j++) {
          const cell = document.createElement("td");
          row.appendChild(cell);
        }
        rows.push(row);
        tbody.appendChild(row);
      }

      // Remplir colonne par colonne (verticalement)
      // Colonne 0 : entr√©es 0, 1, 2, 3, ...
      // Colonne 1 : entr√©es entriesPerColumn, entriesPerColumn+1, ...
      // Colonne 2 : entr√©es 2*entriesPerColumn, 2*entriesPerColumn+1, ...
      // Colonne 3 : entr√©es 3*entriesPerColumn, 3*entriesPerColumn+1, ...
      entries.forEach(([codon, symbol], index) => {
        // Calculer la colonne et la ligne pour un remplissage vertical
        const columnIndex = Math.floor(index / entriesPerColumn);
        const rowIndex = index % entriesPerColumn;

        // S'assurer qu'on ne d√©passe pas le nombre de colonnes
        if (columnIndex >= numColumns) return;

        const row = rows[rowIndex];

        // Trouver la position dans la ligne (chaque colonne = 2 cellules : Codon + Symbole)
        const codonCellIndex = columnIndex * 2;
        const symbolCellIndex = codonCellIndex + 1;

        // Remplir les cellules
        row.cells[codonCellIndex].textContent = codon;
        row.cells[symbolCellIndex].textContent = symbol;

        // Colorer les codons stop en rose pastel
        if (["TAA", "TAG", "TGA"].includes(codon)) {
          row.cells[codonCellIndex].style.backgroundColor = "#ffb3d9";
          row.cells[symbolCellIndex].style.backgroundColor = "#ffb3d9";
        }
      });

      // Coloriser le textarea de d√©codage en temps r√©el
      const dnaInput = document.getElementById("dnaInput");
      dnaInput.addEventListener("input", function () {
        setTimeout(colorizeDNAInput, 10);
      });
      dnaInput.addEventListener("paste", function () {
        setTimeout(colorizeDNAInput, 10); // Attendre que le collage soit termin√©
      });

      // Fonction pour importer un fichier .edi
      function importEDIFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const text = e.target.result;
            const dnaInput = document.getElementById("dnaInput");

            // Format .edi : extraire la s√©quence ADN compl√®te (y compris les marqueurs "√† trou" TGGTGG)
            // On extrait toutes les s√©quences de nucl√©otides (A, T, C, G) pour pr√©server TGGTGG et les positions
            const sequences = text.match(/[ATCG]+/gi);

            if (sequences && sequences.length > 0) {
              // Concat√©ner toutes les s√©quences trouv√©es pour pr√©server les marqueurs "√† trou"
              const dnaSequence = sequences.join("").toUpperCase();
              dnaInput.textContent = dnaSequence;
              colorizeDNAInput();
              alert("Fichier .edi import√© avec succ√®s !");
            } else {
              alert("Aucune s√©quence ADN trouv√©e dans le fichier .edi");
            }

            event.target.value = "";
          } catch (error) {
            alert(
              "Erreur lors de la lecture du fichier .edi : " + error.message
            );
            event.target.value = "";
          }
        };
        reader.readAsText(file);
      }

      // Fonction pour importer un fichier .fasta
      function importFASTAFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const text = e.target.result;
            const dnaInput = document.getElementById("dnaInput");

            // Format FASTA : les lignes commen√ßant par > sont des en-t√™tes, les autres sont des s√©quences
            const lines = text.split("\n");
            let sequences = [];

            for (let line of lines) {
              line = line.trim();
              // Ignorer les lignes d'en-t√™te (commencent par >)
              if (line && !line.startsWith(">")) {
                // Extraire uniquement les caract√®res A, T, C, G (ignorer les espaces, retours √† la ligne, etc.)
                const sequence = line.replace(/[^ATCGatcg]/g, "").toUpperCase();
                if (sequence.length > 0) {
                  sequences.push(sequence);
                }
              }
            }

            if (sequences.length > 0) {
              // Concat√©ner toutes les s√©quences trouv√©es
              const dnaSequence = sequences.join("");
              dnaInput.textContent = dnaSequence;
              colorizeDNAInput();
              alert("Fichier .fasta import√© avec succ√®s !");
            } else {
              alert("Aucune s√©quence ADN trouv√©e dans le fichier .fasta");
            }

            event.target.value = "";
          } catch (error) {
            alert(
              "Erreur lors de la lecture du fichier .fasta : " + error.message
            );
            event.target.value = "";
          }
        };
        reader.readAsText(file);
      }

      // Fonction pour charger la s√©quence de test
      function loadTestSequence() {
        // S√©quence ADN de test √† mettre directement dans le champ de d√©codage
        let baseSequence =
          "ATGGGCACACCCACTCTTACAACTTTTGGCAAACTTGGCTTTACAGACCTTGGCACACCCACTCTTACAACTTTTCTTTTCACTGGCGTATTTGCCGTGACTTTTGCTGTGCCCCTTACTTTTACGACTTTTCGTTTCAAGCTCACTTAATTTATTGCTAAACTTACCGACCCCGGCTTTGCTAAAAATACTCGTAAACCCGGCTAA";

        // Nettoyer la s√©quence : retirer les espaces (TTT) qui suivent directement un point (TAA, TAG, TGA)
        // Cela √©vite d'avoir un espace entre deux phrases qui cause un deuxi√®me point
        baseSequence = baseSequence.replace(/(TAA|TAG|TGA)TTT+/g, "$1");

        // S√©quences ADN √† garder encod√©es (√† deviner)
        const sequencesToKeep = [
          "ACAGACCTTGGCACACCCACTCTTACAACT",
          "CGTTTCAAGCTCACT",
          "GCTAAAAATACTCGTAAACCCGGC",
        ];

        // D√©coder temporairement la s√©quence pour trouver les positions des mots
        // On va simuler le d√©codage pour trouver les indices
        const input = baseSequence;
        const startIndex = input.indexOf("ATG");
        if (startIndex === -1) {
          alert("S√©quence invalide : pas de codon START (ATG)");
          return;
        }

        // Trouver les positions des s√©quences √† garder
        const wordIndices = new Set();
        let wordIndex = 0;
        let currentWordDNA = "";

        for (let i = startIndex + 3; i <= input.length - 3; i += 3) {
          const codon = input.substring(i, i + 3);

          if (["TAA", "TAG", "TGA"].includes(codon)) {
            // Fin de mot (point)
            if (currentWordDNA) {
              // V√©rifier si cette s√©quence ADN correspond √† une des s√©quences √† garder
              for (const seqToKeep of sequencesToKeep) {
                if (currentWordDNA === seqToKeep) {
                  wordIndices.add(wordIndex);
                  break;
                }
              }
              currentWordDNA = "";
              wordIndex++;
            }
            // Ignorer les codons stop cons√©cutifs
            while (i + 3 <= input.length - 3) {
              const nextCodon = input.substring(i + 3, i + 6);
              if (["TAA", "TAG", "TGA"].includes(nextCodon)) {
                i += 3;
              } else {
                break;
              }
            }
          } else if (codon === "TTT") {
            // Espace - fin de mot
            if (currentWordDNA) {
              for (const seqToKeep of sequencesToKeep) {
                if (currentWordDNA === seqToKeep) {
                  wordIndices.add(wordIndex);
                  break;
                }
              }
              currentWordDNA = "";
              wordIndex++;
            }
          } else {
            // Caract√®re normal - ajouter au mot actuel
            currentWordDNA += codon;
          }
        }

        // Ajouter le dernier mot s'il existe
        if (currentWordDNA) {
          for (const seqToKeep of sequencesToKeep) {
            if (currentWordDNA === seqToKeep) {
              wordIndices.add(wordIndex);
              break;
            }
          }
        }

        // S'assurer que la s√©quence se termine par un seul point (TAA, TAG ou TGA)
        // Retirer tout ce qui suit le dernier point
        let cleanedSequence = baseSequence;
        let lastStopIndex = -1;
        for (let i = cleanedSequence.length - 3; i >= 0; i -= 3) {
          const codon = cleanedSequence.substring(i, i + 3);
          if (["TAA", "TAG", "TGA"].includes(codon)) {
            lastStopIndex = i;
            // V√©rifier s'il y a des codons stop cons√©cutifs avant
            let j = i - 3;
            while (j >= 0) {
              const prevCodon = cleanedSequence.substring(j, j + 3);
              if (["TAA", "TAG", "TGA"].includes(prevCodon)) {
                lastStopIndex = j;
                j -= 3;
              } else {
                break;
              }
            }
            break;
          }
        }

        if (lastStopIndex !== -1) {
          // Garder seulement jusqu'au dernier point (inclus)
          cleanedSequence = cleanedSequence.substring(0, lastStopIndex + 3);
        }

        // Ne pas ajouter les marqueurs "√† trou" - utiliser seulement la s√©quence de base nettoy√©e
        // Les s√©quences √† garder seront d√©tect√©es automatiquement lors du d√©codage
        let fullSequence = cleanedSequence;

        // Supprimer tout marqueur "√† trou" (TGGTGG) et ce qui suit s'il existe d√©j√† dans la s√©quence
        const trouMarkerIndex = fullSequence.indexOf(TROU_MARKER);
        if (trouMarkerIndex !== -1) {
          fullSequence = fullSequence.substring(0, trouMarkerIndex);
        }

        // Mettre la s√©quence directement dans le champ de d√©codage
        const dnaInput = document.getElementById("dnaInput");
        dnaInput.textContent = fullSequence;
        colorizeDNAInput();
      }

      // Fonction pour copier l'adresse email dans le presse-papier
      function copyEmailToClipboard() {
        const email = "michawaro.mail@gmail.com";
        navigator.clipboard
          .writeText(email)
          .then(() => {
            // Feedback visuel temporaire
            const icon = document.getElementById("emailIcon");
            const originalTitle = icon.title;
            icon.title = "Copi√© !";
            icon.style.transform = "scale(1.2)";
            setTimeout(() => {
              icon.title = originalTitle;
              icon.style.transform = "scale(1)";
            }, 1000);
          })
          .catch((err) => {
            console.error("Erreur lors de la copie :", err);
            alert("Erreur lors de la copie de l'adresse email");
          });
      }

      // Fonction pour exporter le code g√©n√©tique en CSV
      function exportGeneticCode() {
        const entries = Object.entries(geneticCode)
          .filter(([k, v]) => v !== "START")
          .sort(([a], [b]) => a.localeCompare(b));

        // Cr√©er le contenu CSV
        let csvContent = "Codon,Symbole\n";
        entries.forEach(([codon, symbol]) => {
          // √âchapper les virgules et guillemets dans les symboles
          const escapedSymbol =
            symbol.includes(",") || symbol.includes('"')
              ? `"${symbol.replace(/"/g, '""')}"`
              : symbol;
          csvContent += `${codon},${escapedSymbol}\n`;
        });

        // Cr√©er un blob et t√©l√©charger
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "code_genetique.csv");
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      // Fonction pour importer le code g√©n√©tique depuis un CSV
      function importGeneticCode(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const text = e.target.result;
            const lines = text.split("\n").filter((line) => line.trim() !== "");

            // Ignorer la premi√®re ligne (en-t√™te)
            const dataLines = lines.slice(1);

            // Cr√©er un nouveau code g√©n√©tique
            const newGeneticCode = { ATG: "START" };
            let hasError = false;
            let errorMessage = "";

            dataLines.forEach((line, index) => {
              // Parser la ligne CSV (g√©rer les virgules dans les valeurs)
              const match = line.match(/^([^,]+),(".*"|[^,]*)$/);
              if (match) {
                const codon = match[1].trim();
                let symbol = match[2].trim();

                // Enlever les guillemets si pr√©sents
                if (symbol.startsWith('"') && symbol.endsWith('"')) {
                  symbol = symbol.slice(1, -1).replace(/""/g, '"');
                }

                // Valider le codon (3 lettres A, T, C, G)
                if (/^[ATCG]{3}$/.test(codon)) {
                  newGeneticCode[codon] = symbol;
                } else {
                  hasError = true;
                  errorMessage += `Ligne ${
                    index + 2
                  }: Codon invalide "${codon}"\n`;
                }
              } else if (line.trim() !== "") {
                hasError = true;
                errorMessage += `Ligne ${index + 2}: Format invalide\n`;
              }
            });

            if (hasError) {
              alert("Erreurs lors de l'importation :\n" + errorMessage);
              return;
            }

            // Demander confirmation avant de remplacer
            if (
              confirm(
                "Voulez-vous remplacer le code g√©n√©tique actuel par celui du fichier CSV ?"
              )
            ) {
              // Remplacer le code g√©n√©tique
              Object.keys(geneticCode).forEach((key) => {
                if (key !== "ATG") delete geneticCode[key];
              });
              Object.assign(geneticCode, newGeneticCode);

              // Reconstruire le reverseCode global
              Object.keys(reverseCode).forEach(
                (key) => delete reverseCode[key]
              );
              for (let [codon, char] of Object.entries(geneticCode)) {
                if (char !== "START" && char !== "Majuscule") {
                  if (!reverseCode[char]) reverseCode[char] = [];
                  reverseCode[char].push(codon);
                }
              }

              // Recharger le tableau
              const tbody = document.getElementById("codeTable");
              tbody.innerHTML = "";
              const entries = Object.entries(geneticCode)
                .filter(([k, v]) => v !== "START")
                .sort(([a], [b]) => a.localeCompare(b));

              const numColumns = 4;
              const entriesPerColumn = Math.ceil(entries.length / numColumns);

              const rows = [];
              for (let i = 0; i < entriesPerColumn; i++) {
                const row = document.createElement("tr");
                for (let j = 0; j < numColumns * 2; j++) {
                  const cell = document.createElement("td");
                  row.appendChild(cell);
                }
                rows.push(row);
                tbody.appendChild(row);
              }

              entries.forEach(([codon, symbol], index) => {
                const columnIndex = Math.floor(index / entriesPerColumn);
                const rowIndex = index % entriesPerColumn;
                if (columnIndex >= numColumns) return;
                const row = rows[rowIndex];
                const codonCellIndex = columnIndex * 2;
                const symbolCellIndex = codonCellIndex + 1;
                row.cells[codonCellIndex].textContent = codon;
                row.cells[symbolCellIndex].textContent = symbol;

                // Colorer les codons stop en rose pastel
                if (["TAA", "TAG", "TGA"].includes(codon)) {
                  row.cells[codonCellIndex].style.backgroundColor = "#ffb3d9";
                  row.cells[symbolCellIndex].style.backgroundColor = "#ffb3d9";
                }
              });

              alert("Code g√©n√©tique import√© avec succ√®s !");
            }

            // R√©initialiser l'input file
            event.target.value = "";
          } catch (error) {
            alert("Erreur lors de la lecture du fichier : " + error.message);
            event.target.value = "";
          }
        };
        reader.readAsText(file);
      }
    </script>
  </body>
</html>
