<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      Cryptogen - Encodeur / Décodeur ADN | Convertir Texte en Séquence ADN
    </title>
    <meta
      name="description"
      content="Cryptogen : outil gratuit pour encoder et décoder du texte en séquence ADN. Créez des messages secrets avec le code génétique. Éditeur pixel art intégré pour dessiner dans l'ADN. Gratuit et sans inscription."
    />
    <meta
      name="keywords"
      content="encodeur ADN, décodeur ADN, cryptage ADN, séquence ADN, code génétique, cryptage texte, message secret, pixel art ADN, génétique, bioinformatique, outil pédagogique"
    />
    <meta name="author" content="Michawaro" />
    <meta
      name="robots"
      content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1"
    />
    <meta
      name="google-site-verification"
      content="NkVG6etTdlVCQqPhDHrmvjWMF3mEupZmvNkQcgDYYGc"
    />
    <link rel="canonical" href="https://michawaro.github.io/secret-ig/" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://michawaro.github.io/secret-ig/" />
    <meta
      property="og:title"
      content="Cryptogen - Encodeur / Décodeur ADN | Convertir Texte en Séquence ADN"
    />
    <meta
      property="og:description"
      content="Outil gratuit pour encoder et décoder du texte en séquence ADN. Créez des messages secrets avec le code génétique. Éditeur pixel art intégré."
    />
    <meta
      property="og:image"
      content="https://www.dropbox.com/scl/fi/43zx4lyuc3rtzssraez67/Logo-Michawaro.png?rlkey=s5tgng6uud0nl6ic3u1ipnkip&st=jmke0kcf&raw=1"
    />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:locale" content="fr_FR" />
    <meta property="og:site_name" content="Cryptogen" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="https://michawaro.github.io/secret-ig/" />
    <meta name="twitter:title" content="Cryptogen - Encodeur / Décodeur ADN" />
    <meta
      name="twitter:description"
      content="Outil gratuit pour encoder et décoder du texte en séquence ADN. Créez des messages secrets avec le code génétique."
    />
    <meta
      name="twitter:image"
      content="https://www.dropbox.com/scl/fi/43zx4lyuc3rtzssraez67/Logo-Michawaro.png?rlkey=s5tgng6uud0nl6ic3u1ipnkip&st=jmke0kcf&raw=1"
    />

    <!-- Structured Data (JSON-LD) -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Cryptogen",
        "description": "Outil gratuit en ligne pour encoder et décoder du texte en séquence ADN. Créez des messages secrets avec le code génétique. Éditeur pixel art intégré pour dessiner dans l'ADN.",
        "url": "https://michawaro.github.io/secret-ig/",
        "applicationCategory": "EducationalApplication",
        "operatingSystem": "Any",
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "EUR"
        },
        "aggregateRating": {
          "@type": "AggregateRating",
          "ratingValue": "5",
          "ratingCount": "1"
        },
        "featureList": [
          "Encodeur de texte en séquence ADN",
          "Décodeur de séquence ADN en texte",
          "Éditeur pixel art avec conversion ADN",
          "Export en format FASTA",
          "Interface intuitive et gratuite"
        ],
        "creator": {
          "@type": "Organization",
          "name": "Michawaro",
          "url": "https://michawaro.github.io/michawaro/"
        },
        "inLanguage": "fr"
      }
    </script>

    <link
      rel="icon"
      type="image/png"
      href="https://www.dropbox.com/scl/fi/43zx4lyuc3rtzssraez67/Logo-Michawaro.png?rlkey=s5tgng6uud0nl6ic3u1ipnkip&st=jmke0kcf&raw=1"
    />
    <link
      rel="apple-touch-icon"
      href="https://www.dropbox.com/scl/fi/43zx4lyuc3rtzssraez67/Logo-Michawaro.png?rlkey=s5tgng6uud0nl6ic3u1ipnkip&st=jmke0kcf&raw=1"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&family=Comfortaa:wght@400;500;600;700&family=Quicksand:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #8a9bb0 0%, #c4d9e8 100%);
        color: #222;
        min-height: 100vh;
        padding-bottom: 60px;
      }
      .container {
        max-width: 1440px;
        margin: 0 auto;
        padding: 40px 20px;
      }
      header {
        text-align: center;
        margin-bottom: 60px;
        padding: 40px 180px 40px 40px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
        position: relative;
        min-height: 120px;
      }
      header > *:not(.header-logo) {
        display: block;
        width: 100%;
        max-width: 100%;
      }
      .header-logo {
        position: absolute;
        top: 50%;
        right: 20px;
        transform: translateY(-50%);
        width: 150px;
        height: auto;
        cursor: pointer;
        transition: transform 0.3s ease, opacity 0.3s ease;
        z-index: 1;
      }
      .header-logo:hover {
        transform: translateY(-50%) scale(1.05);
        opacity: 0.9;
      }
      /* Styles pour les cellules de la grille pixel art */
      .pixel-cell {
        min-width: 0 !important;
        min-height: 0 !important;
        flex-shrink: 1 !important;
        flex-grow: 0 !important;
      }
      #pixelGrid {
        contain: layout style;
      }
      /* Styles pour l'image de la fabrique dans l'éditeur Pixel Art */
      .pixel-art-image-container {
        display: flex;
        align-items: flex-start;
        gap: 20px;
        flex-wrap: nowrap;
      }
      .pixel-art-grid-wrapper {
        flex: 1;
        min-width: 500px;
        width: 100%;
      }
      .pixel-grid-image-wrapper {
        display: flex;
        align-items: flex-start;
        gap: 20px;
        flex-wrap: nowrap;
      }
      /* Modal pour l'agrandissement de l'image La fabrique */
      .fabrique-zoom-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 10000;
        justify-content: center;
        align-items: center;
        cursor: pointer;
      }
      .fabrique-zoom-modal.active {
        display: flex;
      }
      .fabrique-zoom-content {
        position: relative;
        max-width: 90%;
        max-height: 90%;
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        cursor: default;
      }
      .fabrique-zoom-content img {
        max-width: 100%;
        max-height: 80vh;
        height: auto;
        display: block;
      }
      .fabrique-zoom-close {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 30px;
        height: 30px;
        background-color: #fff;
        border: 2px solid #333;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 18px;
        font-weight: bold;
        color: #333;
        transition: all 0.2s;
      }
      .fabrique-zoom-close:hover {
        background-color: #f0f0f0;
        transform: scale(1.1);
      }
      .fabrique-zoom-close::before {
        content: "✓";
      }
      .pixel-art-illustration {
        flex-shrink: 0;
        max-width: 460px;
        width: auto;
        height: auto;
        align-self: flex-start;
        object-fit: contain;
        cursor: pointer;
        transition: transform 0.2s;
      }
      .pixel-art-illustration:hover {
        transform: scale(1.02);
      }
      /* Media query pour mobile en mode portrait */
      @media (max-width: 768px) and (orientation: portrait) {
        .pixel-art-image-container {
          flex-direction: column;
        }
        .pixel-art-grid-wrapper {
          min-width: 100%;
          width: 100%;
        }
        .pixel-grid-image-wrapper {
          flex-direction: column !important;
          flex-wrap: wrap;
        }
        .pixel-art-illustration {
          max-width: 100%;
          width: 100%;
          margin-top: 20px;
          align-self: center;
          order: 2;
        }
        #pixelGrid {
          order: 1;
        }
      }
      @media (max-width: 768px) {
        .section {
          padding: 20px 10px !important;
          overflow-x: hidden !important;
        }
        #code-input-window {
          width: 100% !important;
          max-width: 100% !important;
          padding: 10px 5px !important;
          overflow-x: hidden !important;
        }
        /* Sur mobile, afficher les fenêtres papa/maman/manip en colonne */
        #activity1-container {
          grid-template-columns: 1fr !important;
          gap: 15px !important;
        }
        #code-input-window > div {
          max-width: 100% !important;
          overflow-x: auto !important;
        }
        #activity1-container {
          gap: 10px !important;
          grid-template-columns: 1fr !important;
          width: 100% !important;
          max-width: 100% !important;
          padding: 0 !important;
          margin-left: 0 !important;
          margin-right: 0 !important;
          overflow-x: hidden !important;
        }
        #activity1-container > div {
          width: 100% !important;
          max-width: 100% !important;
          box-sizing: border-box !important;
          overflow-x: hidden !important;
          min-width: 0 !important;
        }
        #activity1-container > div > div {
          max-width: 100% !important;
          overflow-x: auto !important;
        }
        .nucleotide-square,
        .nucleotide-square-empty {
          width: calc((100% - 15px) / 4) !important;
          max-width: 50px !important;
          min-width: 30px !important;
          height: auto !important;
          aspect-ratio: 1 !important;
          font-size: clamp(0.8rem, 2.2vw, 1.2rem) !important;
          flex-shrink: 1 !important;
        }
        #activity1-container > div:nth-child(1) .nucleotide-square {
          width: calc((100% - 15px) / 4) !important;
        }
        #activity1-container > div:nth-child(2) .nucleotide-square {
          width: calc((100% - 20px) / 5) !important;
        }
        #activity1-container > div:nth-child(3) .nucleotide-square {
          width: calc((100% - 25px) / 6) !important;
        }
        #activity1-container > div > div {
          gap: 3px !important;
          padding: 0 2px !important;
        }
        .pixel-art-image-container {
          flex-direction: column;
        }
        .pixel-art-grid-wrapper {
          min-width: 100%;
          width: 100%;
        }
        .pixel-grid-image-wrapper {
          flex-direction: column !important;
          flex-wrap: wrap;
          width: 100%;
        }
        .pixel-art-illustration {
          max-width: 100%;
          width: 100%;
          margin-bottom: 20px;
          align-self: center;
          order: 1;
        }
        #pixelGrid {
          order: 2;
          width: 100% !important;
          max-width: 100% !important;
          min-width: 100% !important;
        }
        /* Header de la modale Pixel Art - boutons sous le titre sur mobile */
        #pixelArtModalHeader {
          flex-direction: column !important;
          align-items: flex-start !important;
        }
        #pixelArtModalHeader h2 {
          width: 100% !important;
          margin-bottom: 15px !important;
        }
        #pixelArtModalButtons {
          width: 100% !important;
          justify-content: center !important;
          flex-wrap: wrap !important;
        }
        #pixelArtModalButtons button {
          flex: 1 !important;
          min-width: 140px !important;
        }
        /* Correction de la troncature de la grille sur mobile */
        #pixelArtContent {
          width: 100% !important;
          max-width: 100% !important;
          overflow-x: hidden !important;
          box-sizing: border-box !important;
        }
        #pixelArtContent > div {
          width: 100% !important;
          max-width: 100% !important;
          box-sizing: border-box !important;
        }
        #pixelArtContent > div > div[style*="flex: 1"] {
          min-width: 0 !important;
          width: 100% !important;
          max-width: 100% !important;
        }
        /* Conteneur principal de l'éditeur */
        #pixelArtContent > div {
          gap: 15px !important;
        }
        /* Conteneur de la modale */
        #pixelArtModal > div {
          padding: 20px 15px !important;
          max-width: 100% !important;
          margin: 10px auto !important;
        }
      }
      /* Mode portrait mobile : tout en colonne, grille en pleine largeur après les boutons */
      @media (max-width: 768px) and (orientation: portrait) {
        /* Mode portrait : tout en colonne, grille en pleine largeur après les boutons */
        #pixelArtContent > div {
          flex-direction: column !important;
          flex-wrap: nowrap !important;
        }
        /* Palette et outils en haut en portrait */
        #pixelArtContent > div > div:first-child {
          width: 100% !important;
          flex: 0 0 auto !important;
          order: 1 !important;
          max-width: 100% !important;
        }
        /* Conteneur de la grille en bas en portrait */
        #pixelArtContent > div > div:last-child {
          width: 100% !important;
          flex: 0 0 auto !important;
          order: 2 !important;
          max-width: 100% !important;
          display: block !important;
        }
        /* Grille en pleine largeur en portrait */
        #pixelGrid {
          width: 100% !important;
          max-width: 100% !important;
          aspect-ratio: 1 !important;
          display: grid !important;
          visibility: visible !important;
          opacity: 1 !important;
        }
        /* Cellules de la grille en portrait */
        #pixelGrid .pixel-cell {
          min-width: 0 !important;
          min-height: 0 !important;
          width: auto !important;
          height: auto !important;
        }
      }
      /* Mode paysage mobile : boutons à gauche, grille optimisée en hauteur */
      @media (max-width: 768px) and (orientation: landscape) {
        #pixelArtContent > div {
          flex-direction: row !important;
          flex-wrap: nowrap !important;
          align-items: flex-start !important;
          gap: 15px !important;
        }
        /* Palette et outils à gauche */
        #pixelArtContent > div > div:first-child {
          flex: 0 0 200px !important;
          max-width: 200px !important;
          order: 1 !important;
        }
        /* Conteneur de la grille à droite */
        #pixelArtContent > div > div:last-child {
          flex: 1 1 auto !important;
          min-width: 0 !important;
          order: 2 !important;
        }
        /* Grille optimisée en hauteur pour le paysage */
        #pixelGrid {
          width: 100% !important;
          max-width: 100% !important;
          aspect-ratio: unset !important;
          max-height: calc(100vh - 250px) !important;
          height: auto !important;
          display: grid !important;
          visibility: visible !important;
          opacity: 1 !important;
        }
        /* Cellules de la grille en paysage */
        #pixelGrid .pixel-cell {
          min-width: 0 !important;
          min-height: 0 !important;
          width: auto !important;
          height: auto !important;
        }
        /* Conteneur de la grille optimisé en paysage */
        #pixelArtContent > div > div:last-child {
          max-height: calc(100vh - 250px) !important;
          overflow-y: auto !important;
        }
        /* Ajuster la hauteur de la modale en paysage */
        #pixelArtModal > div {
          max-height: 95vh !important;
          overflow-y: auto !important;
          padding: 15px 10px !important;
        }
      }
      @media (max-width: 768px) {
        .container {
          padding: 15px 10px;
        }
        header {
          padding: 20px;
          min-height: auto;
        }
        .header-logo {
          position: static;
          transform: none;
          display: block;
          margin: 0 auto 20px auto;
          width: 120px;
        }
        .header-logo:hover {
          transform: scale(1.05);
        }
        header h1 {
          margin-top: 0;
          padding-right: 0;
          font-size: 2rem;
          word-wrap: break-word;
          overflow-wrap: break-word;
        }
        header .subtitle {
          display: block;
          width: 100%;
          white-space: normal;
          word-wrap: break-word;
          overflow-wrap: break-word;
          font-size: 1rem;
          line-height: 1.5;
        }
        header p {
          display: block;
          width: 100%;
          white-space: normal;
          word-wrap: break-word;
          overflow-wrap: break-word;
        }
        header > *:not(.header-logo) {
          width: 100%;
        }
        .section {
          width: 100%;
          max-width: 100%;
          padding: 20px 15px;
          margin-left: 0;
          margin-right: 0;
          box-sizing: border-box;
        }
      }
      h1 {
        font-size: 3rem;
        font-weight: 900;
        margin: 0 0 20px 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        letter-spacing: 0.02em;
        font-family: "Nunito", "Comfortaa", "Quicksand", -apple-system,
          BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial,
          sans-serif;
        display: block;
        width: 100%;
      }
      .subtitle {
        font-size: 1.3rem;
        color: #666;
        margin: 0;
        font-weight: 400;
        line-height: 1.6;
        display: block;
        width: 100%;
      }
      .section {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 40px;
        margin-bottom: 40px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
      }
      h2 {
        font-size: 2.4rem;
        font-weight: 800;
        margin: 0 0 30px 0;
        text-align: center;
        color: #333;
        letter-spacing: 0.02em;
        font-family: "Nunito", "Comfortaa", "Quicksand", -apple-system,
          BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial,
          sans-serif;
      }
      textarea {
        width: 100%;
        height: 160px;
        font-family: "Courier New", monospace;
        font-size: 1.1rem;
        padding: 20px;
        border-radius: 12px;
        border: 2px solid #e0e0e0;
        resize: vertical;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
        line-height: 1.6;
      }
      textarea::placeholder {
        color: #999;
        opacity: 1;
      }
      textarea:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }
      button {
        margin-top: 20px;
        padding: 16px 32px;
        font-size: 1.1rem;
        font-weight: 600;
        border-radius: 12px;
        border: none;
        cursor: pointer;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
          1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
          1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
          0 0 5px rgba(0, 0, 0, 0.5);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        touch-action: manipulation;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
      }
      button:active {
        transform: translateY(0);
      }
      .output {
        margin-top: 30px;
        padding: 25px;
        background: #f8f9fa;
        border-radius: 12px;
        min-height: 80px;
        max-height: 400px;
        overflow-y: auto;
        font-size: 1.2rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        line-height: 2;
        border: 2px solid #e0e0e0;
        font-family: "Courier New", monospace;
      }
      /* Message pour la fenêtre de résultats de décodage */
      #output:empty:before {
        content: "Les résultats apparaîtront ici, tu vas savoir ce qu'on souhaite te dire à partir de cet ADN !";
        color: #999;
        font-style: italic;
      }
      /* Message pour la fenêtre de résultats d'encodage */
      #dnaOutput:empty:before {
        content: "Le résultat apparaîtra ici... Tu peux le copier-coller dans encodage pour tester que tout fonctionne puis envoyer ce message codé à qui tu veux. Pour les textes à trous, double-clique sur les mots que tu souhaites masquer.";
        color: #999;
        font-style: italic;
      }
      /* Animations pour la première fenêtre de démarrage */
      @keyframes pulseWindow {
        0%, 100% {
          box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.4);
        }
        50% {
          box-shadow: 0 0 0 8px rgba(76, 175, 80, 0);
        }
      }
      
      @keyframes shineLink {
        0% {
          background-position: -100% 0;
        }
        100% {
          background-position: 200% 0;
        }
      }
      
      @keyframes clickCursor {
        0%, 100% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
        45% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
        50% {
          opacity: 0.8;
          transform: translateY(3px) scale(0.9);
        }
        55% {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }
      
      #demarrageFenetre1 {
        animation: pulseWindow 3s ease-in-out infinite;
      }
      
      #demarrageFenetre1 a {
        position: relative;
        display: inline-block;
        transition: all 0.3s ease;
        padding: 2px 4px;
        border-radius: 4px;
      }
      
      #demarrageFenetre1 a:hover {
        animation: shineLink 1.5s ease-in-out;
        transform: scale(1.05);
        background: linear-gradient(90deg, transparent, rgba(76, 175, 80, 0.2), transparent);
        background-size: 200% 100%;
      }
      
      
      /* Style pour "le formulaire" dans la 3e fenêtre */
      .formulaire-link {
        position: relative;
        display: inline-block;
        transition: all 0.3s ease;
        padding: 2px 4px;
        border-radius: 4px;
        color: #4caf50;
        text-decoration: underline;
        cursor: pointer;
      }
      
      .formulaire-link:hover {
        animation: shineLink 1.5s ease-in-out;
        transform: scale(1.05);
        background: linear-gradient(90deg, transparent, rgba(76, 175, 80, 0.2), transparent);
        background-size: 200% 100%;
      }
      
      .word-space {
        background-color: #e0e0e0;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-short {
        background-color: #b3d9ff;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-medium {
        background-color: #b3ffb3;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-long {
        background-color: #fff9b3;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-verylong {
        background-color: #ffb3d9;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-trou {
        background-color: #ff6b6b !important;
        opacity: 0.7;
        cursor: pointer;
        position: relative;
      }
      .word-stop {
        background-color: #ffb3d9;
        padding: 4px 6px;
        border-radius: 4px;
        margin: 0 2px;
      }
      .word-trou:hover {
        opacity: 1;
      }
      .word-trou::after {
        content: "✕";
        position: absolute;
        top: -8px;
        right: -8px;
        background: #ff6b6b;
        color: white;
        text-shadow: -0.3px -0.3px 0 rgba(0, 0, 0, 0.5),
          0.3px -0.3px 0 rgba(0, 0, 0, 0.5), -0.3px 0.3px 0 rgba(0, 0, 0, 0.5),
          0.3px 0.3px 0 rgba(0, 0, 0, 0.5), 0 0 0.5px rgba(0, 0, 0, 0.3);
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
      }
      .trou-mode-active {
        background: #fff3cd !important;
        border: 2px solid #ffc107 !important;
      }
      #dnaInput {
        width: 100%;
        min-height: 160px;
        max-height: 400px;
        overflow-y: auto;
        font-family: "Courier New", monospace;
        font-size: 1.1rem;
        padding: 20px;
        border-radius: 12px;
        border: 2px solid #e0e0e0;
        background: white;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        transition: border-color 0.3s ease;
        line-height: 1.6;
      }
      #dnaInput:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      }
      #dnaInput:empty:before {
        content: attr(placeholder);
        color: #999;
        pointer-events: none;
      }
      /* Menu contextuel pour les modifications de séquence */
      #contextMenu {
        position: fixed;
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        padding: 8px 0;
        z-index: 10000;
        min-width: 180px;
        display: none;
      }
      #contextMenu .menu-item {
        padding: 10px 20px;
        cursor: pointer;
        transition: background-color 0.2s;
        font-size: 0.95rem;
      }
      #contextMenu .menu-item:hover {
        background-color: #f0f0f0;
      }
      #contextMenu .menu-item:active {
        background-color: #e0e0e0;
      }
      /* Style pour les nucléotides modifiés - additions (blanc sur fond noir) */
      .nucleotide-modified {
        color: white !important;
        background-color: black !important;
        padding: 2px 1px;
        border-radius: 2px;
      }
      /* Style pour les nucléotides substitués (fond mauve) */
      .nucleotide-substituted {
        color: white !important;
        background-color: #9b59b6 !important;
        padding: 2px 1px;
        border-radius: 2px;
      }
      /* Style pour les délétions (marqueur visuel - croix rouge dans un carré) */
      .nucleotide-deleted-marker {
        display: inline-block;
        width: 16px;
        height: 16px;
        background-color: white;
        border: 2px solid #ff6b6b;
        border-radius: 2px;
        position: relative;
        vertical-align: middle;
        margin: 0 2px;
        box-sizing: border-box;
      }
      .nucleotide-deleted-marker::before,
      .nucleotide-deleted-marker::after {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        width: 10px;
        height: 2px;
        background-color: #ff6b6b;
        transform: translate(-50%, -50%) rotate(45deg);
      }
      .nucleotide-deleted-marker::after {
        transform: translate(-50%, -50%) rotate(-45deg);
      }
      /* Style pour les marqueurs de séparation entre triplets */
      .triplet-separator {
        display: inline-block;
        width: 1.5px;
        height: 0.5em;
        background-color: #000;
        vertical-align: top;
        margin: 0 0.5px;
        position: relative;
        top: -0.15em;
      }
      table {
        margin: 0 auto;
        width: 100%;
        max-width: 1000px;
        border-collapse: collapse;
        background: white;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
      }
      th,
      td {
        padding: 10px 12px;
        border-bottom: 1px solid #eee;
        border-right: 1px solid #eee;
        text-align: center;
        font-family: "Courier New", monospace;
        font-size: 0.95rem;
        width: 12.5%;
      }
      th {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
          1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
          1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
          0 0 5px rgba(0, 0, 0, 0.5);
        font-weight: 600;
        text-transform: uppercase;
        font-size: 0.85rem;
        letter-spacing: 0.05em;
      }
      td:last-child,
      th:last-child {
        border-right: none;
      }
      tr:hover {
        background-color: #f8f9fa;
      }
      tr:last-child td {
        border-bottom: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <a
          href="https://michawaro.github.io/michawaro/"
          target="_blank"
          title="Aller sur la page Michawaro"
        >
          <img
            src="https://www.dropbox.com/scl/fi/43zx4lyuc3rtzssraez67/Logo-Michawaro.png?rlkey=s5tgng6uud0nl6ic3u1ipnkip&st=jmke0kcf&raw=1"
            alt="Logo Michawaro - Cryptogen Encodeur Décodeur ADN"
            class="header-logo"
            width="150"
            height="150"
            onerror="this.style.display='none'; this.nextElementSibling.style.display='block';"
          />
          <div
            class="header-logo"
            style="
              display: none;
              width: 150px;
              height: 150px;
              background: linear-gradient(135deg, #e84e9b 0%, #ff6b9d 100%);
              border-radius: 50%;
              position: relative;
              overflow: hidden;
            "
          >
            <div
              style="
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                text-align: center;
                color: white;
                font-weight: bold;
                z-index: 2;
                width: 85%;
                padding: 0;
                box-sizing: border-box;
              "
            >
              <div
                style="
                  font-size: 0.95rem;
                  margin-bottom: 3px;
                  line-height: 1.1;
                  white-space: nowrap;
                "
              >
                MICHAWARO
              </div>
              <div style="font-size: 0.65rem; color: #fce86e; line-height: 1.1">
                APPRENDRE, ENSEIGNER, PARTAGER
              </div>
            </div>
            <svg
              style="
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                opacity: 0.3;
              "
              viewBox="0 0 100 100"
              preserveAspectRatio="none"
            >
              <path
                d="M50,10 Q30,30 20,50 Q30,70 50,90 Q70,70 80,50 Q70,30 50,10"
                stroke="#8B4A9B"
                stroke-width="2"
                fill="none"
              />
              <path
                d="M50,15 Q35,30 25,50 Q35,70 50,85 Q65,70 75,50 Q65,30 50,15"
                stroke="#8B4A9B"
                stroke-width="1.5"
                fill="none"
              />
            </svg>
          </div>
        </a>
        <h1>Cryptogen - Encodeur / Décodeur ADN</h1>
        <p class="subtitle">
          Cache un message secret ou même une image dans une séquence ADN !
        </p>
        <p class="subtitle" style="margin-top: 10px; font-size: 1rem">
          Mode d'emploi de l'encodeur dans
          <a
            href="https://youtu.be/hiESgS8diVg
            target="_blank"
            style="color: #667eea; text-decoration: underline"
            >cette vidéo</a
          >. Des exemples d'utilisation seront ajoutés sur
          <a
            href="https://michawaro.github.io/michawaro/"
            target="_blank"
            style="color: #667eea; text-decoration: underline"
            >la page Michawaro</a
          >.
        </p>
        <p class="subtitle" style="margin-top: 10px; font-size: 1rem">
          Pour des retours ou suggestions vous pouvez
          <a
            href="mailto:michawaro.mail@gmail.com"
            style="
              color: #667eea;
              text-decoration: underline;
              cursor: pointer;
              transition: color 0.2s ease;
            "
            onmouseover="this.style.color='#764ba2'"
            onmouseout="this.style.color='#667eea'"
            >me contacter</a
          >.
        </p>
      </header>

      <div class="section">
        <h2>Démarrage</h2>
        <div
          style="
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
          "
        >
          <p
            id="demarrageFenetre1"
            style="
              margin: 0;
              color: #333;
              font-size: 1.1rem;
              line-height: 1.8;
              padding: 15px;
              background: rgba(76, 175, 80, 0.1);
              border-radius: 8px;
              border-left: 4px solid #4caf50;
              flex: 1;
              min-width: 250px;
              text-align: center;
            "
          >
            Je suis pressé, montre moi comment :<br /><br />
            <a href="#" onclick="highlightEncodeTextSequence(); return false;" style="color: #4caf50; text-decoration: underline; cursor: pointer;">transformer un texte en une séquence ADN</a><br />
            <a href="#" onclick="highlightPixelArtWithTooltip(); return false;" style="color: #4caf50; text-decoration: underline; cursor: pointer;">transformer une image en une séquence ADN</a><br />
            <a href="#" onclick="highlightDecodeSequence(); return false;" style="color: #4caf50; text-decoration: underline; cursor: pointer;">décoder une séquence ADN</a>
          </p>
          <p
            style="
              margin: 0;
              color: #333;
              font-size: 1.1rem;
              line-height: 1.8;
              padding: 15px;
              background: rgba(233, 30, 99, 0.1);
              border-radius: 8px;
              border-left: 4px solid #e91e63;
              flex: 1;
              min-width: 250px;
              text-align: center;
            "
          >
            J'ai 5 minutes pour regarder la vidéo explicative :<br />
            <a href="https://youtu.be/hiESgS8diVg" target="_blank" style="display: inline-block; margin-top: 10px; cursor: pointer;">
              <img id="videoExplicativeImg" src="https://dl.dropboxusercontent.com/scl/fi/kmx268y2xchlu1objbjo4/ADN-Mut.jpg?rlkey=lziujwhr354lq43r3j28t2nfl&st=1mzqlzub&dl=1" alt="Miniature vidéo explicative" style="max-width: 50%; height: auto; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); transition: transform 0.2s ease;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'" />
            </a>
          </p>
          <p
            style="
              margin: 0;
              color: #333;
              font-size: 1.1rem;
              line-height: 1.8;
              padding: 15px;
              background: rgba(102, 126, 234, 0.1);
              border-radius: 8px;
              border-left: 4px solid #667eea;
              flex: 1;
              min-width: 250px;
              text-align: center;
            "
          >
            Je suis ici en activité pratique. Pour gagner du temps sur la mise en page je peux directement répondre dans le formulaire :
            <br /><br />
            <button
              onclick="window.open('https://www.dropbox.com/scl/fi/0iof5ncrdisucs2he5bql/TP-Enonc-Seconde.pdf?rlkey=ytiq7buu07wlq81eqr353cs7f&st=10wwmwn9&dl=0', '_blank')"
              style="
                padding: 12px 24px;
                font-size: 1rem;
                font-weight: 600;
                color: white;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                border: none;
                border-radius: 8px;
                cursor: pointer;
                transition: transform 0.2s, box-shadow 0.2s;
                box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
                margin: 0 7.5px;
              "
              onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(102, 126, 234, 0.4)'"
              onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.3)'"
            >
              Enoncé 2nde
            </button>
            <button
              disabled
              style="
                padding: 12px 24px;
                font-size: 1rem;
                font-weight: 600;
                color: #999;
                background: #e0e0e0;
                border: none;
                border-radius: 8px;
                cursor: not-allowed;
                opacity: 0.6;
                margin: 0 7.5px;
              "
            >
              Enoncé 1ere
            </button>
          </p>
        </div>
      </div>

      <div class="section">
        <h2>Prérequis</h2>
        <div
          style="
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-top: 30px;
          "
        >
          <div
            style="
              background: rgba(255, 255, 255, 0.8);
              border-radius: 12px;
              padding: 25px;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            "
          >
            <h3
              style="
                margin: 0 0 20px 0;
                color: #333;
                font-size: 1.5rem;
                font-weight: 600;
                text-align: center;
              "
            >
              Quelques notions sur l'ADN
            </h3>
            <div
              id="notionsADNButtons"
              style="display: flex; flex-direction: column; gap: 10px"
            >
              <button
                onclick="window.open('https://www.canva.com/design/DAG8F9XFrVY/dBv3GvqcVJZxjU3WLcnF3w/view?utm_content=DAG8F9XFrVY&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=h27ee868e96', '_blank')"
                style="
                  padding: 12px 20px;
                  font-size: 1rem;
                  font-weight: 600;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  color: white;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(102, 126, 234, 0.3)'"
              >
                Une molécule organisée...
              </button>
              <button
                onclick="window.open('https://www.canva.com/design/DAG8PqCZsx4/65sGfIci6KjlzDWKIhrujg/view?utm_content=DAG8PqCZsx4&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=hd3cb4c7f86', '_blank')"
                style="
                  padding: 12px 20px;
                  font-size: 1rem;
                  font-weight: 600;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  color: white;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(102, 126, 234, 0.3)'"
              >
                ... contenant une information protégée...
              </button>
              <button
                onclick="window.open('https://www.canva.com/design/DAG82J0a6jM/33WMkTJz7Lt373T6xUUjiw/view?utm_content=DAG82J0a6jM&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=he90e507cbc', '_blank')"
                style="
                  padding: 12px 20px;
                  font-size: 1rem;
                  font-weight: 600;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  color: white;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(102, 126, 234, 0.3)'"
              >
                ... mais néanmoins modifiable ...
              </button>
              <button
                onclick="window.open('https://www.canva.com/design/DAG8Wk40uNo/nCiev7Hi3YpwK8x2OfDREQ/view?utm_content=DAG8Wk40uNo&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=hfc30b894ce', '_blank')"
                style="
                  padding: 12px 20px;
                  font-size: 1rem;
                  font-weight: 600;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  color: white;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(102, 126, 234, 0.3)'"
              >
                ... dont l'expression conduit à la synthèse de protéines.
              </button>
            </div>
          </div>
          <div
            style="
              background: rgba(255, 255, 255, 0.8);
              border-radius: 12px;
              padding: 25px;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            "
          >
            <h3
              style="
                margin: 0 0 20px 0;
                color: #333;
                font-size: 1.5rem;
                font-weight: 600;
                text-align: center;
              "
            >
              Je me teste
            </h3>
            <div
              id="testButtons"
              style="display: flex; flex-direction: column; gap: 10px"
            >
              <button
                onclick="window.open('https://michawaro.github.io/cryptogen/Quiz/2nde/', '_blank')"
                style="
                  padding: 12px 20px;
                  font-size: 1rem;
                  font-weight: 600;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  background: linear-gradient(135deg, #e84e9b 0%, #ff6b9d 100%);
                  color: white;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(232, 78, 155, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(232, 78, 155, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(232, 78, 155, 0.3)'"
              >
                2nde
              </button>
              <button
                onclick=""
                style="
                  padding: 12px 20px;
                  font-size: 1rem;
                  font-weight: 600;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  background: linear-gradient(135deg, #e84e9b 0%, #ff6b9d 100%);
                  color: white;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(232, 78, 155, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(232, 78, 155, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(232, 78, 155, 0.3)'"
              >
                1ere
              </button>
              <button
                onclick=""
                style="
                  padding: 12px 20px;
                  font-size: 1rem;
                  font-weight: 600;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  background: linear-gradient(135deg, #e84e9b 0%, #ff6b9d 100%);
                  color: white;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(232, 78, 155, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(232, 78, 155, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(232, 78, 155, 0.3)'"
              >
                Terminale
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>Prise en main</h2>
        <h3
          style="
            margin: 0 0 20px 0;
            color: #333;
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
          "
        >
          Ce que nous savons :
        </h3>
        <ul
          style="
            margin: 20px 0;
            padding-left: 30px;
            color: #333;
            font-size: 1.1rem;
            line-height: 1.8;
          "
        >
          <li style="margin-bottom: 15px">
            L'ADN contient des informations il permet, par exemple, la synthèse
            d'insuline mais aussi le fait d'avoir 2 bras, 2 jambes ainsi qu'une
            colonne vertébrale.
          </li>
          <li style="margin-bottom: 15px">
            L'ADN est constitué de 4 éléments différents : les nucléotides A, T,
            C, G
          </li>
        </ul>

        <h3
          style="
            margin: 30px 0 20px 0;
            color: #333;
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
          "
        >
          Ce que nous cherchons :
        </h3>
        <p
          style="
            margin: 20px 0;
            color: green;
            font-size: 1.98rem;
            line-height: 1.8;
            text-align: center;
            font-weight: 500;
          "
        >
          Comment, avec seulement 4 constituants, l'ADN peut-il déterminer une
          aussi grande diversité de caractères ?
        </p>

        <h3
          style="
            margin: 30px 0 20px 0;
            color: #333;
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
          "
        >
          Pour répondre :
        </h3>
        <p
          style="
            margin: 20px 0;
            color: #333;
            font-size: 1.1rem;
            line-height: 1.8;
            text-align: center;
          "
        >
          Nous allons voir dans le détail comment l'ADN peut contenir des
          informations.
        </p>

        <p
          style="
            margin: 30px 0 20px 0;
            color: #333;
            font-size: 1.1rem;
            line-height: 1.8;
            text-align: center;
            font-weight: 500;
          "
        >
          2 contraintes pour les questions suivantes : 2 lettres différentes ne
          peuvent pas être codée de la même manière<br />
          Une fois un code attribué à une lettre il ne peut être changé pour le
          mot suivant.
        </p>

        <p
          style="
            margin: 30px 0 15px 0;
            color: #333;
            font-size: 1.1rem;
            line-height: 1.8;
            text-align: center;
          "
        >
          Pour gagner du temps sur la mise en page je peux directement répondre dans le formulaire :
        </p>
        <div
          style="
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 15px 0 30px 0;
            flex-wrap: wrap;
          "
        >
          <button
            onclick="window.open('https://www.dropbox.com/scl/fi/0iof5ncrdisucs2he5bql/TP-Enonc-Seconde.pdf?rlkey=ytiq7buu07wlq81eqr353cs7f&st=10wwmwn9&dl=0', '_blank')"
            style="
              padding: 12px 24px;
              font-size: 1rem;
              font-weight: 600;
              color: white;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              border: none;
              border-radius: 8px;
              cursor: pointer;
              transition: transform 0.2s, box-shadow 0.2s;
              box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            "
            onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(102, 126, 234, 0.4)'"
            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.3)'"
          >
            Enoncé 2nde
          </button>
          <button
            disabled
            style="
              padding: 12px 24px;
              font-size: 1rem;
              font-weight: 600;
              color: #999;
              background: #e0e0e0;
              border: none;
              border-radius: 8px;
              cursor: not-allowed;
              opacity: 0.6;
            "
          >
            Enoncé 1ere
          </button>
        </div>
      </div>

      <div class="section">
        <h3
          style="
            margin: 40px 0 20px 0;
            color: #333;
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
            background: linear-gradient(135deg, #e84e9b 0%, #ff6b9d 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
          "
        >
          Activité 1 : A l'aide des 4 nucléotides de l'ADN, serais-tu capable
          d'écrire...
        </h3>

        <p
          style="
            margin: 15px 0;
            color: #666;
            font-size: 1rem;
            text-align: center;
            font-style: italic;
          "
        >
          Cliquer sur les carrés roses pour changer les nucléotides
        </p>

        <div
          id="activity1-container"
          style="
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px auto;
            width: fit-content;
            max-width: 100%;
            box-sizing: border-box;
            overflow-x: hidden;
            min-width: 0;
          "
        >
          <div
            style="
              background: rgba(255, 255, 255, 0.8);
              border-radius: 12px;
              padding: 10px;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
              min-width: 0;
              max-width: 100%;
              box-sizing: border-box;
            "
          >
            <h4
              style="
                margin: 0 0 10px 0;
                color: #333;
                font-size: 1.3rem;
                font-weight: 600;
                text-align: center;
              "
            >
              Le mot papa ?
            </h4>
            <div
              style="
                display: flex;
                gap: 5px;
                justify-content: center;
                align-items: center;
              "
            >
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                data-word="papa"
                data-position="0"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                data-word="papa"
                data-position="1"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                data-word="papa"
                data-position="2"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                data-word="papa"
                data-position="3"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
            </div>
          </div>
          <div
            style="
              background: rgba(255, 255, 255, 0.8);
              border-radius: 12px;
              padding: 10px;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
              min-width: 0;
              max-width: 100%;
              box-sizing: border-box;
            "
          >
            <h4
              style="
                margin: 0 0 10px 0;
                color: #333;
                font-size: 1.3rem;
                font-weight: 600;
                text-align: center;
              "
            >
              Le mot maman ?
            </h4>
            <div
              style="
                display: flex;
                gap: 5px;
                justify-content: center;
                align-items: center;
              "
            >
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                data-word="maman"
                data-position="0"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                data-word="maman"
                data-position="1"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                data-word="maman"
                data-position="2"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                data-word="maman"
                data-position="3"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                data-word="maman"
                data-position="4"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
            </div>
          </div>
          <div
            style="
              background: rgba(255, 255, 255, 0.8);
              border-radius: 12px;
              padding: 10px;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
              min-width: 0;
              max-width: 100%;
              box-sizing: border-box;
            "
          >
            <h4
              style="
                margin: 0 0 10px 0;
                color: #333;
                font-size: 1.3rem;
                font-weight: 600;
                text-align: center;
              "
            >
              Le mot manip ?
            </h4>
            <div
              style="
                display: flex;
                gap: 5px;
                justify-content: center;
                align-items: center;
              "
            >
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                data-word="manip"
                data-position="0"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
              <div
                class="nucleotide-square"
                data-nucleotide="A"
                onclick="cycleNucleotide(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(255, 154, 158, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(255, 154, 158, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(255, 154, 158, 0.3)'"
              >
                A
              </div>
            </div>
          </div>
          <div
            id="code-input-window"
            style="
              background: rgba(255, 255, 255, 0.8);
              border-radius: 12px;
              padding: 10px;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
              margin: 20px 0;
              grid-column: 1 / -1;
              box-sizing: border-box;
              max-width: 100%;
              overflow-x: auto;
            "
          >
            <p
              style="
                margin: 0 0 15px 0;
                color: #333;
                font-size: 1.1rem;
                font-weight: 600;
                text-align: center;
              "
            >
              Note, au fur et à mesure, la correspondance que tu choisis entre les nucléotides (carrés à compléter) et les lettres codées par ces nucléotides.
            </p>
            <div
              style="
                display: flex;
                flex-wrap: wrap;
                gap: 15px;
                justify-content: center;
                align-items: center;
              "
            >
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1.1rem; font-weight: 600; color: #333"
                  >Lettre A =</span
                >
                <div
                  class="nucleotide-square-empty"
                  data-letter="A"
                  data-nucleotide=""
                  onclick="cycleNucleotide(this)"
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: transparent;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                    cursor: pointer;
                    transition: transform 0.2s ease, box-shadow 0.2s ease;
                  "
                  onmouseover="this.style.transform='translateY(-2px)'; this.style.borderColor='#999'"
                  onmouseout="this.style.transform='translateY(0)'; this.style.borderColor='#ccc'"
                ></div>
              </div>
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1.1rem; font-weight: 600; color: #333"
                  >Lettre P =</span
                >
                <div
                  class="nucleotide-square-empty"
                  data-letter="P"
                  data-nucleotide=""
                  onclick="cycleNucleotide(this)"
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: transparent;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                    cursor: pointer;
                    transition: transform 0.2s ease, box-shadow 0.2s ease;
                  "
                  onmouseover="this.style.transform='translateY(-2px)'; this.style.borderColor='#999'"
                  onmouseout="this.style.transform='translateY(0)'; this.style.borderColor='#ccc'"
                ></div>
              </div>
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1.1rem; font-weight: 600; color: #333"
                  >Lettre M =</span
                >
                <div
                  class="nucleotide-square-empty"
                  data-letter="M"
                  data-nucleotide=""
                  onclick="cycleNucleotide(this)"
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: transparent;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                    cursor: pointer;
                    transition: transform 0.2s ease, box-shadow 0.2s ease;
                  "
                  onmouseover="this.style.transform='translateY(-2px)'; this.style.borderColor='#999'"
                  onmouseout="this.style.transform='translateY(0)'; this.style.borderColor='#ccc'"
                ></div>
              </div>
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1.1rem; font-weight: 600; color: #333"
                  >Lettre N =</span
                >
                <div
                  class="nucleotide-square-empty"
                  data-letter="N"
                  data-nucleotide=""
                  onclick="cycleNucleotide(this)"
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: transparent;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                    cursor: pointer;
                    transition: transform 0.2s ease, box-shadow 0.2s ease;
                  "
                  onmouseover="this.style.transform='translateY(-2px)'; this.style.borderColor='#999'"
                  onmouseout="this.style.transform='translateY(0)'; this.style.borderColor='#ccc'"
                ></div>
              </div>
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1.1rem; font-weight: 600; color: #333"
                  >Lettre I =</span
                >
                <div style="display: flex; gap: 3px">
                  <div
                    class="nucleotide-square-empty"
                    data-letter="I"
                    data-position="0"
                    data-nucleotide=""
                    onclick="cycleNucleotide(this)"
                    style="
                      width: 45px;
                      height: 45px;
                      border-radius: 12px;
                      background: #f0f0f0;
                      border: 2px dashed #ccc;
                      color: transparent;
                      display: flex;
                      align-items: center;
                      justify-content: center;
                      font-size: 1.2rem;
                      font-weight: 700;
                      cursor: pointer;
                      transition: transform 0.2s ease, box-shadow 0.2s ease;
                    "
                    onmouseover="this.style.transform='translateY(-2px)'; this.style.borderColor='#999'"
                    onmouseout="this.style.transform='translateY(0)'; this.style.borderColor='#ccc'"
                  ></div>
                  <div
                    class="nucleotide-square-empty"
                    data-letter="I"
                    data-position="1"
                    data-nucleotide=""
                    onclick="cycleNucleotide(this)"
                    style="
                      width: 45px;
                      height: 45px;
                      border-radius: 12px;
                      background: #f0f0f0;
                      border: 2px dashed #ccc;
                      color: transparent;
                      display: flex;
                      align-items: center;
                      justify-content: center;
                      font-size: 1.2rem;
                      font-weight: 700;
                      cursor: pointer;
                      transition: transform 0.2s ease, box-shadow 0.2s ease;
                    "
                    onmouseover="this.style.transform='translateY(-2px)'; this.style.borderColor='#999'"
                    onmouseout="this.style.transform='translateY(0)'; this.style.borderColor='#ccc'"
                  ></div>
                </div>
              </div>
            </div>
            <div style="text-align: center; margin-top: 20px">
              <button
                onclick="validateActivity1()"
                style="
                  padding: 12px 30px;
                  font-size: 1.1rem;
                  font-weight: 600;
                  border: none;
                  border-radius: 8px;
                  cursor: pointer;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  color: white;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(102, 126, 234, 0.3)'"
              >
                ✓ Valider
              </button>
              <p
                id="validation-result"
                style="
                  margin: 15px 0 0 0;
                  color: #333;
                  font-size: 1rem;
                  font-weight: 500;
                "
              ></p>
            </div>
          </div>
        </div>
      </div>

      <div
        style="
          background: rgba(255, 255, 255, 0.8);
          border-radius: 12px;
          padding: 25px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
          margin: 30px 0;
        "
      >
        <p
          style="
            margin: 15px 0;
            color: #333;
            font-size: 1.1rem;
            line-height: 1.8;
          "
        >
          <strong>Q1)</strong> Recopie le code que tu as obtenu.
        </p>
        <p
          style="
            margin: 15px 0;
            color: #333;
            font-size: 1.1rem;
            line-height: 1.8;
          "
        >
          <strong>Q2)</strong> Quel problème s'est posé lorsque tu as eu à
          écrire le mot « manip » ?
        </p>
        <p
          style="
            margin: 15px 0;
            color: #333;
            font-size: 1.1rem;
            line-height: 1.8;
          "
        >
          <strong>Q3)</strong> Quelle a été la seule solution pour toi ?
        </p>
        <p
          style="
            margin: 15px 0;
            color: #333;
            font-size: 1.1rem;
            line-height: 1.8;
          "
        >
          <strong>Q4)</strong> Et si tu devais encoder les 26 lettres de
          l'alphabet à l'aide de seulement 4 nucléotides, comment ferais-tu ?
        </p>
      </div>

      <div class="section">
        <h3
          style="
            margin: 40px 0 20px 0;
            color: #333;
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
            background: linear-gradient(135deg, #e84e9b 0%, #ff6b9d 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
          "
        >
          Activité 2 : Distinguer information et code génétique
        </h3>

        <p
          style="
            margin: 20px 0;
            color: #333;
            font-size: 1.1rem;
            line-height: 1.8;
            text-align: center;
          "
        >
          De nombreuses personnes confondent l'information et le code génétique. Réalisons les tests suivants pour éclaircir cette confusion :
        </p>

        <div
          style="
            display: flex;
            flex-direction: column;
            gap: 25px;
            margin: 30px 0;
          "
        >
          <!-- Information génétique 1 -->
          <div
            style="
              background: rgba(255, 255, 255, 0.8);
              border-radius: 12px;
              padding: 20px;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            "
          >
            <p
              style="
                margin: 0 0 15px 0;
                color: #333;
                font-size: 1.1rem;
                line-height: 1.8;
                text-align: center;
              "
            >
              <strong><span style="background-color: #fff9c4; padding: 2px 4px; border-radius: 3px;">Information génétique 1 : ATAACG</span></strong> -
              <strong>Information génétique 1 décodée selon un code génétique 1 :</strong>
            </p>
            <div
              style="
                background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
                border-radius: 12px;
                padding: 15px;
                margin: 0 0 15px 0;
                text-align: center;
              "
            >
              <p
                style="
                  margin: 0 0 10px 0;
                  color: #333;
                  font-size: 1rem;
                  font-weight: 600;
                "
              >
                Code génétique 1 :
              </p>
              <div
                style="
                  display: flex;
                  flex-wrap: wrap;
                  gap: 15px;
                  justify-content: center;
                  align-items: center;
                "
              >
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1rem; font-weight: 600; color: #333"
                  >A=</span
                >
                <div
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: #333;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                  "
                >
                  S
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1rem; font-weight: 600; color: #333"
                  >T=</span
                >
                <div
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: #333;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                  "
                >
                  O
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1rem; font-weight: 600; color: #333"
                  >C=</span
                >
                <div
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: #333;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                  "
                >
                  V
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1rem; font-weight: 600; color: #333"
                  >G=</span
                >
                <div
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: #333;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                  "
                >
                  T
                </div>
              </div>
              </div>
            </div>
            <p
              style="
                margin: 15px 0 10px 0;
                color: #333;
                font-size: 1rem;
                font-weight: 600;
                text-align: center;
              "
            >
              Résultats 1 :
            </p>
            <div
              style="
                display: flex;
                gap: 8px;
                justify-content: center;
                align-items: center;
                flex-wrap: wrap;
              "
            >
              <div
                class="letter-square"
                data-letter=""
                data-position="0"
                data-info="1"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="1"
                data-info="1"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="2"
                data-info="1"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="3"
                data-info="1"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="4"
                data-info="1"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="5"
                data-info="1"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
            </div>
            <div style="text-align: center; margin-top: 20px">
              <button
                onclick="validateActivity2('1')"
                style="
                  background: linear-gradient(135deg, #51cf66 0%, #87e86b 100%);
                  color: white;
                  text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                    1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                    1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                    0 0 5px rgba(0, 0, 0, 0.5);
                  border: none;
                  padding: 12px 25px;
                  border-radius: 8px;
                  cursor: pointer;
                  font-size: 1.1rem;
                  font-weight: bold;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(81, 207, 102, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(81, 207, 102, 0.3)'"
              >
                ✓ Valider
              </button>
              <p
                id="validation-result-1"
                style="
                  margin: 15px 0 0 0;
                  color: #333;
                  font-size: 1rem;
                  font-weight: 500;
                "
              ></p>
            </div>
            </div>
          </div>

          <!-- Information génétique 2 -->
          <div
            style="
              background: rgba(255, 255, 255, 0.8);
              border-radius: 12px;
              padding: 20px;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            "
          >
            <p
              style="
                margin: 0 0 15px 0;
                color: #333;
                font-size: 1.1rem;
                line-height: 1.8;
                text-align: center;
              "
            >
              <strong><span style="background-color: #c8e6c9; padding: 2px 4px; border-radius: 3px;">Information génétique 2 : ACGATA</span></strong> -
              <strong>Information génétique 2 décodée selon le même code génétique 1:</strong>
            </p>
            <div
              style="
                background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
                border-radius: 12px;
                padding: 15px;
                margin: 0 0 15px 0;
                text-align: center;
              "
            >
              <p
                style="
                  margin: 0 0 10px 0;
                  color: #333;
                  font-size: 1rem;
                  font-weight: 600;
                "
              >
                Code génétique 1 :
              </p>
              <div
                style="
                  display: flex;
                  flex-wrap: wrap;
                  gap: 15px;
                  justify-content: center;
                  align-items: center;
                "
              >
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1rem; font-weight: 600; color: #333"
                  >A=</span
                >
                <div
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: #333;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                  "
                >
                  S
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1rem; font-weight: 600; color: #333"
                  >T=</span
                >
                <div
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: #333;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                  "
                >
                  O
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1rem; font-weight: 600; color: #333"
                  >C=</span
                >
                <div
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: #333;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                  "
                >
                  V
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1rem; font-weight: 600; color: #333"
                  >G=</span
                >
                <div
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: #333;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                  "
                >
                  T
                </div>
              </div>
              </div>
            </div>
            <p
              style="
                margin: 15px 0 10px 0;
                color: #333;
                font-size: 1rem;
                font-weight: 600;
                text-align: center;
              "
            >
              Résultats 2 :
            </p>
            <div
              style="
                display: flex;
                gap: 8px;
                justify-content: center;
                align-items: center;
                flex-wrap: wrap;
              "
            >
              <div
                class="letter-square"
                data-letter=""
                data-position="0"
                data-info="2"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="1"
                data-info="2"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="2"
                data-info="2"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="3"
                data-info="2"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="4"
                data-info="2"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="5"
                data-info="2"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
            </div>
            <div style="text-align: center; margin-top: 20px">
              <button
                onclick="validateActivity2('2')"
                style="
                  background: linear-gradient(135deg, #51cf66 0%, #87e86b 100%);
                  color: white;
                  text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                    1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                    1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                    0 0 5px rgba(0, 0, 0, 0.5);
                  border: none;
                  padding: 12px 25px;
                  border-radius: 8px;
                  cursor: pointer;
                  font-size: 1.1rem;
                  font-weight: bold;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(81, 207, 102, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(81, 207, 102, 0.3)'"
              >
                ✓ Valider
              </button>
              <p
                id="validation-result-2"
                style="
                  margin: 15px 0 0 0;
                  color: #333;
                  font-size: 1rem;
                  font-weight: 500;
                "
              ></p>
            </div>
            </div>
          

          <!-- Information génétique 2 avec code génétique 2 -->
          <div
            style="
              background: rgba(255, 255, 255, 0.8);
              border-radius: 12px;
              padding: 20px;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
              margin-top: 30px;
            "
          >
            <p
              style="
                margin: 0 0 15px 0;
                color: #333;
                font-size: 1.1rem;
                line-height: 1.8;
                text-align: center;
              "
            >
              <strong><span style="background-color: #c8e6c9; padding: 2px 4px; border-radius: 3px;">Information génétique 2 : ACGATA</span></strong> -
              <strong>Information génétique 2 décodée selon un code génétique 2 :</strong>
            </p>
            <div
              style="
                background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
                border-radius: 12px;
                padding: 15px;
                margin: 0 0 15px 0;
                text-align: center;
              "
            >
              <p
                style="
                  margin: 0 0 10px 0;
                  color: #333;
                  font-size: 1rem;
                  font-weight: 600;
                "
              >
                Code génétique 2 :
              </p>
              <div
                style="
                  display: flex;
                  flex-wrap: wrap;
                  gap: 15px;
                  justify-content: center;
                  align-items: center;
                "
              >
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1rem; font-weight: 600; color: #333"
                  >A=</span
                >
                <div
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: #333;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                  "
                >
                  L
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1rem; font-weight: 600; color: #333"
                  >T=</span
                >
                <div
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: #333;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                  "
                >
                  O
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1rem; font-weight: 600; color: #333"
                  >C=</span
                >
                <div
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: #333;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                  "
                >
                  W
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 5px">
                <span style="font-size: 1rem; font-weight: 600; color: #333"
                  >G=</span
                >
                <div
                  style="
                    width: 45px;
                    height: 45px;
                    border-radius: 12px;
                    background: #f0f0f0;
                    border: 2px dashed #ccc;
                    color: #333;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 1.2rem;
                    font-weight: 700;
                  "
                >
                  Z
                </div>
              </div>
              </div>
            </div>
            <p
              style="
                margin: 15px 0 10px 0;
                color: #333;
                font-size: 1rem;
                font-weight: 600;
                text-align: center;
              "
            >
              Résultats 3 :
            </p>
            <div
              style="
                display: flex;
                gap: 8px;
                justify-content: center;
                align-items: center;
                flex-wrap: wrap;
              "
            >
              <div
                class="letter-square"
                data-letter=""
                data-position="0"
                data-info="3"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="1"
                data-info="3"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="2"
                data-info="3"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="3"
                data-info="3"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="4"
                data-info="3"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
              <div
                class="letter-square"
                data-letter=""
                data-position="5"
                data-info="3"
                onclick="cycleLetter(this)"
                style="
                  width: 50px;
                  height: 50px;
                  border-radius: 12px;
                  background: #e0e0e0;
                  color: #333;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 1.3rem;
                  font-weight: 700;
                  cursor: pointer;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0, 0, 0, 0.2)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 0, 0, 0.1)'"
              ></div>
            </div>
            <div style="text-align: center; margin-top: 20px">
              <button
                onclick="validateActivity2('3')"
                style="
                  background: linear-gradient(135deg, #51cf66 0%, #87e86b 100%);
                  color: white;
                  text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                    1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                    1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                    0 0 5px rgba(0, 0, 0, 0.5);
                  border: none;
                  padding: 12px 25px;
                  border-radius: 8px;
                  cursor: pointer;
                  font-size: 1.1rem;
                  font-weight: bold;
                  transition: transform 0.2s ease, box-shadow 0.2s ease;
                "
                onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(81, 207, 102, 0.4)'"
                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(81, 207, 102, 0.3)'"
              >
                ✓ Valider
              </button>
              <p
                id="validation-result-3"
                style="
                  margin: 15px 0 0 0;
                  color: #333;
                  font-size: 1rem;
                  font-weight: 500;
                "
              ></p>
            </div>
            </div>
          </div>

          <div
            style="
              background: rgba(255, 255, 255, 0.8);
              border-radius: 12px;
              padding: 25px;
              box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
              margin: 30px 0;
            "
          >
            <p
              style="
                margin: 15px 0;
                color: #333;
                font-size: 1.1rem;
                line-height: 1.8;
              "
            >
              <strong>Q1)</strong> Compare tes résultats 1 et 2 pour expliquer en quoi
              consiste une information génétique.
            </p>
            <p
              style="
                margin: 15px 0;
                color: #333;
                font-size: 1.1rem;
                line-height: 1.8;
              "
            >
              <strong>Q2)</strong> Compare tes résultats obtenus en 2) et 3) pour une même
              information génétique mais avec 2 codes génétiques différents pour expliquer la
              différence entre une information génétique et un code génétique !
            </p>
            <p
              style="
                margin: 15px 0;
                color: #333;
                font-size: 1.1rem;
                line-height: 1.8;
              "
            >
              <strong>Q3)</strong> Dans l'expérience de transgenèse (<a href="https://www.canva.com/design/DAG8PqCZsx4/65sGfIci6KjlzDWKIhrujg/view?utm_content=DAG8PqCZsx4&utm_campaign=designshare&utm_medium=link2&utm_source=uniquelinks&utlId=hd3cb4c7f86" target="_blank" style="color: #667eea; text-decoration: underline;">voir prérequis</a>) il a été vu que de l'ADN humain, 
              le gène de l'insuline, introduit dans une bactérie, a permis de produire de l'insuline humaine chez cette bactérie.
              Selon toi, la bactérie et l'homme ont-ils le même code génétique ? Argumente ta réponse.
            </p>
            <p
              style="
                margin: 20px 0 15px 0;
                color: #333;
                font-size: 1.1rem;
                line-height: 1.8;
                padding: 15px;
                background: rgba(102, 126, 234, 0.1);
                border-radius: 8px;
                border-left: 4px solid #667eea;
              "
            >
              Les êtres vivants possèdent tous le même code génétique, autrement dit,
              le code génétique est universel. En revanche chaque être vivant, à
              l'exception des clones et des jumeaux, possède une information
              génétique unique.
            </p>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>Enquêtes</h2>
        <h3
          style="
            margin: 40px 0 20px 0;
            color: #333;
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
            background: linear-gradient(135deg, #e84e9b 0%, #ff6b9d 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
          "
        >
          Activité 3 : Décoder l'ADN selon un code génétique fictif
        </h3>
        <p style="text-align: center; margin: 15px 0; color: #333; font-size: 0.95rem; line-height: 1.6;">
          Téléchargez les séquences ci dessous puis ouvrez les dans <a href="#importDnaBtn" style="color: #667eea; text-decoration: underline; cursor: pointer;">la rubrique « Décodage »</a> à l'aide du bouton « Importer de l'ADN ».
        </p>
        <p style="text-align: center; margin: 15px 0; color: #333; font-size: 0.95rem; line-height: 1.6;">
          La séquence 4 est un peu spéciale, vous ne pourrez la télécharger qu'après avoir trouvé le code grâce aux autres séquences
        </p>
        <div
          style="
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 30px 0;
            flex-wrap: wrap;
          "
        >
          <button
            id="btn-seconde"
            onclick="window.open('https://www.dropbox.com/scl/fi/0iof5ncrdisucs2he5bql/TP-Enonc-Seconde.pdf?rlkey=ytiq7buu07wlq81eqr353cs7f&st=10wwmwn9&dl=0', '_blank')"
            style="
              padding: 12px 24px;
              font-size: 1rem;
              font-weight: 600;
              color: white;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              border: none;
              border-radius: 8px;
              cursor: pointer;
              transition: transform 0.2s, box-shadow 0.2s;
              box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            "
            onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(102, 126, 234, 0.4)'"
            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.3)'"
          >
            Enoncé 2nde
          </button>
          <button
            id="btn-premiere"
            disabled
            style="
              padding: 12px 24px;
              font-size: 1rem;
              font-weight: 600;
              color: #999;
              background: #e0e0e0;
              border: none;
              border-radius: 8px;
              cursor: not-allowed;
              opacity: 0.6;
            "
          >
            Enoncé 1ere
          </button>
          <button
            id="btn-sequences"
            onclick="window.open('https://www.dropbox.com/scl/fo/rsqqa7o0jm21282p4yryk/ANTODWD97yVv-Md8RD78XE4?rlkey=6uwelsggtn2394mze913gzpln&st=wwzem7ja&dl=0', '_blank')"
            style="
              padding: 12px 24px;
              font-size: 1rem;
              font-weight: 600;
              color: white;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              border: none;
              border-radius: 8px;
              cursor: pointer;
              transition: transform 0.2s, box-shadow 0.2s;
              box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            "
            onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(102, 126, 234, 0.4)'"
            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.3)'"
          >
            Séquences retrouvées
          </button>
          <button
            id="btn-sequence-cryptee"
            onclick="checkSequenceCode()"
            style="
              padding: 12px 24px;
              font-size: 1rem;
              font-weight: 600;
              color: white;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              border: none;
              border-radius: 8px;
              cursor: pointer;
              transition: transform 0.2s, box-shadow 0.2s;
              box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            "
            onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(102, 126, 234, 0.4)'"
            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.3)'"
          >
            Séquence 4 cryptée
          </button>
        </div>
      </div>

      <div class="section">
        <h2>
          Encodage - Transforme une phrase ou un dessin en séquence ADN !
        </h2>
        <p
          style="
            margin: 20px 0 15px 0;
            color: #333;
            font-size: 1.1rem;
            line-height: 1.8;
            padding: 15px;
            background: rgba(255, 183, 77, 0.1);
            border-radius: 8px;
            border-left: 4px solid #ff9800;
          "
        >
          Si tu confonds information et code génétique mais que tu as envie de comprendre ce que tu vas faire, il peut être intéressant de réaliser au préalable 
          les activité 1 et 2. Si les notions d'information génétique et de code génétique n'ont plus de secrets pour toi il est temps de tester différents 
          codes génétiques fictifs et de s'amuser à enregistrer ou lire des informations secrètes dans de l'ADN !!!
        </p>
        <p
          style="
            margin-bottom: 15px;
            color: #333;
            font-size: 1.76rem;
            font-weight: 500;
            line-height: 1.6;
            text-align: center;
          "
        >
          Ce que je souhaite encoder sous forme d'une séquence ADN :
        </p>
        <textarea
          id="textInput"
          placeholder="Ecris, colle ou importe un texte que tu souhaites encoder dans de l'ADN puis clique sur le bouton Texte ou Texte à trous selon le résultat souhaité. Anecdote : il est aujourd'hui possible d'encapsuler l'ADN dans des nanobilles de silice. En les stockant dans des capsules en acier inoxydable, on estime pouvoir obtenir une durée de vie de 50.000 ans. Source : Académie des technologies - Wikipedia"
        ></textarea>
        <div
          style="
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
          "
        >
          <button
            id="encodeTextBtn"
            onclick="encodeText()"
            style="
              background-image: url('https://www.dropbox.com/scl/fi/1covqkpg610vvsmnpvhgd/Bouton-Encoder.png?rlkey=wkbzvci3ac9fp7vg4ghfjb7cw&st=zgk9jkfz&raw=1');
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              color: #fff;
              text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                0 0 5px rgba(0, 0, 0, 0.5);
              border: 1px solid rgba(255, 255, 255, 0.3);
            "
          >
            Texte
          </button>
          <button
            id="trouModeBtn"
            onclick="toggleTrouMode()"
            style="
              background-image: url('https://www.dropbox.com/scl/fi/x94k24wjgsy5qx80vzn76/Bouton-Trous.png?rlkey=08oskttv9edx7tks6e3fruohh&st=wt2nbmka&raw=1');
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              color: #fff;
              text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                0 0 5px rgba(0, 0, 0, 0.5);
              border: 1px solid rgba(255, 255, 255, 0.3);
            "
          >
            Texte à trous
          </button>
        </div>
        <div
          style="
            margin-top: 20px;
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
          "
        >
          <span
            style="
              color: #333;
              font-size: 1.6rem;
              font-weight: 500;
              text-align: center;
              display: block;
              width: 100%;
            "
          >
            Je préfère dessiner et encoder un dessin en séquence ADN :
          </span>
          <div
            style="
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 10px;
              flex-wrap: wrap;
            "
          >
            <button
              onclick="openPixelArtEditor()"
              id="pixelArtBtn"
              style="
                position: relative;
                overflow: hidden;
                border: 2px solid #333;
              "
            >
              <span
                style="
                  position: relative;
                  z-index: 2;
                  color: white;
                  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
                  font-weight: bold;
                "
                >Pixel art</span
              >
              <div
                id="pixelArtMosaic"
                style="
                  position: absolute;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 100%;
                  z-index: 1;
                  display: grid;
                  grid-template-columns: repeat(8, 1fr);
                  grid-template-rows: repeat(4, 1fr);
                  gap: 1px;
                  background: #9b59b6;
                "
              ></div>
            </button>
            <button
              id="exportBtn"
              onclick="openExportModal()"
              style="
                background-image: url('https://www.dropbox.com/scl/fi/914wi5wvt59l7dy4j7onz/Bouton-sauvegarder.png?rlkey=g1xvkbw2orc5dxthgo5wkofpf&st=jy6l5f3n&raw=1');
                background-size: cover;
                background-position: center;
                background-repeat: no-repeat;
                color: #fff;
                text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                  1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                  1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                  0 0 5px rgba(0, 0, 0, 0.5);
                border: 1px solid rgba(255, 255, 255, 0.3);
                display: none;
              "
            >
              Télécharger
            </button>
            <button
              id="copyBtn"
              onclick="copyDNAWithTrous()"
              style="background: #51cf66; display: none"
            >
              Copier la séquence
            </button>
          </div>
        </div>
        <p
          id="dnaOutputLabel"
          style="
            display: none;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #333;
            font-size: 1.6rem;
            font-weight: 500;
            line-height: 1.6;
            text-align: center;
          "
        >
          Voici une séquence ADN contenant ton texte/dessin, tu peux la
          télécharger :
        </p>
        <div class="output" id="dnaOutput"></div>
      </div>

      <div class="section">
        <h2>Décodage - Que cache cette séquence ADN ?</h2>
        <div style="margin-bottom: 15px; text-align: center">
          <button
            id="importDnaBtn"
            onclick="openImportModal()"
            style="
              background-image: url('https://www.dropbox.com/scl/fi/cmxmx7gp6ipkgbnkwo7ul/Bouton-ADN.png?rlkey=de5pm9v22723web0s3v5ykp38&st=4s2y7aj8&raw=1');
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              color: #fff;
              text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                0 0 5px rgba(0, 0, 0, 0.5);
              border: 1px solid rgba(255, 255, 255, 0.3);
              margin-right: 10px;
            "
          >
            Importer de l'ADN
          </button>
          <input
            type="file"
            id="ediFileInput"
            accept=".edi"
            style="display: none"
            onchange="importEDIFile(event)"
          />
          <input
            type="file"
            id="fastaFileInput"
            accept=".fasta,.fa,.fas"
            style="display: none"
            onchange="importFASTAFile(event)"
          />
          <button
            onclick="loadTestTextSequence()"
            style="
              background-image: url('https://www.dropbox.com/scl/fi/evqozc3atpj7k98f51fnt/Bouton-Texte.png?rlkey=g3bm34kfxz95fj4haxsitgt1s&st=31grtgcr&raw=1');
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              color: #fff;
              text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                0 0 5px rgba(0, 0, 0, 0.5);
              border: 1px solid rgba(255, 255, 255, 0.3);
            "
          >
            Tester texte 📖
          </button>
          <button
            onclick="loadTestImageSequence()"
            style="
              background-image: url('https://www.dropbox.com/scl/fi/l1dpigpe88rl2pyg3f07e/Bouton-Image.png?rlkey=ng5n1wt2tkw3cbb07r82k9ope&st=c8gkzhsn&raw=1');
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              color: #fff;
              text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                0 0 5px rgba(0, 0, 0, 0.5);
              border: 1px solid rgba(255, 255, 255, 0.3);
            "
          >
            Tester image ⛰️
          </button>
          <button
            onclick="openScenarioVideo()"
            style="
              background-image: url('https://www.dropbox.com/scl/fi/aaajr0x4rr041t2w1aq0c/Bouton-Sc-nario.png?rlkey=sjlonljrq5xk8yti2fkbdr50l&st=r8ozrln6&raw=1');
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              color: #fff;
              text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                0 0 5px rgba(0, 0, 0, 0.5);
              border: 1px solid rgba(255, 255, 255, 0.3);
              margin-left: 10px;
            "
          >
            Scénario
          </button>
          <button
            onclick="loadJoyeuseFeteSequence()"
            style="
              position: relative;
              overflow: hidden;
              color: #fff;
              text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                0 0 5px rgba(0, 0, 0, 0.5);
              border: 1px solid rgba(255, 255, 255, 0.3);
              margin-left: 10px;
              padding: 12px 20px;
              font-size: 1rem;
              font-weight: 600;
              border-radius: 8px;
              cursor: pointer;
              z-index: 1;
            "
          >
            <video
              autoplay
              loop
              muted
              playsinline
              style="
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                object-fit: cover;
                z-index: -1;
              "
            >
              <source
                src="https://www.dropbox.com/scl/fi/ujopnc8afy5d6rjfonusz/Bouton-Noel.mp4?rlkey=b2sbepnvac3vb7aj3p9rpx1vc&st=m2pxi211&dl=1"
                type="video/mp4"
              />
            </video>
            Joyeuses fêtes !!! 🎉
          </button>
        </div>
        <div
          id="dnaInput"
          contenteditable="true"
          placeholder="Ecris ou colle ici une séquence d'ADN. L'ADN contient des informations codées sous forme de séquence de nucléotides. Peut-être qu'un message est caché dans la séquence que tu vas étudier ?"
        ></div>
        <div id="contextMenu" style="display: none">
          <div class="menu-item" data-action="substitution">Substitution</div>
          <div class="menu-item" data-action="addition">Addition</div>
          <div class="menu-item" data-action="suppression">Délétion</div>
        </div>
        <div
          style="
            text-align: center;
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
          "
        >
          <button
            id="mutationBtn"
            onclick="toggleMutationMode()"
            style="background: #ff6b6b"
          >
            Mutation
          </button>
          <button id="decodeBtn" onclick="decodeDNA()">Décoder</button>
          <button
            id="downloadDecodeBtn"
            onclick="openDecodeExportModal()"
            style="
              background-image: url('https://www.dropbox.com/scl/fi/914wi5wvt59l7dy4j7onz/Bouton-sauvegarder.png?rlkey=g1xvkbw2orc5dxthgo5wkofpf&st=jy6l5f3n&raw=1');
              background-size: cover;
              background-position: center;
              background-repeat: no-repeat;
              color: #fff;
              text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9),
                1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9),
                1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8),
                0 0 5px rgba(0, 0, 0, 0.5);
              border: 1px solid rgba(255, 255, 255, 0.3);
            "
          >
            Télécharger
          </button>
        </div>
        <p
          style="
            margin-top: 15px;
            margin-bottom: 10px;
            color: #666;
            font-style: italic;
            text-align: center;
          "
        >
          Dans le cas où certains mots s'affichent sous forme de séquence de
          nucléotides, double cliquez dessus pour les déchiffrer.
        </p>
        <p
          style="
            margin-top: 10px;
            margin-bottom: 10px;
            color: #666;
            font-style: italic;
            text-align: center;
          "
        >
          Concernant les mutations : 1) Les nucléotides sur fond noir indiquent une addition 2) Les coches rouges indiquent une délétion 3) Les nucléotides sur fond mauve indiquent une substitution
        </p>
        <div class="output" id="output"></div>
      </div>

      <div class="section">
        <h2>Code génétique fictif - Triplet de nucléotides / texte</h2>
        <div style="margin-bottom: 20px; text-align: center">
          <button
            onclick="exportGeneticCode()"
            style="margin-right: 10px; background: #51cf66"
          >
            Exporter CSV
          </button>
          <label for="csvFileInput" style="display: inline-block">
            <button
              onclick="document.getElementById('csvFileInput').click()"
              style="background: #4dabf7"
            >
              Importer CSV
            </button>
            <input
              type="file"
              id="csvFileInput"
              accept=".csv"
              style="display: none"
              onchange="importGeneticCode(event)"
            />
          </label>
        </div>
        <p
          style="
            margin-top: 10px;
            margin-bottom: 15px;
            color: #666;
            font-style: italic;
            text-align: center;
            font-size: 0.9rem;
          "
        >
          L'import CSV permet à chaque utilisateur de personnaliser
          temporairement le code génétique pour sa session.
        </p>
        <table>
          <thead>
            <tr>
              <th>Codon</th>
              <th>Symbole</th>
              <th>Codon</th>
              <th>Symbole</th>
              <th>Codon</th>
              <th>Symbole</th>
              <th>Codon</th>
              <th>Symbole</th>
            </tr>
          </thead>
          <tbody id="codeTable"></tbody>
        </table>
      </div>
    </div>

    <!-- Fenêtre modale pour le pixel art -->
    <div
      id="pixelArtModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1001;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 20px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 95%;
          max-height: 95vh;
          overflow-y: auto;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          id="pixelArtModalHeader"
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
          "
        >
          <h2 style="margin: 0; color: #667eea; flex: 1; min-width: 200px;">
            Éditeur Pixel Art : Enregistre ton dessin dans l'ADN !<br />
            Chaque pixel correspond à un triplet de nucléotides.
          </h2>
          <div id="pixelArtModalButtons" style="display: flex; gap: 10px; flex-shrink: 0;">
            <button
              id="savePixelArtBtn"
              onclick="savePixelArt()"
              style="
                background: #51cf66;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 1.2rem;
                touch-action: manipulation;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
              "
            >
              💾 Enregistrer dans l'ADN
            </button>
            <button
              id="closePixelArtModal"
              style="
                background: #ff6b6b;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 1.2rem;
                touch-action: manipulation;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
              "
            >
              ✕ Fermer
            </button>
          </div>
        </div>
        <div id="pixelArtContent"></div>
      </div>
    </div>

    <!-- Fenêtre modale pour choisir le nom de fichier et le répertoire -->
    <div
      id="saveFileModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1003;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 100px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 500px;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
          "
        >
          <h3 style="margin: 0; color: #667eea">Enregistrer le fichier</h3>
          <button
            id="closeSaveFileModal"
            style="
              background: #ff6b6b;
              color: white;
              border: none;
              padding: 8px 16px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 1rem;
            "
          >
            ✕
          </button>
        </div>
        <div style="margin-bottom: 20px">
          <label
            for="fileNameInput"
            style="
              display: block;
              margin-bottom: 8px;
              font-weight: bold;
              color: #333;
            "
          >
            Nom du fichier :
          </label>
          <input
            type="text"
            id="fileNameInput"
            value="sequence_encodée"
            style="
              width: 100%;
              padding: 10px;
              border: 2px solid #ddd;
              border-radius: 6px;
              font-size: 1rem;
              box-sizing: border-box;
            "
          />
          <p
            id="fileExtensionInfo"
            style="margin: 5px 0 15px 0; color: #666; font-size: 0.9rem"
          >
            Extension : .fasta
          </p>
          <button
            id="chooseDirectoryBtn"
            onclick="chooseDirectory()"
            style="
              width: 100%;
              padding: 12px;
              margin-bottom: 10px;
              background: #4dabf7;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 1rem;
              font-weight: bold;
            "
          >
            📁 Choisir le répertoire
          </button>
          <p style="margin: 5px 0 15px 0; color: #666; font-size: 0.9rem">
            <span id="directoryInfo"
              >Le fichier sera téléchargé dans le répertoire par défaut de votre
              navigateur.</span
            >
          </p>
          <div style="display: flex; gap: 10px; margin-top: 20px">
            <button
              id="confirmSaveBtn"
              onclick="confirmSaveFile()"
              style="
                flex: 1;
                padding: 12px;
                background: #51cf66;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-size: 1rem;
                font-weight: bold;
              "
            >
              💾 Enregistrer
            </button>
            <button
              onclick="closeSaveFileModal()"
              style="
                flex: 1;
                padding: 12px;
                background: #ff6b6b;
                color: white;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-size: 1rem;
                font-weight: bold;
              "
            >
              Annuler
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Fenêtre modale pour choisir la taille -->
    <div
      id="sizeModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1002;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 100px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 400px;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
          "
        >
          <h3 style="margin: 0; color: #667eea" id="sizeModalTitle">
            Choisir la taille
          </h3>
          <button
            id="closeSizeModal"
            style="
              background: #ff6b6b;
              color: white;
              border: none;
              padding: 8px 16px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 1rem;
            "
          >
            ✕
          </button>
        </div>
        <div
          id="sizeModalContent"
          style="
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
          "
        ></div>
      </div>
    </div>

    <!-- Fenêtre modale pour choisir le format d'import -->
    <div
      id="importModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1002;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 50px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 500px;
          max-height: 80vh;
          overflow-y: auto;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
          "
        >
          <h3 style="margin: 0; color: #667eea">Choisir le format d'import</h3>
          <button
            id="closeImportModal"
            onclick="closeImportModal()"
            style="
              background: #ff6b6b;
              color: white;
              border: none;
              padding: 8px 16px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 1rem;
            "
          >
            ✕
          </button>
        </div>
        <div style="margin-bottom: 20px">
          <button
            onclick="openImportFormat('edi')"
            style="
              width: 100%;
              padding: 15px;
              margin-bottom: 10px;
              background: #4dabf7;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 1.1rem;
              font-weight: bold;
            "
          >
            📄 Format .edi
          </button>
          <p style="margin: 5px 0 15px 0; color: #666; font-size: 0.9rem">
            Format simple : une seule ligne de séquence ADN sans en-tête. Idéal
            pour les séquences courtes.
          </p>
          <button
            onclick="openImportFormat('fasta')"
            style="
              width: 100%;
              padding: 15px;
              margin-bottom: 10px;
              background: #4dabf7;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 1.1rem;
              font-weight: bold;
            "
          >
            🧬 Format .fasta
          </button>
          <p style="margin: 5px 0 0 0; color: #666; font-size: 0.9rem">
            Format standard en bioinformatique : commence par un en-tête (ligne
            commençant par ">") suivi de la séquence ADN sur une ou plusieurs
            lignes. Plus lisible pour les longues séquences.
          </p>
        </div>
      </div>
    </div>

    <!-- Fenêtre modale pour choisir le format d'export -->
    <div
      id="exportModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1002;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 100px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 500px;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
          "
        >
          <h3 style="margin: 0; color: #667eea">Choisir le format d'export</h3>
          <button
            id="closeExportModal"
            style="
              background: #ff6b6b;
              color: white;
              border: none;
              padding: 8px 16px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 1rem;
            "
          >
            ✕
          </button>
        </div>
        <div style="margin-bottom: 20px">
          <button
            onclick="openExportFormat('edi')"
            style="
              width: 100%;
              padding: 15px;
              margin-bottom: 10px;
              background: #ffa94d;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 1.1rem;
              font-weight: bold;
            "
          >
            📄 Format .edi
          </button>
          <p style="margin: 5px 0 15px 0; color: #666; font-size: 0.9rem">
            Format simple : une seule ligne de séquence ADN sans en-tête. Idéal
            pour les séquences courtes.
          </p>
          <button
            onclick="openExportFormat('fasta')"
            style="
              width: 100%;
              padding: 15px;
              margin-bottom: 10px;
              background: #ffa94d;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 1.1rem;
              font-weight: bold;
            "
          >
            🧬 Format .fasta
          </button>
          <p style="margin: 5px 0 0 0; color: #666; font-size: 0.9rem">
            Format standard en bioinformatique : commence par un en-tête (ligne
            commençant par ">") suivi de la séquence ADN sur une ou plusieurs
            lignes. Plus lisible pour les longues séquences.
          </p>
        </div>
      </div>
    </div>

    <!-- Fenêtre modale pour choisir le format d'export du décodage -->
    <div
      id="decodeExportModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1002;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 100px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 500px;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
          "
        >
          <h3 style="margin: 0; color: #667eea">Choisir le format d'export</h3>
          <button
            id="closeDecodeExportModal"
            onclick="closeDecodeExportModal()"
            style="
              background: #ff6b6b;
              color: white;
              border: none;
              padding: 8px 16px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 1rem;
            "
          >
            ✕
          </button>
        </div>
        <div style="margin-bottom: 20px">
          <button
            onclick="exportDecodeEDIFile()"
            style="
              width: 100%;
              padding: 15px;
              margin-bottom: 10px;
              background: #ffa94d;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 1.1rem;
              font-weight: bold;
            "
          >
            📄 Format .edi
          </button>
          <p style="margin: 5px 0 15px 0; color: #666; font-size: 0.9rem">
            Format simple : une seule ligne de séquence ADN sans en-tête. Les mutations sont conservées.
          </p>
          <button
            onclick="exportDecodeFASTAFile()"
            style="
              width: 100%;
              padding: 15px;
              margin-bottom: 10px;
              background: #ffa94d;
              color: white;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 1.1rem;
              font-weight: bold;
            "
          >
            🧬 Format .fasta
          </button>
          <p style="margin: 5px 0 0 0; color: #666; font-size: 0.9rem">
            Format standard en bioinformatique : commence par un en-tête (ligne
            commençant par ">") suivi de la séquence ADN sur une ou plusieurs
            lignes. Les mutations sont conservées dans les métadonnées.
          </p>
        </div>
      </div>
    </div>

    <!-- Fenêtre modale pour le décodage interactif -->
    <div
      id="decodeModal"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        overflow-y: auto;
      "
    >
      <div
        style="
          background: white;
          margin: 50px auto;
          padding: 30px;
          border-radius: 12px;
          max-width: 90%;
          max-height: 90vh;
          overflow-y: auto;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        "
      >
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
          "
        >
          <h2 style="margin: 0; color: #667eea">Décodage interactif</h2>
          <button
            id="closeModal"
            style="
              background: #ff6b6b;
              color: white;
              border: none;
              padding: 10px 20px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 1.2rem;
            "
          >
            ✕ Fermer
          </button>
        </div>
        <div id="modalContent"></div>
      </div>
    </div>

    <script>
      // Fonction de validation pour l'activité 1
      function validateActivity1() {
        // Récupérer les séquences des mots (chaque carré = 1 nucléotide)
        const getSequence = (word) => {
          const squares = document.querySelectorAll(
            `.nucleotide-square[data-word="${word}"]`
          );
          return Array.from(squares)
            .sort((a, b) => parseInt(a.dataset.position || 0) - parseInt(b.dataset.position || 0))
            .map((sq) => sq.getAttribute("data-nucleotide") || "")
            .join("");
        };

        const papaSeq = getSequence("papa"); // 4 nucléotides (indices 0,1,2,3)
        const mamanSeq = getSequence("maman"); // 5 nucléotides (indices 0,1,2,3,4)
        const manipSeq = getSequence("manip"); // 6 nucléotides (indices 0,1,2,3,4,5)

        // Récupérer les codes saisis
        const getCode = (letter) => {
          if (letter === "I") {
            // Pour I, il y a 2 carrés
            const squares = document.querySelectorAll(
              `.nucleotide-square-empty[data-letter="I"]`
            );
            const codes = Array.from(squares)
              .sort((a, b) => parseInt(a.dataset.position || 0) - parseInt(b.dataset.position || 0))
              .map((sq) => {
                const nuc = sq.getAttribute("data-nucleotide");
                return nuc && nuc !== "" ? nuc : null;
              })
              .filter(nuc => nuc !== null);
            return codes.length === 2 ? codes.join("") : "";
          } else {
            // Pour P, M, A, N : 1 seul carré
            const square = document.querySelector(
              `.nucleotide-square-empty[data-letter="${letter}"]`
            );
            if (!square) return "";
            const nuc = square.getAttribute("data-nucleotide");
            return nuc && nuc !== "" ? nuc : "";
          }
        };

        const codeA = getCode("A"); // 1 nucléotide
        const codeI = getCode("I"); // 2 nucléotides
        const codeM = getCode("M"); // 1 nucléotide
        const codeN = getCode("N"); // 1 nucléotide
        const codeP = getCode("P"); // 1 nucléotide

        const resultEl = document.getElementById("validation-result");

        // Vérifier que tous les codes sont remplis
        if (!codeA || codeA.length !== 1 || !codeI || codeI.length !== 2 || !codeM || codeM.length !== 1 || !codeN || codeN.length !== 1 || !codeP || codeP.length !== 1) {
          resultEl.textContent =
            "⚠ Veuillez remplir tous les codes (A, I avec 2 nucléotides, M, N, P) avant de valider.";
          resultEl.style.color = "#ffa726";
          return;
        }

        // Contrainte 2 : Les codes doivent être différents pour P, M, A, N
        const codes = [codeP, codeM, codeA, codeN];
        const uniqueCodes = new Set(codes);
        if (uniqueCodes.size !== codes.length) {
          resultEl.textContent =
            "✗ Les codes pour P, M, A et N doivent être différents.";
          resultEl.style.color = "#f5576c";
          return;
        }

        // Vérifier les correspondances selon les spécifications
        let isValid = true;
        let errors = [];

        // A : 2e et 4e position de papa (indices 1 et 3), 2e et 4e position de maman (indices 1 et 3), 2e position de manip (indice 1)
        if (papaSeq.length >= 4) {
          if (papaSeq[1] !== codeA) {
            isValid = false;
            errors.push("A dans 'papa' position 2");
          }
          if (papaSeq[3] !== codeA) {
            isValid = false;
            errors.push("A dans 'papa' position 4");
          }
        }
        if (mamanSeq.length >= 4) {
          if (mamanSeq[1] !== codeA) {
            isValid = false;
            errors.push("A dans 'maman' position 2");
          }
          if (mamanSeq[3] !== codeA) {
            isValid = false;
            errors.push("A dans 'maman' position 4");
          }
        }
        if (manipSeq.length >= 2) {
          if (manipSeq[1] !== codeA) {
            isValid = false;
            errors.push("A dans 'manip' position 2");
          }
        }

        // P : 1ère et 3e position de papa (indices 0 et 2), 6e position de manip (indice 5)
        if (papaSeq.length >= 3) {
          if (papaSeq[0] !== codeP) {
            isValid = false;
            errors.push("P dans 'papa' position 1");
          }
          if (papaSeq[2] !== codeP) {
            isValid = false;
            errors.push("P dans 'papa' position 3");
          }
        }
        if (manipSeq.length >= 6) {
          if (manipSeq[5] !== codeP) {
            isValid = false;
            errors.push("P dans 'manip' position 6");
          }
        }

        // M : 1ère et 3e position de maman (indices 0 et 2)
        if (mamanSeq.length >= 3) {
          if (mamanSeq[0] !== codeM) {
            isValid = false;
            errors.push("M dans 'maman' position 1");
          }
          if (mamanSeq[2] !== codeM) {
            isValid = false;
            errors.push("M dans 'maman' position 3");
          }
        }

        // N : 5e position de maman (indice 4), 3e position de manip (indice 2)
        if (mamanSeq.length >= 5) {
          if (mamanSeq[4] !== codeN) {
            isValid = false;
            errors.push("N dans 'maman' position 5");
          }
        }
        if (manipSeq.length >= 3) {
          if (manipSeq[2] !== codeN) {
            isValid = false;
            errors.push("N dans 'manip' position 3");
          }
        }

        // I : 4e et 5e position de manip (indices 3 et 4) - vérifier que le code I correspond bien aux 4e et 5e lettres
        if (manipSeq.length >= 5) {
          const iSeq = manipSeq[3] + manipSeq[4]; // 4e et 5e lettres de manip
          if (iSeq !== codeI) {
            isValid = false;
            errors.push("I dans 'manip' positions 4-5");
          }
        } else if (manipSeq.length < 5) {
          isValid = false;
          errors.push("La séquence 'manip' doit avoir au moins 5 nucléotides pour vérifier I");
        }

        // Modifier le style de la fenêtre "code-input-window" au lieu d'afficher un message
        const codeInputWindow = document.getElementById("code-input-window");
        if (codeInputWindow) {
          if (isValid) {
            // Vert pâle pour succès
            codeInputWindow.style.background = "rgba(200, 255, 200, 0.9)";
            codeInputWindow.style.border = "2px solid #51cf66";
          } else {
            // Rose pâle pour échec
            codeInputWindow.style.background = "rgba(255, 200, 200, 0.9)";
            codeInputWindow.style.border = "2px solid #f5576c";
          }
        }
        
        // Afficher le message de résultat
        if (resultEl) {
          if (isValid) {
            resultEl.textContent = "✓ Bravo, tu viens de créer ton 1er code génétique fictif !";
            resultEl.style.color = "#51cf66";
          } else {
            resultEl.textContent = "✗ " + (errors.length > 0 ? errors.join(", ") : "Erreur de validation");
            resultEl.style.color = "#f5576c";
          }
        }
      }

      // Fonction pour faire tourner les nucléotides A -> T -> C -> G -> A
      function cycleNucleotide(element) {
        const nucleotides = ["A", "T", "C", "G"];
        const colors = {
          A: "linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%)",
          T: "linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)",
          C: "linear-gradient(135deg, #d4fc79 0%, #96e6a1 100%)",
          G: "linear-gradient(135deg, #fff9c4 0%, #ffeaa7 100%)",
        };
        const shadows = {
          A: "0 2px 8px rgba(255, 154, 158, 0.3)",
          T: "0 2px 8px rgba(168, 237, 234, 0.3)",
          C: "0 2px 8px rgba(212, 252, 121, 0.3)",
          G: "0 2px 8px rgba(255, 249, 196, 0.3)",
        };

        const currentNucleotide = element.getAttribute("data-nucleotide") || "";
        let currentIndex = -1;
        
        if (currentNucleotide === "") {
          // Si vide, commencer par A
          currentIndex = -1;
        } else {
          currentIndex = nucleotides.indexOf(currentNucleotide);
        }
        
        const nextIndex = (currentIndex + 1) % nucleotides.length;
        const nextNucleotide = nucleotides[nextIndex];

        element.setAttribute("data-nucleotide", nextNucleotide);
        element.textContent = nextNucleotide;
        element.style.background = colors[nextNucleotide];
        element.style.boxShadow = shadows[nextNucleotide];
        
        // Si c'est un carré vide, enlever le style de bordure en pointillés
        if (element.classList.contains("nucleotide-square-empty")) {
          element.style.border = "none";
          element.style.color = "#333";
        }
      }

      // Fonction pour faire défiler les lettres A, M, N, P (sans changement de couleur)
      function cycleLetter(element) {
        // Déterminer les lettres disponibles selon la fenêtre (data-info)
        const infoNumber = element.getAttribute("data-info");
        let letters;
        if (infoNumber === "1" || infoNumber === "2") {
          // Fenêtres 1 et 2 : S, O, V, T
          letters = ["", "S", "O", "V", "T"];
        } else if (infoNumber === "3") {
          // Fenêtre 3 : L, O, W, Z
          letters = ["", "L", "O", "W", "Z"];
        } else {
          // Par défaut (ne devrait pas arriver)
          letters = ["", "A", "M", "N", "P"];
        }

        const currentLetter = element.getAttribute("data-letter") || "";
        const currentIndex = letters.indexOf(currentLetter);
        const nextIndex = (currentIndex + 1) % letters.length;
        const nextLetter = letters[nextIndex];

        element.setAttribute("data-letter", nextLetter);
        element.textContent = nextLetter;
        // Garder la même couleur grise pour tous
        element.style.background = "#e0e0e0";
        element.style.color = "#333";
        element.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.1)";
      }

      // Fonction de validation pour l'activité 2
      function validateActivity2(infoNumber) {
        const squares = document.querySelectorAll(
          `.letter-square[data-info="${infoNumber}"]`
        );
        const sequence = Array.from(squares)
          .sort((a, b) => parseInt(a.dataset.position) - parseInt(b.dataset.position))
          .map((sq) => sq.getAttribute("data-letter") || "")
          .join("");

        const expectedSequences = {
          1: "SOSSVT",
          2: "SVTSOS",
          3: "LWZLOL",
        };

        const expected = expectedSequences[infoNumber];
        
        // Trouver la fenêtre parente (la div qui contient les carrés)
        const firstSquare = squares[0];
        if (!firstSquare) {
          console.error(`Aucun carré trouvé pour la fenêtre ${infoNumber}`);
          return;
        }
        
        // Remonter jusqu'à la div de la fenêtre (celle qui contient directement les carrés)
        // Structure: div fenêtre > div flex > carrés
        let windowDiv = firstSquare.parentElement; // div flex avec les carrés
        if (windowDiv) {
          windowDiv = windowDiv.parentElement; // div fenêtre
        }

        if (windowDiv) {
          if (sequence === expected) {
            // Vert pâle pour succès
            windowDiv.style.background = "rgba(200, 255, 200, 0.9)";
            windowDiv.style.border = "2px solid #51cf66";
          } else {
            // Rose pâle pour échec
            windowDiv.style.background = "rgba(255, 200, 200, 0.9)";
            windowDiv.style.border = "2px solid #f5576c";
          }
        }
        
        // Masquer le message de résultat s'il existe
        const resultEl = document.getElementById(`validation-result-${infoNumber}`);
        if (resultEl) {
          resultEl.textContent = "";
        }
      }

      // Fonction pour vérifier le code de la séquence cryptée
      function checkSequenceCode() {
        // Calculer la valeur attendue sans la mettre en clair
        const expectedValue = parseInt("5" + "1");
        const userInput = prompt("Veuillez entrer le code d'accès que vous avez trouvé à l'aide des séquences ADN 2 et 3 :");
        
        if (userInput === null) {
          // L'utilisateur a annulé
          return;
        }
        
        const inputValue = parseInt(userInput);
        if (inputValue === expectedValue) {
          window.open('https://www.dropbox.com/scl/fo/vwwfz15a8cit0izownlps/AGS6YVR1Txxe-WYguQi48KQ?rlkey=4d30p996exh9v3mipfvmm58yb&st=jw60v4t8&dl=0', '_blank');
        } else {
          alert("Code incorrect. Veuillez réessayer.");
        }
      }

      const geneticCode = {
        ATG: "START",
        AAA: "A",
        // Ordre alphabétique des triplets
        // A : 1 triplet
        AAC: "À",
        AAG: "Â",
        // B : 1 triplet
        AAT: "B",
        // C : 2 triplets
        ACA: "C",
        ACC: "Ç",
        // D : 2 triplets
        ACG: "D",
        // E : 1 triplet
        ACT: "E",
        AGC: "Œ",
        // É (é en majuscule) : 1 triplet
        AGG: "É",
        // È (è en majuscule) : 1 triplet
        AGT: "È",
        // Ê (ê en majuscule) : 1 triplet
        ATA: "Ê",
        // Ë (ë en majuscule) : 1 triplet
        ATC: "Ë",
        // F : 2 triplets
        ATT: "F",
        CAA: "G",
        // G : 2 triplets
        CAC: "H",
        CAG: "I",
        // H : 2 triplets
        CAT: "Î",
        CCA: "Ï",
        // I : 1 triplet
        CCC: "J",
        // Ï (ï en majuscule) : 1 triplet
        CCG: "K",
        // J : 2 triplets
        CCT: "L",
        CGA: "M",
        // K : 2 triplets
        CGC: "N",
        CGG: "O",
        // L : 2 triplets
        CGT: "Ô",
        CTA: "P",
        // M : 2 triplets
        CTC: "Q",
        CTG: "R",
        // N : 2 triplets
        CTT: "S",
        GAA: "T",
        // O : 2 triplets
        GAC: "U",
        GAG: "Û",
        // P : 2 triplets
        GAT: "Ü",
        GCA: "V",
        // Q : 2 triplets
        GCC: "W",
        GCG: "X",
        // R : 2 triplets
        GCT: "Y",
        GGA: "Z",
        // S : 2 triplets
        GGC: "1",
        GGT: "2",
        // T : 2 triplets
        GTA: "3",
        GTC: "4",
        // U : 2 triplets
        GTG: "5",
        GTT: "6",
        // V : 2 triplets
        TAC: "7",
        TAT: "8",
        // W : 2 triplets
        TCA: "9",
        TCC: "(",
        // X : 2 triplets
        TCG: ")",
        TCT: "-",
        // Point (fin de phrase) - uniquement les 3 stop codons classiques
        TAA: ".",
        TAG: ".",
        TGA: ".",
        // Utiliser les triplets restants pour des redondances
        TGC: "!", // Y : 1 triplet
        TGG: "?", // Z : 1 triplet
        // Caractères spéciaux (derniers triplets)
        TTA: ":", // Virgule
        TTC: "'", // Apostrophe
        TTG: ",", // Virgule (tous types)
        TTT: " ", // Espace
      };

      const reverseCode = {};
      for (let [codon, char] of Object.entries(geneticCode)) {
        if (char !== "START") {
          if (!reverseCode[char]) reverseCode[char] = [];
          reverseCode[char].push(codon);
        }
      }

      // Variables pour le mode "encodage à trou"
      let trouModeActive = false;
      let selectedWordIndices = new Set(); // Indices des mots sélectionnés (0-based)
      let currentWordPositions = []; // Positions des mots dans la séquence actuelle

      // Gérer le collage dans le champ d'encodage (textInput)
      const textInput = document.getElementById("textInput");
      if (textInput) {
        textInput.addEventListener("paste", function () {
          // Vider les champs de décodage lors du collage dans le champ d'encodage
          const dnaInput = document.getElementById("dnaInput");
          const output = document.getElementById("output");
          if (dnaInput) {
            dnaInput.textContent = "";
            dnaInput.removeAttribute("data-full-sequence");
            dnaInput.removeAttribute("data-modified-ranges");
            dnaInput.removeAttribute("data-deleted-ranges");
          }
          if (output) {
            output.innerHTML = "";
          }
        });
      }

      // Fonction pour activer/désactiver le mode "à trou"
      function toggleTrouMode() {
        trouModeActive = !trouModeActive;
        const btn = document.getElementById("trouModeBtn");
        const output = document.getElementById("dnaOutput");
        const textInput = document.getElementById("textInput");

        if (trouModeActive) {
          btn.classList.add("trou-mode-active");
          btn.textContent = "Double-cliquez sur les mots";
          // Réencoder pour permettre la sélection
          if (textInput.value.trim()) {
            encodeText();
          } else {
            // Si aucun texte n'est encodé, afficher un message
            output.innerHTML =
              '<span style="color: #666; font-style: italic;">Veuillez d\'abord encoder un texte pour utiliser le mode "à trou".</span>';
          }
        } else {
          btn.classList.remove("trou-mode-active");
          btn.textContent = "Texte à trou";
          // Réencoder pour enlever les sélections
          if (textInput.value.trim()) {
            encodeText();
          } else {
            // Si aucun texte n'est encodé, vider l'affichage
            output.innerHTML = "";
          }
        }
      }

      // Marqueur spécial pour les positions "à trou" : TGGTGG (double stop codon)
      const TROU_MARKER = "TGGTGG";

      // Fonction pour encoder les positions des mots sélectionnés
      function encodeTrouPositions(indices) {
        if (indices.size === 0) return "";
        // Format: TGGTGG (marqueur) + positions encodées en base 4, longueur fixe 4 (A=0, T=1, C=2, G=3)
        // Longueur fixe évite toute ambiguïté lors du décodage (pas besoin de séparateur)
        const positions = Array.from(indices).sort((a, b) => a - b);
        let encoded = TROU_MARKER; // Marqueur de début

        for (let pos of positions) {
          let digits = [];
          let n = pos;
          // Encoder sur 4 digits base 4
          for (let i = 0; i < 4; i++) {
            digits.unshift(n % 4);
            n = Math.floor(n / 4);
          }
          const dnaDigits = digits.map((d) => ["A", "T", "C", "G"][d]).join("");
          encoded += dnaDigits;
        }

        return encoded;
      }

      // Fonction pour décoder les positions des mots à trou
      function decodeTrouPositions(dna) {
        const indices = new Set();
        // Chercher le marqueur TGGTGG
        const startIdx = dna.indexOf(TROU_MARKER);
        if (startIdx === -1) return indices;

        // Extraire la partie après le marqueur (chaque position = 4 bases codées)
        const encoded = dna.substring(startIdx + TROU_MARKER.length);
        for (let i = 0; i + 4 <= encoded.length; i += 4) {
          const chunk = encoded.substring(i, i + 4);
          let pos = 0;
          for (let j = 0; j < chunk.length; j++) {
            const digit = ["A", "T", "C", "G"].indexOf(chunk[j]);
            if (digit === -1) {
              pos = null;
              break;
            }
            pos = pos * 4 + digit;
          }
          if (pos !== null) {
            indices.add(pos);
          }
        }

        return indices;
      }

      // Fonction pour obtenir la classe CSS selon la longueur du mot
      function getWordClass(length) {
        if (length <= 4) return "word-short";
        if (length <= 6) return "word-medium";
        if (length <= 9) return "word-long";
        return "word-verylong";
      }

      // Fonction pour colorer le texte selon la longueur des mots
      function colorizeText(text, wordToDNA = null) {
        const words = text.split(/(\s+)/);
        let html = "";
        for (let word of words) {
          if (word.trim() === "") {
            // Espace
            html += `<span class="word-space">${word}</span>`;
          } else {
            const length = word.length;
            const className = getWordClass(length);
            const tooltip =
              wordToDNA && wordToDNA[word] ? ` title="${wordToDNA[word]}"` : "";
            html += `<span class="${className}"${tooltip}>${word}</span>`;
          }
        }
        return html;
      }

      // Fonction pour décoder une séquence ADN en texte
      function decodeDNASequence(dnaSequence) {
        let decoded = "";
        for (let i = 0; i <= dnaSequence.length - 3; i += 3) {
          const codon = dnaSequence.substring(i, i + 3);
          const decodedChar = geneticCode[codon];
          if (decodedChar && decodedChar !== "START") {
            let displayChar = decodedChar;
            if (decodedChar === "é") displayChar = "É";
            if (decodedChar === "è") displayChar = "È";
            if (decodedChar === "ê") displayChar = "Ê";
            if (decodedChar === "ë") displayChar = "Ë";
            if (decodedChar === "ï") displayChar = "Ï";
            decoded += displayChar;
          }
        }
        return decoded;
      }

      // Fonction pour ajouter des marqueurs de séparation entre triplets
      function addTripletSeparators(sequence) {
        if (!sequence || sequence.length === 0) return "";
        let result = "";
        for (let i = 0; i < sequence.length; i++) {
          result += sequence[i];
          // Ajouter un marqueur après chaque triplet (tous les 3 caractères), sauf à la fin
          if ((i + 1) % 3 === 0 && i < sequence.length - 1) {
            result += '<span class="triplet-separator"></span>';
          }
        }
        return result;
      }

      // Fonction pour colorer la séquence ADN selon les mots (pour le décodage)
      function colorizeDNAForDecode(dna) {
        if (!dna || dna.length === 0) return "";

        // Vérifier s'il y a un marqueur "à trou" (TGGTGG)
        const markerIndex = dna.indexOf(TROU_MARKER);
        let sequenceToColorize = dna;
        let markerAndPositions = "";

        if (markerIndex !== -1) {
          // Séparer la séquence principale et le marqueur avec les positions
          sequenceToColorize = dna.substring(0, markerIndex);
          markerAndPositions = dna.substring(markerIndex);
        }

        let html = "";
        let i = 0;
        const startIndex = sequenceToColorize.indexOf("ATG");

        if (startIndex === -1) {
          // Pas de ATG, commencer au début
          i = 0;
        } else {
          // Ajouter tout ce qui précède ATG et ATG lui-même avec marqueurs de triplets
          const beforeATG = sequenceToColorize.substring(0, startIndex + 3);
          html += `<span>${addTripletSeparators(beforeATG)}</span>`;
          i = startIndex + 3;
        }

        let currentWordStart = i;
        let inWord = true;

        // Traiter toute la séquence sans s'arrêter aux codons stop
        while (i <= sequenceToColorize.length - 3) {
          const codon = sequenceToColorize.substring(i, i + 3);

          if (codon === "TTT") {
            // Espace
            if (inWord) {
              // Finir le mot précédent
              const wordLength = i - currentWordStart;
              const className = getNucleotideClass(wordLength);
              const wordDNA = sequenceToColorize.substring(currentWordStart, i);
              const decodedWord = decodeDNASequence(wordDNA);
              const tooltip = decodedWord ? ` title="${decodedWord}"` : "";
              html += `<span class="${className}"${tooltip}>${addTripletSeparators(
                wordDNA
              )}</span>`;
              inWord = false;
            }
            html += `<span class="word-space">${addTripletSeparators(
              codon
            )}</span>`;
            i += 3;
            currentWordStart = i;
            inWord = true;
          } else if (["TAA", "TAG", "TGA"].includes(codon)) {
            // Codon stop = point (mais continuer après)
            if (inWord) {
              const wordLength = i - currentWordStart;
              const className = getNucleotideClass(wordLength);
              const wordDNA = sequenceToColorize.substring(currentWordStart, i);
              const decodedWord = decodeDNASequence(wordDNA);
              const tooltip = decodedWord ? ` title="${decodedWord}"` : "";
              html += `<span class="${className}"${tooltip}>${addTripletSeparators(
                wordDNA
              )}</span>`;
              inWord = false;
            }
            html += `<span class="word-stop" title="Point">${addTripletSeparators(
              codon
            )}</span>`;
            i += 3;
            currentWordStart = i;
            inWord = true;
          } else {
            i += 3;
          }
        }

        // Ajouter le dernier mot s'il existe
        if (inWord && i > currentWordStart) {
          const wordLength = i - currentWordStart;
          const className = getNucleotideClass(wordLength);
          const wordDNA = sequenceToColorize.substring(currentWordStart, i);
          const decodedWord = decodeDNASequence(wordDNA);
          const tooltip = decodedWord ? ` title="${decodedWord}"` : "";
          html += `<span class="${className}"${tooltip}>${addTripletSeparators(
            wordDNA
          )}</span>`;
        }

        // Ajouter le reste de la séquence (ce qui reste après le dernier triplet complet)
        if (i < sequenceToColorize.length) {
          const remainder = sequenceToColorize.substring(i);
          html += `<span>${addTripletSeparators(remainder)}</span>`;
        }

        // Ajouter le marqueur et les positions "à trou" s'ils existent
        if (markerAndPositions) {
          html += `<span style="color: #999; font-size: 0.9em;">${markerAndPositions}</span>`;
        }

        return html;
      }

      // Fonction pour coloriser le textarea de décodage
      function colorizeDNAInput() {
        const dnaInput = document.getElementById("dnaInput");
        let rawText = dnaInput.getAttribute("data-full-sequence");
        if (!rawText) {
          rawText = dnaInput.innerText || dnaInput.textContent || "";
        }

        // Si on détecte un marqueur "à trou", on masque visuellement la partie après le marqueur
        const markerIndex = rawText.indexOf(TROU_MARKER);
        if (markerIndex !== -1) {
          const visible = rawText.substring(0, markerIndex);
          // Stocker la séquence complète pour le décodage
          dnaInput.setAttribute("data-full-sequence", rawText);
          // Afficher uniquement la partie visible
          dnaInput.textContent = visible;
          // Repartir du visible pour le coloriage
          rawText = visible;
        }

        const cleaned = rawText.toUpperCase().replace(/[^ATCG]/g, "");

        if (cleaned.length === 0) {
          if (text.length === 0) {
            dnaInput.innerHTML = "";
          }
          return;
        }

        const colored = colorizeDNAForDecode(cleaned);

        // Appliquer le style aux nucléotides modifiés et aux délétions
        const modifiedRanges = JSON.parse(
          dnaInput.getAttribute("data-modified-ranges") || "[]"
        );
        const deletedRanges = JSON.parse(
          dnaInput.getAttribute("data-deleted-ranges") || "[]"
        );
        let finalHTML = colored;

        if (modifiedRanges.length > 0 || deletedRanges.length > 0) {
          // Créer un élément temporaire pour manipuler le HTML
          const tempDiv = document.createElement("div");
          tempDiv.innerHTML = colored;

          // Parcourir tous les nœuds texte et appliquer le style aux positions modifiées
          const walker = document.createTreeWalker(
            tempDiv,
            NodeFilter.SHOW_TEXT,
            null,
            false
          );

          let textPos = 0;
          const nodesToWrap = [];

          let node;
          while ((node = walker.nextNode())) {
            const nodeText = node.textContent;
            const nodeStart = textPos;
            const nodeEnd = textPos + nodeText.length;

            // Vérifier si cette portion chevauche une plage modifiée
            for (let range of modifiedRanges) {
              if (nodeEnd > range.start && nodeStart < range.end) {
                // Il y a un chevauchement
                const overlapStart = Math.max(0, range.start - nodeStart);
                const overlapEnd = Math.min(
                  nodeText.length,
                  range.end - nodeStart
                );

                if (overlapStart < overlapEnd) {
                  // Déterminer le type : substitution ou addition (par défaut addition pour compatibilité)
                  const mutationType = range.type === "substitution" ? "substitution" : "addition";
                  nodesToWrap.push({
                    node: node,
                    start: overlapStart,
                    end: overlapEnd,
                    type: mutationType,
                  });
                }
              }
            }

            // Vérifier si cette portion contient le début d'une plage supprimée (marqueur avant)
            for (let range of deletedRanges) {
              // Marquer juste avant la position de début de la délétion
              if (nodeStart <= range.start && range.start < nodeEnd) {
                const markerPos = range.start - nodeStart;
                if (markerPos >= 0 && markerPos < nodeText.length) {
                  nodesToWrap.push({
                    node: node,
                    start: markerPos,
                    end: markerPos,
                    type: "deleted",
                  });
                }
              }
            }

            textPos = nodeEnd;
          }

          // Grouper les modifications par nœud pour éviter les doublons
          const nodeModifications = new Map();
          nodesToWrap.forEach(({ node, start, end, type }) => {
            if (!nodeModifications.has(node)) {
              nodeModifications.set(node, []);
            }
            nodeModifications.get(node).push({ start, end, type });
          });

          // Appliquer les modifications (en ordre inverse pour préserver les indices)
          Array.from(nodeModifications.entries())
            .reverse()
            .forEach(([node, mods]) => {
              const parent = node.parentNode;
              const nodeText = node.textContent;

              // Trier les modifications par position
              mods.sort((a, b) => a.start - b.start);

              // Construire le nouveau contenu du nœud
              let newContent = [];
              let lastPos = 0;

              for (let mod of mods) {
                // Ajouter le texte avant la modification
                if (mod.start > lastPos) {
                  newContent.push(
                    document.createTextNode(
                      nodeText.substring(lastPos, mod.start)
                    )
                  );
                }

                if (mod.type === "deleted") {
                  // Pour les délétions, insérer un marqueur visuel (croix rouge dans un carré)
                  const deletedMarker = document.createElement("span");
                  deletedMarker.className = "nucleotide-deleted-marker";
                  deletedMarker.title = "Délétion à cet emplacement";
                  // Le contenu visuel est créé par CSS (::before et ::after)
                  newContent.push(deletedMarker);
                  lastPos = mod.start;
                } else if (mod.type === "substitution") {
                  // Pour les substitutions, ajouter le texte avec fond mauve
                  const modifiedText = nodeText.substring(mod.start, mod.end);
                  const modifiedSpan = document.createElement("span");
                  modifiedSpan.className = "nucleotide-substituted";
                  modifiedSpan.textContent = modifiedText;
                  newContent.push(modifiedSpan);
                  lastPos = mod.end;
                } else {
                  // Pour les additions, ajouter le texte avec fond noir
                  const modifiedText = nodeText.substring(mod.start, mod.end);
                  const modifiedSpan = document.createElement("span");
                  modifiedSpan.className = "nucleotide-modified";
                  modifiedSpan.textContent = modifiedText;
                  newContent.push(modifiedSpan);
                  lastPos = mod.end;
                }
              }

              // Ajouter le texte restant
              if (lastPos < nodeText.length) {
                newContent.push(
                  document.createTextNode(nodeText.substring(lastPos))
                );
              }

              // Remplacer le nœud
              newContent.forEach((content) => {
                parent.insertBefore(content, node);
              });
              parent.removeChild(node);
            });

          finalHTML = tempDiv.innerHTML;
        }

        // Ne mettre à jour que si le contenu a changé pour éviter les problèmes de curseur
        if (dnaInput.innerHTML !== finalHTML) {
          dnaInput.innerHTML = finalHTML;
        }
      }

      function decodeDNA() {
        const dnaInput = document.getElementById("dnaInput");
        // Récupérer la séquence complète depuis l'attribut data si elle existe
        // Sinon utiliser le texte du champ (pour les cas où l'utilisateur tape manuellement)
        let rawInput = dnaInput.getAttribute("data-full-sequence");
        if (!rawInput) {
          rawInput = dnaInput.innerText || dnaInput.textContent || "";
        }
        // Nettoyer pour le décodage (enlever tout sauf A, T, C, G)
        let input = rawInput.toUpperCase().replace(/[^ATCG]/g, "");

        // Détecter si c'est une image pixel art (>= 14700 nucléotides)
        // 14700 = 4900 triplets pour une grille 70x70 (palette classique par défaut)
        // 14703+ = 1 triplet de palette + 4900+ triplets pour une grille 70x70+ (max 70 pixels supplémentaires)
        const baseSize = 70 * 70 * 3; // 14700 nucléotides pour 70x70
        const maxAdditionalPixels = 70; // Maximum 70 pixels supplémentaires
        const maxSize = baseSize + 3 + maxAdditionalPixels * 3; // 14703 + 210 = 14913 max

        if (input.length >= baseSize && input.length <= maxSize) {
          // C'est une image pixel art, ouvrir l'éditeur avec cette séquence
          loadPixelArtFromSequence(input);
          return;
        }

        // Extraire les positions "à trou" AVANT de retirer le marqueur (chercher TGGTGG)
        const trouIndices = decodeTrouPositions(input);

        // Retirer le marqueur et les positions de la séquence à décoder
        const markerIndex = input.indexOf(TROU_MARKER);
        if (markerIndex !== -1) {
          input = input.substring(0, markerIndex);
        }

        const output = document.getElementById("output");
        output.innerHTML = "";
        const startIndex = input.indexOf("ATG");
        if (startIndex === -1) {
          output.textContent = "Aucun codon START (ATG) trouvé.";
          return;
        }

        // Décoder le message et créer la correspondance mot -> séquence ADN
        const words = []; // Liste des mots (décodés ou ADN)
        const wordToDNA = {}; // Correspondance mot -> séquence ADN
        let currentWord = "";
        let currentWordDNA = "";
        let wordIndex = 0; // Index du mot actuel
        let foundStopCodon = false; // Indicateur si on a trouvé un codon stop

        for (let i = startIndex + 3; i <= input.length - 3; i += 3) {
          const codon = input.substring(i, i + 3);

          if (["TAA", "TAG", "TGA"].includes(codon)) {
            // D'abord, finaliser et ajouter le mot actuel s'il existe
            if (currentWord || currentWordDNA) {
              if (trouIndices.has(wordIndex)) {
                // Mot "à trou" : garder la séquence ADN
                words.push({
                  type: "trou",
                  content: currentWordDNA,
                  dna: currentWordDNA,
                });
              } else {
                // Mot normal : décoder
                if (currentWord) {
                  wordToDNA[currentWord] = currentWordDNA;
                  words.push({
                    type: "normal",
                    content: currentWord,
                    dna: currentWordDNA,
                  });
                }
              }
            }

            // Réinitialiser IMMÉDIATEMENT pour éviter que le point soit intégré au mot suivant
            currentWord = "";
            currentWordDNA = "";

            // Ignorer les codons stop consécutifs en sautant directement au prochain codon non-stop
            while (i + 3 <= input.length - 3) {
              const nextCodon = input.substring(i + 3, i + 6);
              if (["TAA", "TAG", "TGA"].includes(nextCodon)) {
                i += 3; // Sauter ce codon stop aussi
              } else {
                break; // Prochain codon n'est pas un stop, continuer normalement
              }
            }

            // Ajouter un point seulement si le dernier élément ajouté n'est pas déjà un point
            let shouldAddPoint = true;
            if (words.length > 0) {
              const lastElement = words[words.length - 1];
              // Ne pas ajouter de point si le dernier élément est déjà un point
              if (
                lastElement.type === "punctuation" &&
                lastElement.content === "."
              ) {
                shouldAddPoint = false;
              }
            }

            if (shouldAddPoint) {
              words.push({ type: "punctuation", content: "." });
            }
            foundStopCodon = true;
            // CONTINUER dans la boucle pour traiter le prochain codon (qui sera le début du mot suivant)
            continue;
          }

          if (codon === "TTT") {
            // Espace
            if (currentWord || currentWordDNA) {
              if (trouIndices.has(wordIndex)) {
                // Mot "à trou" : garder la séquence ADN
                words.push({
                  type: "trou",
                  content: currentWordDNA,
                  dna: currentWordDNA,
                });
              } else {
                // Mot normal : décoder
                if (currentWord) {
                  wordToDNA[currentWord] = currentWordDNA;
                  words.push({
                    type: "normal",
                    content: currentWord,
                    dna: currentWordDNA,
                  });
                }
              }
              currentWord = "";
              currentWordDNA = "";
            }
            // Ne pas ajouter d'espace si le dernier élément est déjà un point (évite l'espace entre point et mot suivant)
            if (words.length > 0) {
              const lastElement = words[words.length - 1];
              if (
                lastElement.type === "punctuation" &&
                lastElement.content === "."
              ) {
                // Ne pas ajouter d'espace après un point
                wordIndex++; // Passer au mot suivant quand même
                continue;
              }
            }
            words.push({ type: "space", content: " " });
            wordIndex++; // Passer au mot suivant
          } else {
            const decodedChar = geneticCode[codon];
            if (decodedChar && decodedChar !== "START") {
              // Forcer les minuscules accentuées à s'afficher en majuscules
              let displayChar = decodedChar;
              if (decodedChar === "é") displayChar = "É";
              if (decodedChar === "è") displayChar = "È";
              if (decodedChar === "ê") displayChar = "Ê";
              if (decodedChar === "ë") displayChar = "Ë";
              if (decodedChar === "ï") displayChar = "Ï";

              currentWordDNA += codon;
              // Si ce mot est "à trou", ne pas décoder
              if (!trouIndices.has(wordIndex)) {
                currentWord += displayChar;
              }
            }
          }
        }

        // Ajouter le dernier mot s'il existe (même après un codon stop, car on peut avoir plusieurs phrases)
        // Mais seulement si on n'a pas déjà traité un codon stop à la fin qui aurait vidé currentWord
        if (currentWord || currentWordDNA) {
          // Vérifier si le dernier codon de la séquence est un stop
          const lastCodon = input.substring(input.length - 3);
          const isLastCodonStop = ["TAA", "TAG", "TGA"].includes(lastCodon);

          // Si le dernier codon est un stop, il a déjà été traité dans la boucle
          // et le mot a déjà été ajouté, donc on ne doit pas l'ajouter à nouveau
          if (!isLastCodonStop) {
            if (trouIndices.has(wordIndex)) {
              // Mot "à trou" : garder la séquence ADN
              words.push({
                type: "trou",
                content: currentWordDNA,
                dna: currentWordDNA,
              });
            } else {
              // Mot normal : décoder
              if (currentWord) {
                wordToDNA[currentWord] = currentWordDNA;
                words.push({
                  type: "normal",
                  content: currentWord,
                  dna: currentWordDNA,
                });
              }
            }
          }
        }

        // Fonction pour vérifier si une chaîne est une séquence ADN pure
        function isDNASequence(str) {
          return /^[ATCG]+$/i.test(str) && str.length >= 3;
        }

        // Afficher le texte décodé avec les mots "à trou" en séquence ADN
        let html = "";
        for (let word of words) {
          if (word.type === "space") {
            html += `<span class="word-space">${word.content}</span>`;
          } else if (word.type === "punctuation") {
            // Les points doivent avoir la couleur d'arrière-plan rose pastel
            html += `<span class="word-stop">${word.content}</span>`;
          } else if (word.type === "trou") {
            // Afficher la séquence ADN avec double-clic
            html += `<span class="word-trou decode-dna" data-dna="${word.content}" style="font-family: monospace; background: #ff6b6b; padding: 4px 6px; border-radius: 4px; cursor: pointer; user-select: text; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; pointer-events: auto;" title="Double-cliquez pour décoder">${word.content}</span>`;
          } else {
            // Mot normal - vérifier si c'est une séquence ADN pure
            if (isDNASequence(word.content)) {
              html += `<span class="decode-dna" data-dna="${word.content}" style="font-family: monospace; background: #ffb3d9; padding: 4px 6px; border-radius: 4px; cursor: pointer; user-select: text; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; pointer-events: auto;" title="Double-cliquez pour décoder">${word.content}</span>`;
            } else {
              const length = word.content.length;
              const className = getWordClass(length);
              const tooltip = wordToDNA[word.content]
                ? ` title="${wordToDNA[word.content]}"`
                : "";
              html += `<span class="${className}"${tooltip}>${word.content}</span>`;
            }
          }
        }

        output.innerHTML = html;

        // Ajouter les événements double-clic/double-tap sur les séquences ADN
        // Variable globale pour le double-tap (partagée entre tous les spans)
        if (!window.lastDecodeTap) {
          window.lastDecodeTap = { time: 0, target: null };
        }

        output.querySelectorAll(".decode-dna").forEach((span) => {
          // Empêcher la sélection de texte sur mobile
          span.addEventListener(
            "touchstart",
            function (e) {
              // Si c'est un double-tap potentiel, empêcher la sélection
              const currentTime = new Date().getTime();
              const timeSinceLastTap = currentTime - window.lastDecodeTap.time;
              if (
                timeSinceLastTap < 300 &&
                window.lastDecodeTap.target === this
              ) {
                e.preventDefault();
              }
            },
            { passive: false }
          );

          // Double-clic pour desktop
          span.addEventListener("dblclick", function (e) {
            e.preventDefault();
            const dnaSequence = this.getAttribute("data-dna");
            openDecodeModal(dnaSequence, this);
          });

          // Double-tap pour mobile/tactile
          span.addEventListener(
            "touchend",
            function (e) {
              const currentTime = new Date().getTime();
              const timeSinceLastTap = currentTime - window.lastDecodeTap.time;

              // Vérifier si c'est un double-tap sur le même élément
              if (
                timeSinceLastTap < 300 &&
                timeSinceLastTap > 0 &&
                window.lastDecodeTap.target === this
              ) {
                // Double tap détecté
                e.preventDefault();
                e.stopPropagation();

                // Annuler toute sélection de texte
                if (window.getSelection) {
                  window.getSelection().removeAllRanges();
                }

                const dnaSequence = this.getAttribute("data-dna");
                openDecodeModal(dnaSequence, this);

                // Réinitialiser pour éviter les triple-taps
                window.lastDecodeTap.time = 0;
                window.lastDecodeTap.target = null;
              } else {
                // Premier tap
                window.lastDecodeTap.time = currentTime;
                window.lastDecodeTap.target = this;
              }
            },
            { passive: false }
          );
        });

        // Centrer la vue sur la fenêtre de résultats
        setTimeout(() => {
          output.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 100);
      }

      // Fonction pour ouvrir la modale de décodage interactif
      function openDecodeModal(dnaSequence, originalSpan = null) {
        const modal = document.getElementById("decodeModal");
        const modalContent = document.getElementById("modalContent");

        // Nettoyer la séquence (enlever tout sauf A, T, C, G)
        const cleaned = dnaSequence.toUpperCase().replace(/[^ATCG]/g, "");

        if (cleaned.length < 3) {
          alert("Séquence ADN trop courte pour être décodée.");
          return;
        }

        // Stocker la référence au span original pour pouvoir le remplacer
        window.modalOriginalSpan = originalSpan;
        window.modalDNASequence = cleaned;

        // Récupérer le mot déjà saisi s'il existe (pour préremplir)
        let existingWord = "";
        if (originalSpan && originalSpan.classList.contains("decode-filled")) {
          existingWord = originalSpan.textContent || "";
        }

        // Diviser en triplets et décoder
        const triplets = [];
        const decodedChars = [];
        let correctWord = ""; // Mot correct décodé

        for (let i = 0; i <= cleaned.length - 3; i += 3) {
          const triplet = cleaned.substring(i, i + 3);
          triplets.push(triplet);

          const decodedChar = geneticCode[triplet];
          if (decodedChar && decodedChar !== "START") {
            let displayChar = decodedChar;
            // Forcer les minuscules accentuées à s'afficher en majuscules
            if (decodedChar === "é") displayChar = "É";
            if (decodedChar === "è") displayChar = "È";
            if (decodedChar === "ê") displayChar = "Ê";
            if (decodedChar === "ë") displayChar = "Ë";
            if (decodedChar === "ï") displayChar = "Ï";

            decodedChars.push({ char: displayChar, isMarker: false });
            // Construire le mot correct
            correctWord += displayChar;
          } else {
            decodedChars.push({ char: "?", isMarker: false });
          }
        }

        // Stocker le mot correct pour la validation
        window.modalCorrectWord = correctWord;

        // Créer le contenu de la modale
        let html = '<div style="margin-bottom: 30px;">';
        html +=
          '<h3 style="color: #667eea; margin-bottom: 15px;">Séquence ADN : ' +
          cleaned +
          "</h3>";

        // Première ligne : inputs pour les lettres
        html +=
          '<div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px; justify-content: center; align-items: center;">';
        let existingWordIndex = 0; // Index pour parcourir le mot existant
        decodedChars.forEach((item, index) => {
          // Préremplir avec la lettre existante si disponible
          const existingLetter =
            existingWord && existingWordIndex < existingWord.length
              ? existingWord[existingWordIndex].toUpperCase()
              : "";
          existingWordIndex++;

          html += `<input type="text"
                          id="letter-${index}"
                          maxlength="1"
                          value="${existingLetter}"
                          style="width: 40px; height: 40px; text-align: center; font-size: 1.5rem; border: 2px solid #667eea; border-radius: 6px; font-weight: bold; text-transform: uppercase;"
                          placeholder="?"
                          oninput="this.value = this.value.toUpperCase()">`;
        });
        html += "</div>";

        // Bouton de validation
        html += '<div style="text-align: center; margin: 20px 0;">';
        html +=
          '<button id="validateDecode" style="background: #51cf66; color: white; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5); border: none; padding: 15px 30px; border-radius: 8px; cursor: pointer; font-size: 1.1rem; font-weight: bold;">Valider</button>';
        html += "</div>";

        // Deuxième ligne : les triplets
        html +=
          '<div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 30px; justify-content: center; font-family: monospace;">';
        triplets.forEach((triplet, index) => {
          const isStop = ["TAA", "TAG", "TGA"].includes(triplet);
          let bgColor = "#e0e0e0";
          if (isStop) bgColor = "#ffb3d9";
          html += `<div style="width: 40px; height: 30px; text-align: center; padding-top: 5px; background: ${bgColor}; border-radius: 4px; font-size: 0.9rem;">${triplet}</div>`;
        });
        html += "</div>";

        // Troisième ligne : code génétique (tableau)
        html +=
          '<div style="margin-top: 30px; border-top: 2px solid #e0e0e0; padding-top: 20px;">';
        html +=
          '<h3 style="color: #667eea; margin-bottom: 15px;">Code Génétique</h3>';
        html += '<div style="overflow-x: auto;">';
        html +=
          '<table style="width: 100%; border-collapse: collapse; margin: 0 auto;">';
        html += "<thead><tr>";
        for (let i = 0; i < 4; i++) {
          html +=
            '<th style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5); padding: 10px; text-align: center;">Codon</th>';
          html +=
            '<th style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5); padding: 10px; text-align: center;">Symbole</th>';
        }
        html += "</tr></thead><tbody>";

        // Remplir le tableau avec le code génétique (même logique que la page principale)
        const entries = Object.entries(geneticCode)
          .filter(([k, v]) => v !== "START")
          .sort(([a], [b]) => a.localeCompare(b));
        const numColumns = 4;
        const entriesPerColumn = Math.ceil(entries.length / numColumns);

        // Créer les lignes
        const tableRows = [];
        for (let i = 0; i < entriesPerColumn; i++) {
          const rowData = [];
          for (let j = 0; j < numColumns * 2; j++) {
            rowData.push(null);
          }
          tableRows.push(rowData);
        }

        // Remplir colonne par colonne (verticalement)
        entries.forEach(([codon, symbol], index) => {
          const columnIndex = Math.floor(index / entriesPerColumn);
          const rowIndex = index % entriesPerColumn;

          if (columnIndex >= numColumns) return;

          const codonCellIndex = columnIndex * 2;
          const symbolCellIndex = codonCellIndex + 1;

          tableRows[rowIndex][codonCellIndex] = codon;
          tableRows[rowIndex][symbolCellIndex] = symbol;
        });

        // Générer le HTML des lignes
        tableRows.forEach((row) => {
          html += "<tr>";
          for (let i = 0; i < row.length; i += 2) {
            const codon = row[i];
            const symbol = row[i + 1];
            if (codon && symbol) {
              const isStop = ["TAA", "TAG", "TGA"].includes(codon);
              const bgColor = isStop ? "#ffb3d9" : "";
              html += `<td style="padding: 8px; text-align: center; border: 1px solid #ddd; background: ${bgColor}; font-family: monospace;">${codon}</td>`;
              html += `<td style="padding: 8px; text-align: center; border: 1px solid #ddd; background: ${bgColor};">${symbol}</td>`;
            } else {
              html += '<td style="padding: 8px; border: 1px solid #ddd;"></td>';
              html += '<td style="padding: 8px; border: 1px solid #ddd;"></td>';
            }
          }
          html += "</tr>";
        });

        html += "</tbody></table>";
        html += "</div>";
        html += "</div>";

        modalContent.innerHTML = html;
        modal.style.display = "block";

        // Stocker les données pour la fonction de validation
        window.modalDecodedChars = decodedChars;

        // Fonction pour valider et remplacer la séquence ADN par le mot saisi
        window.validateDecode = function () {
          let userWord = "";

          // Récupérer toutes les lettres saisies
          if (window.modalDecodedChars) {
            window.modalDecodedChars.forEach((item, index) => {
              const input = document.getElementById(`letter-${index}`);
              if (input) {
                const letter = input.value.trim().toUpperCase();
                userWord += letter || "?";
              }
            });
          }

          // Remplacer le span original par le mot saisi
          if (window.modalOriginalSpan && userWord) {
            // Créer un nouveau span avec le mot saisi
            const newSpan = document.createElement("span");
            newSpan.textContent = userWord;
            newSpan.className =
              window.modalOriginalSpan.className + " decode-filled";
            // Stocker la séquence ADN originale pour pouvoir la modifier à nouveau
            newSpan.setAttribute("data-dna", window.modalDNASequence);

            // Comparer le mot saisi avec le mot correct
            const correctWord = window.modalCorrectWord || "";

            // Normaliser les deux chaînes pour la comparaison
            // Convertir en majuscules et normaliser les caractères accentués
            function normalizeForComparison(str) {
              return str.toUpperCase().normalize("NFC"); // Normaliser en forme composée canonique
            }

            const normalizedUser = normalizeForComparison(userWord);
            const normalizedCorrect = normalizeForComparison(correctWord);

            // Comparaison avec debug (peut être retiré après)
            console.log(
              "User word:",
              userWord,
              "-> Normalized:",
              normalizedUser
            );
            console.log(
              "Correct word:",
              correctWord,
              "-> Normalized:",
              normalizedCorrect
            );
            console.log("Match:", normalizedUser === normalizedCorrect);

            // Comparaison directe en majuscules (fallback)
            const directComparison =
              userWord.toUpperCase() === correctWord.toUpperCase();
            console.log("Direct comparison:", directComparison);

            // Utiliser les deux méthodes de comparaison
            const isCorrect =
              normalizedUser === normalizedCorrect || directComparison;

            console.log("Final isCorrect:", isCorrect);

            // Appliquer la couleur selon la justesse
            if (isCorrect) {
              // Vert pastel si correct
              console.log("Applying green color");
              newSpan.style.setProperty("background", "#b3ffb3", "important");
              newSpan.style.setProperty(
                "background-color",
                "#b3ffb3",
                "important"
              );
            } else {
              // Rouge pastel si incorrect
              console.log("Applying red color");
              newSpan.style.setProperty("background", "#ffb3b3", "important");
              newSpan.style.setProperty(
                "background-color",
                "#ffb3b3",
                "important"
              );
            }

            console.log("Final background color:", newSpan.style.background);
            console.log(
              "Final computed style:",
              window.getComputedStyle(newSpan).backgroundColor
            );

            newSpan.style.cursor = "pointer";
            newSpan.style.userSelect = "none";
            newSpan.style.webkitUserSelect = "none";
            newSpan.style.mozUserSelect = "none";
            newSpan.style.msUserSelect = "none";
            newSpan.title = "Double-cliquez pour modifier";

            // Ajouter l'événement de double-clic/double-tap pour permettre de modifier à nouveau
            newSpan.addEventListener("dblclick", function (e) {
              e.preventDefault();
              const dnaSequence = this.getAttribute("data-dna");
              openDecodeModal(dnaSequence, this);
            });

            // Empêcher la sélection de texte sur mobile
            newSpan.addEventListener(
              "touchstart",
              function (e) {
                const currentTime = new Date().getTime();
                const timeSinceLastTap =
                  currentTime - window.lastDecodeTap.time;
                if (
                  timeSinceLastTap < 300 &&
                  window.lastDecodeTap.target === this
                ) {
                  e.preventDefault();
                }
              },
              { passive: false }
            );

            // Double-tap pour mobile/tactile
            newSpan.addEventListener(
              "touchend",
              function (e) {
                const currentTime = new Date().getTime();
                const timeSinceLastTap =
                  currentTime - window.lastDecodeTap.time;

                // Vérifier si c'est un double-tap sur le même élément
                if (
                  timeSinceLastTap < 300 &&
                  timeSinceLastTap > 0 &&
                  window.lastDecodeTap.target === this
                ) {
                  // Double tap détecté
                  e.preventDefault();
                  e.stopPropagation();

                  // Annuler toute sélection de texte
                  if (window.getSelection) {
                    window.getSelection().removeAllRanges();
                  }

                  const dnaSequence = this.getAttribute("data-dna");
                  openDecodeModal(dnaSequence, this);

                  // Réinitialiser pour éviter les triple-taps
                  window.lastDecodeTap.time = 0;
                  window.lastDecodeTap.target = null;
                } else {
                  // Premier tap
                  window.lastDecodeTap.time = currentTime;
                  window.lastDecodeTap.target = this;
                }
              },
              { passive: false }
            );

            // Remplacer l'ancien span par le nouveau
            window.modalOriginalSpan.parentNode.replaceChild(
              newSpan,
              window.modalOriginalSpan
            );
          }

          // Fermer la modale
          const modal = document.getElementById("decodeModal");
          if (modal) {
            modal.style.display = "none";
          }
        };

        // Ajouter l'événement sur le bouton de validation
        setTimeout(() => {
          const validateBtn = document.getElementById("validateDecode");
          if (validateBtn) {
            validateBtn.addEventListener("click", window.validateDecode);
          }

          // Fonction pour trouver l'index de la prochaine case
          function findNextInputIndex(currentIndex, direction) {
            const maxIndex = window.modalDecodedChars.length - 1;
            let nextIndex;
            if (direction === 1) {
              // Vers la droite
              nextIndex = (currentIndex + 1) % (maxIndex + 1);
            } else {
              // Vers la gauche
              nextIndex = (currentIndex - 1 + maxIndex + 1) % (maxIndex + 1);
            }
            return nextIndex;
          }

          // Ajouter la gestion du clavier sur tous les inputs
          window.modalDecodedChars.forEach((item, index) => {
            const input = document.getElementById(`letter-${index}`);
            if (input) {
              input.addEventListener("keydown", function (e) {
                if (e.key === "Enter") {
                  e.preventDefault();
                  // Passer à la case suivante
                  const nextIndex = findNextInputIndex(index, 1);
                  const nextInput = document.getElementById(
                    `letter-${nextIndex}`
                  );
                  if (nextInput) {
                    nextInput.focus();
                    nextInput.select();
                  }
                } else if (e.key === "ArrowRight") {
                  e.preventDefault();
                  // Aller à la case suivante
                  const nextIndex = findNextInputIndex(index, 1);
                  const nextInput = document.getElementById(
                    `letter-${nextIndex}`
                  );
                  if (nextInput) {
                    nextInput.focus();
                    nextInput.select();
                  }
                } else if (e.key === "ArrowLeft") {
                  e.preventDefault();
                  // Aller à la case précédente
                  const prevIndex = findNextInputIndex(index, -1);
                  const prevInput = document.getElementById(
                    `letter-${prevIndex}`
                  );
                  if (prevInput) {
                    prevInput.focus();
                    prevInput.select();
                  }
                }
              });

              // Passer automatiquement à la case suivante quand une lettre est entrée
              input.addEventListener("input", function (e) {
                const value = this.value.trim().toUpperCase();
                // Si une lettre a été entrée (pas vide, pas juste supprimée)
                if (
                  value.length === 1 &&
                  /[A-ZÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞß]/.test(value)
                ) {
                  // Passer à la case suivante
                  const nextIndex = findNextInputIndex(index, 1);
                  const nextInput = document.getElementById(
                    `letter-${nextIndex}`
                  );
                  if (nextInput) {
                    // Petit délai pour s'assurer que la valeur est bien mise à jour
                    setTimeout(() => {
                      nextInput.focus();
                      nextInput.select();
                    }, 10);
                  }
                }
              });
            }
          });
        }, 10);
      }

      // Fermer la modale
      document
        .getElementById("closeModal")
        .addEventListener("click", function () {
          document.getElementById("decodeModal").style.display = "none";
        });

      // Fermer la modale en cliquant en dehors
      document
        .getElementById("decodeModal")
        .addEventListener("click", function (e) {
          if (e.target === this) {
            this.style.display = "none";
          }
        });

      // Fonction pour normaliser le texte (tous les types d'apostrophes -> apostrophe standard)
      function normalizeText(text) {
        if (!text) return text;
        // Normaliser tous les types d'apostrophes vers l'apostrophe standard
        // Utiliser les codes Unicode pour capturer tous les types possibles
        // U+0027: ' (apostrophe droite)
        // U+2018: ' (guillemet simple ouvrant)
        // U+2019: ' (apostrophe typographique)
        // U+201A: ‚ (guillemet-virgule inférieur)
        // U+201B: ‛ (guillemet simple ouvrant renversé)
        // U+2032: ′ (prime)
        // U+2035: ‵ (prime renversée)
        // U+02BC: ʼ (lettre modificative apostrophe)
        // U+02BB: ʻ (lettre modificative guillemet simple)
        // U+0060: ` (accent grave)
        // U+00B4: ´ (accent aigu)
        // Utiliser une approche plus permissive pour capturer tous les caractères similaires
        let normalized = text;
        // Normaliser tous les types d'espaces vers l'espace standard (U+0020)
        // U+0020: espace standard
        // U+00A0: espace insécable
        // U+2000-U+200B: différents types d'espaces (en quadratin, cadratin, etc.)
        // U+202F: espace insécable étroit
        // U+205F: espace mathématique moyen
        // U+3000: espace idéographique
        normalized = normalized.replace(
          /[\u00A0\u2000-\u200B\u202F\u205F\u3000]/g,
          " "
        );
        // Remplacer tous les types d'apostrophes par l'apostrophe standard
        normalized = normalized.replace(/[''‚‛′‵ʼʻ`´]/g, "'");
        // Remplacer aussi par code Unicode pour être sûr
        normalized = normalized.replace(
          /[\u0027\u2018\u2019\u201A\u201B\u2032\u2035\u02BC\u02BB\u0060\u00B4]/g,
          "'"
        );
        // Guillemets typographiques
        normalized = normalized.replace(/[""]/g, '"');
        normalized = normalized.replace(/[""]/g, '"');
        return normalized;
      }

      // Fonction pour obtenir la classe CSS selon le nombre de nucléotides
      function getNucleotideClass(nucleotideCount) {
        if (nucleotideCount <= 12) return "word-short";
        if (nucleotideCount <= 18) return "word-medium";
        if (nucleotideCount <= 27) return "word-long";
        return "word-verylong";
      }

      // Fonction pour colorer la séquence ADN selon la longueur des mots
      function colorizeDNA(dna, wordPositions, dnaToText = null) {
        currentWordPositions = wordPositions.filter((w) => w.type === "word");
        let wordIndex = 0;
        let html = `<span>${dna.substring(0, 3)}</span>`; // ATG au début
        let lastEnd = 3; // Position après ATG

        for (let word of wordPositions) {
          // Vérifier s'il y a des codons stop entre lastEnd et word.start
          for (let i = lastEnd; i < word.start; i += 3) {
            const codon = dna.substring(i, i + 3);
            if (["TAA", "TAG", "TGA"].includes(codon)) {
              html += `<span class="word-stop" title="Point">${codon}</span>`;
              lastEnd = i + 3;
            }
          }

          if (word.type === "space") {
            // Espace (TTT = 3 nucléotides)
            html += `<span class="word-space">${dna.substring(
              word.start,
              word.end
            )}</span>`;
            lastEnd = word.end;
          } else {
            // Mot
            const nucleotideCount = word.end - word.start;
            let className = getNucleotideClass(nucleotideCount);
            const wordDNA = dna.substring(word.start, word.end);
            const tooltip =
              dnaToText && dnaToText[wordDNA]
                ? ` title="${dnaToText[wordDNA]}"`
                : "";

            // Ajouter la classe "word-trou" si le mot est sélectionné
            if (trouModeActive && selectedWordIndices.has(wordIndex)) {
              className += " word-trou";
            }

            // Ajouter l'événement de double-clic si le mode est actif
            const dataIndex = trouModeActive
              ? ` data-word-index="${wordIndex}" ondblclick="toggleWordTrou(${wordIndex})" style="cursor: pointer;"`
              : "";

            html += `<span class="${className}"${tooltip}${dataIndex}>${wordDNA}</span>`;
            lastEnd = word.end;
            wordIndex++;
          }
        }

        // Vérifier s'il y a des codons stop après le dernier mot
        for (let i = lastEnd; i <= dna.length - 3; i += 3) {
          const codon = dna.substring(i, i + 3);
          if (["TAA", "TAG", "TGA"].includes(codon)) {
            html += `<span class="word-stop" title="Point">${codon}</span>`;
            lastEnd = i + 3;
          } else {
            break; // Arrêter si on rencontre un autre codon
          }
        }

        // Ajouter le reste de la séquence (s'il y en a)
        if (lastEnd < dna.length) {
          html += `<span>${dna.substring(lastEnd)}</span>`;
        }

        return html;
      }

      // Fonction pour basculer un mot en mode "à trou"
      function toggleWordTrou(wordIndex) {
        if (!trouModeActive) return;

        if (selectedWordIndices.has(wordIndex)) {
          selectedWordIndices.delete(wordIndex);
        } else {
          selectedWordIndices.add(wordIndex);
        }

        // Réencoder pour mettre à jour l'affichage
        encodeText();
      }

      // Fonction pour afficher/cacher le label au-dessus de dnaOutput
      function updateDnaOutputLabel() {
        const output = document.getElementById("dnaOutput");
        const label = document.getElementById("dnaOutputLabel");
        if (!output || !label) return;

        const hasSequence =
          output.getAttribute("data-dna-sequence") &&
          output.getAttribute("data-dna-sequence").length > 0;
        const hasContent =
          output.innerHTML &&
          output.innerHTML.trim() !== "" &&
          !output.innerHTML.includes("Aucune séquence à afficher");

        if (hasSequence || hasContent) {
          label.style.display = "block";
        } else {
          label.style.display = "none";
        }
      }

      function encodeText() {
        const input = document.getElementById("textInput").value;
        const normalized = normalizeText(input);
        const output = document.getElementById("dnaOutput");
        let dna = "ATG";
        const wordPositions = [];
        const dnaToText = {}; // Correspondance ADN -> texte
        let currentWordStart = 3; // Après ATG
        let currentWordText = ""; // Texte du mot en cours
        let inWord = false;
        let isStartOfSentence = true; // Pour détecter le début de phrase

        for (let char of normalized) {
          let codonLength = 0;
          // Gérer les caractères spéciaux en premier (ponctuation)
          if (char === ".") {
            // Finaliser le mot actuel AVANT d'ajouter le point
            if (inWord) {
              const wordDNA = dna.substring(currentWordStart, dna.length);
              if (currentWordText) {
                dnaToText[wordDNA] = currentWordText;
              }
              wordPositions.push({
                type: "word",
                start: currentWordStart,
                end: dna.length,
              });
              inWord = false;
              currentWordText = "";
            }
            // Maintenant ajouter le point (qui ne fait pas partie du mot)
            dna += "TAA";
            // Ne pas mettre codonLength pour éviter que le point initialise un nouveau mot
            isStartOfSentence = true; // Après un point, on est au début d'une phrase
            continue; // Passer au caractère suivant sans traiter le point comme un codon de mot
          }
          // Gérer l'apostrophe (tous les types normalisés vers ')
          // Vérifier aussi directement les codes Unicode au cas où la normalisation n'a pas fonctionné
          else if (
            char === "'" ||
            char === "'" ||
            char === "'" ||
            char === "'" ||
            char.charCodeAt(0) === 0x0027 ||
            char.charCodeAt(0) === 0x2019 ||
            char.charCodeAt(0) === 0x2018
          ) {
            dna += "TTC";
            codonLength = 3;
            if (inWord) {
              currentWordText += "'";
            }
          }
          // Gérer les espaces (tous les types normalisés vers espace standard)
          // Vérifier aussi directement les codes Unicode au cas où la normalisation n'a pas fonctionné
          else if (
            char === " " ||
            char.charCodeAt(0) === 0x0020 ||
            char.charCodeAt(0) === 0x00a0 ||
            (char.charCodeAt(0) >= 0x2000 && char.charCodeAt(0) <= 0x200b) ||
            char.charCodeAt(0) === 0x202f ||
            char.charCodeAt(0) === 0x205f ||
            char.charCodeAt(0) === 0x3000
          ) {
            if (inWord) {
              // Finir le mot précédent
              const wordDNA = dna.substring(currentWordStart, dna.length);
              if (currentWordText) {
                dnaToText[wordDNA] = currentWordText;
              }
              wordPositions.push({
                type: "word",
                start: currentWordStart,
                end: dna.length,
              });
              inWord = false;
              currentWordText = "";
            }
            const spaceStart = dna.length;
            dna += "TTT";
            wordPositions.push({
              type: "space",
              start: spaceStart,
              end: dna.length,
            });
            currentWordStart = dna.length;
            continue;
          }
          // Gérer les caractères accentués (toujours en majuscule)
          else if (char === "é" || char === "É") {
            dna += "AGG"; // AGG (É)
            codonLength = 3;
            if (inWord) currentWordText += "É";
            isStartOfSentence = false;
          } else if (char === "è" || char === "È") {
            dna += "AGT"; // AGT (È)
            codonLength = 3;
            if (inWord) currentWordText += "È";
            isStartOfSentence = false;
          } else if (char === "ê" || char === "Ê") {
            dna += "ATA"; // ATA (Ê)
            codonLength = 3;
            if (inWord) currentWordText += "Ê";
            isStartOfSentence = false;
          } else if (char === "ë" || char === "Ë") {
            dna += "ATC"; // ATC (Ë)
            codonLength = 3;
            if (inWord) currentWordText += "Ë";
            isStartOfSentence = false;
          } else if (char === "ï" || char === "Ï") {
            dna += "CCG"; // CCG (Ï)
            codonLength = 3;
            if (inWord) currentWordText += "Ï";
            isStartOfSentence = false;
          }
          // Pour les autres caractères
          else {
            let upperChar = char.toUpperCase();

            if (reverseCode[upperChar]) {
              dna += reverseCode[upperChar][0];
              codonLength = 3;
              if (inWord) currentWordText += upperChar;
              isStartOfSentence = false;
            }
            // Les caractères non codables sont simplement ignorés
          }

          if (codonLength > 0) {
            if (!inWord) {
              currentWordStart = dna.length - codonLength;
              inWord = true;
              // Initialiser le texte du mot avec le premier caractère
              if (char === "é" || char === "É") {
                currentWordText = "É";
              } else if (char === "è" || char === "È") {
                currentWordText = "È";
              } else if (char === "ê" || char === "Ê") {
                currentWordText = "Ê";
              } else if (char === "ë" || char === "Ë") {
                currentWordText = "Ë";
              } else if (char === "ï" || char === "Ï") {
                currentWordText = "Ï";
              } else if (
                char === "'" ||
                char === "'" ||
                char === "'" ||
                char === "'"
              ) {
                currentWordText = "'";
              } else if (char !== ".") {
                currentWordText = char.toUpperCase();
              } else {
                currentWordText = "";
              }
            }
          }
        }

        // Ajouter le dernier mot s'il existe
        if (inWord) {
          const wordDNA = dna.substring(currentWordStart, dna.length);
          if (currentWordText) {
            dnaToText[wordDNA] = currentWordText;
          }
          wordPositions.push({
            type: "word",
            start: currentWordStart,
            end: dna.length,
          });
        }

        // Ajouter les positions des mots "à trou" à la fin de la séquence si le mode est actif
        const copyBtn = document.getElementById("copyBtn");
        const exportBtn = document.getElementById("exportBtn");

        // Stocker la séquence de base (sans marqueurs "à trou")
        output.setAttribute("data-dna-base", dna);

        // Toujours afficher la séquence ADN colorisée
        const coloredDNA = colorizeDNA(dna, wordPositions, dnaToText);

        if (selectedWordIndices.size > 0) {
          const trouPositions = encodeTrouPositions(selectedWordIndices);
          const fullSequence = dna + trouPositions;
          // Stocker la séquence complète avec les positions dans un attribut data
          output.setAttribute("data-dna-sequence", fullSequence);
          output.setAttribute("data-trou-positions", trouPositions);
          // Afficher la séquence ADN colorisée (le texte reste visible)
          output.innerHTML =
            coloredDNA ||
            '<span style="color: #666;">Aucune séquence à afficher.</span>';
          // Afficher les boutons
          copyBtn.style.display = "inline-block";
          if (exportBtn) exportBtn.style.display = "inline-block";
          // Afficher le label
          updateDnaOutputLabel();
          // Ajouter l'icône d'avion en papier pour copier vers le décodage
          addCopyToDecodeIcon(output, dna);
        } else if (trouModeActive) {
          // Mode "à trou" actif mais aucun mot sélectionné - afficher quand même la séquence
          output.setAttribute("data-dna-sequence", dna);
          output.removeAttribute("data-trou-positions");
          output.innerHTML =
            coloredDNA ||
            '<span style="color: #666;">Aucune séquence à afficher. Double-cliquez sur les mots pour les sélectionner.</span>';
          // Afficher le bouton d'export
          copyBtn.style.display = "none";
          const exportBtn = document.getElementById("exportBtn");
          if (exportBtn) exportBtn.style.display = "inline-block";
          // Afficher le label
          updateDnaOutputLabel();
          // Ajouter l'icône d'avion en papier pour copier vers le décodage
          addCopyToDecodeIcon(output, dna);
        } else {
          // Mode "à trou" désactivé
          output.setAttribute("data-dna-sequence", dna);
          output.removeAttribute("data-trou-positions");
          output.innerHTML = coloredDNA || "";
          // Afficher le bouton d'export même sans "à trou"
          copyBtn.style.display = "none";
          const exportBtn = document.getElementById("exportBtn");
          if (exportBtn) exportBtn.style.display = "inline-block";
          // Afficher le label
          updateDnaOutputLabel();
        }

        // Ajouter l'icône d'avion en papier pour copier vers le décodage
        addCopyToDecodeIcon(output, dna);
      }

      // Fonction pour supprimer l'icône d'avion en papier
      function removeCopyToDecodeIcon() {
        const dnaOutput = document.getElementById("dnaOutput");
        if (dnaOutput) {
          const existingIcon = dnaOutput.querySelector(".copy-to-decode-icon");
          if (existingIcon) {
            existingIcon.remove();
          }
        }
      }

      // Fonction pour ajouter l'icône d'avion en papier pour copier vers le décodage
      function addCopyToDecodeIcon(outputElement, dnaSequence) {
        // Supprimer l'icône existante si elle existe
        const existingIcon = outputElement.querySelector(
          ".copy-to-decode-icon"
        );
        if (existingIcon) {
          existingIcon.remove();
        }

        // Ne pas ajouter l'icône si la séquence est vide
        if (!dnaSequence || dnaSequence.trim().length === 0) {
          return;
        }

        // Créer l'icône d'avion en papier
        const icon = document.createElement("span");
        icon.className = "copy-to-decode-icon";
        icon.innerHTML = "✈️";
        icon.title = "Copier vers le bloc décodage";
        icon.style.cssText = `
          display: inline-block;
          margin-left: 10px;
          font-size: 1.2em;
          cursor: pointer;
          vertical-align: middle;
          transition: transform 0.2s;
          user-select: none;
        `;

        // Effet au survol
        icon.addEventListener("mouseenter", function () {
          icon.style.transform = "scale(1.2) rotate(15deg)";
        });

        icon.addEventListener("mouseleave", function () {
          icon.style.transform = "scale(1) rotate(0deg)";
        });

        // Gérer le clic pour copier vers le décodage
        icon.addEventListener("click", function () {
          copyToDecodeBlock(dnaSequence);
        });

        // Ajouter l'icône après le contenu
        outputElement.appendChild(icon);
      }

      // Fonction pour copier la séquence vers le bloc décodage
      function copyToDecodeBlock(dnaSequence) {
        // Vider les champs d'encodage avant de copier
        const textInput = document.getElementById("textInput");
        const dnaOutput = document.getElementById("dnaOutput");
        if (textInput) textInput.value = "";

        // Vider le champ de décodage
        const dnaInput = document.getElementById("dnaInput");
        const output = document.getElementById("output");
        if (dnaInput) {
          dnaInput.textContent = "";
          dnaInput.removeAttribute("data-full-sequence");
          dnaInput.removeAttribute("data-modified-ranges");
          dnaInput.removeAttribute("data-deleted-ranges");
        }
        if (output) {
          output.innerHTML = "";
        }

        // Copier la séquence dans le champ de décodage
        if (dnaInput && dnaSequence) {
          // Utiliser la séquence complète si disponible (avec marqueurs "à trou")
          const fullSequence =
            dnaOutput.getAttribute("data-dna-sequence") || dnaSequence;
          dnaInput.setAttribute("data-full-sequence", fullSequence);

          // Masquer les marqueurs "à trou" visuellement
          const markerIndex = fullSequence.indexOf(TROU_MARKER);
          const visibleSequence =
            markerIndex !== -1
              ? fullSequence.substring(0, markerIndex)
              : fullSequence;

          dnaInput.textContent = visibleSequence;
          colorizeDNAInput();

          // Feedback visuel
          const icon = document.querySelector(".copy-to-decode-icon");
          if (icon) {
            const originalHTML = icon.innerHTML;
            icon.innerHTML = "✓";
            icon.style.color = "#51cf66";
            setTimeout(() => {
              icon.innerHTML = originalHTML;
              icon.style.color = "";
            }, 1000);
          }
        }
      }

      // Fonction pour copier la séquence ADN avec les marqueurs "à trou"
      function copyDNAWithTrous() {
        const output = document.getElementById("dnaOutput");
        const fullSequence = output.getAttribute("data-dna-sequence");

        if (fullSequence) {
          // Copier la séquence complète (déjà avec le marqueur et les positions)
          navigator.clipboard
            .writeText(fullSequence)
            .then(() => {
              const btn = document.getElementById("copyBtn");
              const originalText = btn.textContent;
              btn.textContent = "✓ Copié !";
              btn.style.background = "#51cf66";
              setTimeout(() => {
                btn.textContent = originalText;
              }, 2000);
            })
            .catch((err) => {
              console.error("Erreur lors de la copie:", err);
              alert(
                "Erreur lors de la copie. Veuillez sélectionner manuellement la séquence."
              );
            });
        }
      }

      // Fonction pour ouvrir la modale d'import
      function openImportModal() {
        const modal = document.getElementById("importModal");
        if (modal) {
          modal.style.display = "block";
        }
      }

      // Fonction pour fermer la modale d'import
      function closeImportModal() {
        const modal = document.getElementById("importModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Fonction pour ouvrir le sélecteur de fichier selon le format choisi
      async function openImportFormat(format) {
        closeImportModal();

        // Essayer d'utiliser l'API File System Access pour ouvrir le dossier de téléchargements
        if ("showOpenFilePicker" in window) {
          try {
            const acceptTypes =
              format === "edi"
                ? { "text/plain": [".edi"] }
                : { "text/plain": [".fasta", ".fa", ".fas"] };

            const [fileHandle] = await window.showOpenFilePicker({
              types: [{ accept: acceptTypes }],
              multiple: false,
              startIn: "downloads", // Suggère le dossier de téléchargements
            });

            const file = await fileHandle.getFile();
            const event = { target: { files: [file] } };

            if (format === "edi") {
              importEDIFile(event);
            } else if (format === "fasta") {
              importFASTAFile(event);
            }
            return;
          } catch (error) {
            // Si l'utilisateur annule ou si l'API échoue, utiliser l'input file classique
            if (error.name !== "AbortError") {
              console.log(
                "API File System Access non disponible, utilisation de l'input file classique"
              );
            }
          }
        }

        // Fallback : utiliser l'input file classique
        if (format === "edi") {
          document.getElementById("ediFileInput").click();
        } else if (format === "fasta") {
          document.getElementById("fastaFileInput").click();
        }
      }

      // Fonction pour ouvrir la modale d'export
      function openExportModal() {
        const modal = document.getElementById("exportModal");
        if (modal) {
          modal.style.display = "block";
        }
      }

      // Fonction pour fermer la modale d'export
      function closeExportModal() {
        const modal = document.getElementById("exportModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Fonction pour exporter selon le format choisi
      function openExportFormat(format) {
        closeExportModal();
        // Ouvrir la modale de sauvegarde avec le format choisi
        openSaveFileModal(format);
      }

      // Variables globales pour la sauvegarde
      let currentExportFormat = "fasta";
      let selectedDirectoryHandle = null;

      // Fonction pour ouvrir la modale de sauvegarde
      function openSaveFileModal(format = "fasta") {
        currentExportFormat = format;
        const modal = document.getElementById("saveFileModal");
        const fileNameInput = document.getElementById("fileNameInput");
        const fileExtensionInfo = document.getElementById("fileExtensionInfo");

        if (!modal || !fileNameInput || !fileExtensionInfo) return;

        // Définir le nom de fichier par défaut selon le format
        const defaultName =
          format === "edi" ? "sequence_encodée" : "sequence_encodée";
        fileNameInput.value = defaultName;
        fileExtensionInfo.textContent = `Extension : .${format}`;

        // Réinitialiser le répertoire sélectionné
        selectedDirectoryHandle = null;
        const directoryInfo = document.getElementById("directoryInfo");
        if (directoryInfo) {
          if ("showDirectoryPicker" in window) {
            directoryInfo.textContent =
              "Le fichier sera téléchargé dans le répertoire par défaut de votre navigateur. Cliquez sur 'Choisir le répertoire' pour sélectionner un emplacement.";
          } else {
            directoryInfo.textContent =
              "Le fichier sera téléchargé dans le répertoire par défaut de votre navigateur. Le choix de répertoire n'est pas disponible dans votre navigateur.";
          }
        }

        // Désactiver le bouton de choix de répertoire si l'API n'est pas disponible
        const chooseDirectoryBtn =
          document.getElementById("chooseDirectoryBtn");
        if (chooseDirectoryBtn) {
          if ("showDirectoryPicker" in window) {
            chooseDirectoryBtn.disabled = false;
            chooseDirectoryBtn.style.opacity = "1";
            chooseDirectoryBtn.style.cursor = "pointer";
          } else {
            chooseDirectoryBtn.disabled = true;
            chooseDirectoryBtn.style.opacity = "0.5";
            chooseDirectoryBtn.style.cursor = "not-allowed";
          }
        }

        modal.style.display = "block";
        // Focus sur le champ de nom de fichier
        setTimeout(() => {
          fileNameInput.focus();
          fileNameInput.select();
        }, 100);
      }

      // Fonction pour fermer la modale de sauvegarde
      function closeSaveFileModal() {
        const modal = document.getElementById("saveFileModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Fonction pour choisir le répertoire (API File System Access)
      async function chooseDirectory() {
        try {
          // Vérifier si l'API est disponible (Chrome/Edge)
          if ("showDirectoryPicker" in window) {
            const directoryHandle = await window.showDirectoryPicker();
            selectedDirectoryHandle = directoryHandle;
            const directoryInfo = document.getElementById("directoryInfo");
            if (directoryInfo) {
              directoryInfo.textContent = `Répertoire sélectionné : ${directoryHandle.name}`;
            }
          } else {
            alert(
              "Le choix de répertoire n'est pas disponible dans votre navigateur. Le fichier sera téléchargé dans le répertoire par défaut."
            );
          }
        } catch (error) {
          // L'utilisateur a annulé la sélection
          if (error.name !== "AbortError") {
            console.error("Erreur lors de la sélection du répertoire:", error);
          }
        }
      }

      // Fonction pour confirmer la sauvegarde
      async function confirmSaveFile() {
        const fileNameInput = document.getElementById("fileNameInput");
        if (!fileNameInput) return;

        let fileName = fileNameInput.value.trim();
        if (!fileName) {
          alert("Veuillez entrer un nom de fichier.");
          return;
        }

        // Nettoyer le nom de fichier (enlever les caractères invalides)
        fileName = fileName.replace(/[<>:"/\\|?*]/g, "_");

        // Ajouter l'extension si elle n'est pas présente
        if (!fileName.endsWith("." + currentExportFormat)) {
          fileName += "." + currentExportFormat;
        }

        // Fermer la modale
        closeSaveFileModal();

        // Exporter le fichier
        if (currentExportFormat === "edi") {
          await exportEDIFile(fileName);
        } else if (currentExportFormat === "fasta") {
          await exportFASTAFile(fileName);
        }
      }

      // Fonction pour exporter la séquence ADN en format .edi
      // Fonction utilitaire pour télécharger un fichier (compatible mobile et desktop)
      function downloadFile(blob, fileName) {
        const isMobile =
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ) || window.innerWidth <= 768;
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.setAttribute("download", fileName);

        if (isMobile) {
          // Pour mobile : utiliser une approche plus compatible
          link.style.position = "fixed";
          link.style.top = "-1000px";
          link.style.left = "-1000px";
          link.style.opacity = "0";
        } else {
          // Pour desktop : méthode standard
          link.style.display = "none";
          link.style.visibility = "hidden";
        }

        document.body.appendChild(link);

        // Déclencher le téléchargement avec plusieurs méthodes pour compatibilité maximale
        try {
          link.click();
        } catch (e) {
          // Si click() ne fonctionne pas, essayer avec un événement de souris
          const clickEvent = new MouseEvent("click", {
            view: window,
            bubbles: true,
            cancelable: true,
          });
          link.dispatchEvent(clickEvent);
        }

        // Nettoyer après un délai (plus long pour mobile)
        setTimeout(
          () => {
            if (document.body.contains(link)) {
              document.body.removeChild(link);
            }
            URL.revokeObjectURL(url);
          },
          isMobile ? 1000 : 100
        );
      }

      async function exportEDIFile(fileName = "sequence_encodée.edi") {
        const output = document.getElementById("dnaOutput");
        const fullSequence = output.getAttribute("data-dna-sequence");

        if (!fullSequence) {
          alert(
            "Aucune séquence à exporter. Veuillez d'abord encoder un texte."
          );
          return;
        }

        // Format .edi : format simple avec la séquence ADN (peut être réimporté)
        // On exporte juste la séquence ADN, le format .edi sera reconnu par l'import
        const ediFile = fullSequence;

        // Télécharger directement (compatible mobile/tablette, pas de message d'avertissement)
        const blob = new Blob([ediFile], { type: "text/plain;charset=utf-8;" });
        downloadFile(blob, fileName);
      }

      // Fonction pour exporter la séquence ADN en format .fasta
      async function exportFASTAFile(fileName = "sequence_encodée.fasta") {
        const output = document.getElementById("dnaOutput");
        const fullSequence = output.getAttribute("data-dna-sequence");

        if (!fullSequence) {
          alert(
            "Aucune séquence à exporter. Veuillez d'abord encoder un texte."
          );
          return;
        }

        // Format FASTA : en-tête suivi de la séquence (60 caractères par ligne)
        const fastaContent = `>Sequence_ADN_encodee\n`;
        const sequenceLines = fullSequence.match(/.{1,60}/g) || [fullSequence];
        const fastaFile = fastaContent + sequenceLines.join("\n") + "\n";

        // Télécharger directement (compatible mobile/tablette, pas de message d'avertissement)
        const blob = new Blob([fastaFile], {
          type: "text/plain;charset=utf-8;",
        });
        downloadFile(blob, fileName);
      }

      // Fonction pour ouvrir la modale d'export du décodage
      function openDecodeExportModal() {
        const modal = document.getElementById("decodeExportModal");
        if (modal) {
          modal.style.display = "block";
        }
      }

      // Fonction pour fermer la modale d'export du décodage
      function closeDecodeExportModal() {
        const modal = document.getElementById("decodeExportModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Fonction pour exporter la séquence de décodage en format .edi avec mutations
      async function exportDecodeEDIFile(fileName = "sequence_decodee.edi") {
        const dnaInput = document.getElementById("dnaInput");
        if (!dnaInput) {
          alert("Aucune séquence à exporter. Veuillez d'abord importer une séquence.");
          return;
        }

        let fullSequence = dnaInput.getAttribute("data-full-sequence");
        if (!fullSequence) {
          fullSequence = dnaInput.innerText || dnaInput.textContent || "";
        }

        if (!fullSequence) {
          alert("Aucune séquence à exporter. Veuillez d'abord importer une séquence.");
          return;
        }

        // Récupérer les mutations
        const modifiedRanges = JSON.parse(
          dnaInput.getAttribute("data-modified-ranges") || "[]"
        );
        const deletedRanges = JSON.parse(
          dnaInput.getAttribute("data-deleted-ranges") || "[]"
        );

        // Format .edi : séquence ADN avec métadonnées JSON en commentaire
        // Le format est compatible : séquence ADN suivie d'un commentaire JSON
        const ediFile = fullSequence + "\n#MUTATIONS:" + JSON.stringify({modified: modifiedRanges, deleted: deletedRanges});

        // Télécharger directement
        const blob = new Blob([ediFile], { type: "text/plain;charset=utf-8;" });
        downloadFile(blob, fileName);
        closeDecodeExportModal();
      }

      // Fonction pour exporter la séquence de décodage en format .fasta avec mutations
      async function exportDecodeFASTAFile(fileName = "sequence_decodee.fasta") {
        const dnaInput = document.getElementById("dnaInput");
        if (!dnaInput) {
          alert("Aucune séquence à exporter. Veuillez d'abord importer une séquence.");
          return;
        }

        let fullSequence = dnaInput.getAttribute("data-full-sequence");
        if (!fullSequence) {
          fullSequence = dnaInput.innerText || dnaInput.textContent || "";
        }

        if (!fullSequence) {
          alert("Aucune séquence à exporter. Veuillez d'abord importer une séquence.");
          return;
        }

        // Récupérer les mutations
        const modifiedRanges = JSON.parse(
          dnaInput.getAttribute("data-modified-ranges") || "[]"
        );
        const deletedRanges = JSON.parse(
          dnaInput.getAttribute("data-deleted-ranges") || "[]"
        );

        // Format FASTA : en-tête avec métadonnées JSON, puis séquence (60 caractères par ligne)
        const mutationsJson = JSON.stringify({modified: modifiedRanges, deleted: deletedRanges});
        const fastaContent = `>Sequence_ADN_decodee mutations=${mutationsJson}\n`;
        const sequenceLines = fullSequence.match(/.{1,60}/g) || [fullSequence];
        const fastaFile = fastaContent + sequenceLines.join("\n") + "\n";

        // Télécharger directement
        const blob = new Blob([fastaFile], {
          type: "text/plain;charset=utf-8;",
        });
        downloadFile(blob, fileName);
        closeDecodeExportModal();
      }

      // Fonction pour remplir le tableau de code génétique
      function populateCodeTable() {
        const tbody = document.getElementById("codeTable");
        if (!tbody) return; // Si le tbody n'existe pas encore, sortir

        // Vider le tbody avant de le remplir pour éviter les doublons
        tbody.innerHTML = "";

        const entries = Object.entries(geneticCode)
          .filter(([k, v]) => v !== "START")
          .sort(([a], [b]) => a.localeCompare(b));

        // Organiser en 4 colonnes, remplir verticalement (colonne par colonne)
        const numColumns = 4; // 4 colonnes de paires Codon/Symbole
        const entriesPerColumn = Math.ceil(entries.length / numColumns);

        // Créer toutes les lignes nécessaires avec toutes les cellules vides
        const rows = [];
        for (let i = 0; i < entriesPerColumn; i++) {
          const row = document.createElement("tr");
          // Créer 8 cellules vides (4 paires Codon/Symbole)
          for (let j = 0; j < numColumns * 2; j++) {
            const cell = document.createElement("td");
            row.appendChild(cell);
          }
          rows.push(row);
          tbody.appendChild(row);
        }

        // Remplir colonne par colonne (verticalement)
        // Colonne 0 : entrées 0, 1, 2, 3, ...
        // Colonne 1 : entrées entriesPerColumn, entriesPerColumn+1, ...
        // Colonne 2 : entrées 2*entriesPerColumn, 2*entriesPerColumn+1, ...
        // Colonne 3 : entrées 3*entriesPerColumn, 3*entriesPerColumn+1, ...
        entries.forEach(([codon, symbol], index) => {
          // Calculer la colonne et la ligne pour un remplissage vertical
          const columnIndex = Math.floor(index / entriesPerColumn);
          const rowIndex = index % entriesPerColumn;

          // S'assurer qu'on ne dépasse pas le nombre de colonnes
          if (columnIndex >= numColumns) return;

          const row = rows[rowIndex];

          // Trouver la position dans la ligne (chaque colonne = 2 cellules : Codon + Symbole)
          const codonCellIndex = columnIndex * 2;
          const symbolCellIndex = codonCellIndex + 1;

          // Remplir les cellules
          row.cells[codonCellIndex].textContent = codon;
          row.cells[symbolCellIndex].textContent = symbol;

          // Colorer les codons stop en rose pastel
          if (["TAA", "TAG", "TGA"].includes(codon)) {
            row.cells[codonCellIndex].style.backgroundColor = "#ffb3d9";
            row.cells[symbolCellIndex].style.backgroundColor = "#ffb3d9";
          }
        });
      }

      // Appeler la fonction au chargement du DOM (sera appelée aussi dans le gestionnaire DOMContentLoaded global)

      // Coloriser le textarea de décodage en temps réel
      const dnaInput = document.getElementById("dnaInput");
      
      // Empêcher la sélection automatique de tout le texte sur mobile en mode mutation
      let touchStartTime = 0;
      let touchStartX = 0;
      let touchStartY = 0;
      let hasMoved = false;
      let preventAutoSelect = false;
      let lastTouchX = 0;
      let lastTouchY = 0;
      
      // Détecter le début du toucher
      dnaInput.addEventListener("touchstart", function (e) {
        if (mutationModeActive) {
          touchStartTime = Date.now();
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          lastTouchX = touchStartX;
          lastTouchY = touchStartY;
          hasMoved = false;
          preventAutoSelect = true;
          
          // Supprimer toute sélection existante immédiatement
          const selection = window.getSelection();
          selection.removeAllRanges();
          
          // Empêcher le comportement par défaut de sélection
          e.preventDefault();
        }
      }, { passive: false });
      
      // Détecter le mouvement (drag) - si l'utilisateur fait glisser, c'est une sélection manuelle
      dnaInput.addEventListener("touchmove", function (e) {
        if (mutationModeActive) {
          const touch = e.touches[0];
          lastTouchX = touch.clientX;
          lastTouchY = touch.clientY;
          const deltaX = Math.abs(touch.clientX - touchStartX);
          const deltaY = Math.abs(touch.clientY - touchStartY);
          // Si l'utilisateur a bougé de plus de 3px, c'est un drag (sélection manuelle)
          if (deltaX > 3 || deltaY > 3) {
            hasMoved = true;
            preventAutoSelect = false;
          }
        }
      }, { passive: true });
      
      // Fonction pour sélectionner 3 nucléotides autour d'une position
      function selectTripletAtPosition(clickX, clickY) {
        const fullText = dnaInput.innerText || dnaInput.textContent || "";
        if (fullText.length === 0) return false;
        
        // Trouver la position du toucher dans le texte
        let clickPosition = -1;
        
        // Essayer d'utiliser caretRangeFromPoint pour trouver la position
        if (document.caretRangeFromPoint && clickX !== undefined && clickY !== undefined) {
          try {
            const range = document.caretRangeFromPoint(clickX, clickY);
            if (range && dnaInput.contains(range.commonAncestorContainer)) {
              // Calculer la position dans le texte
              const preRange = range.cloneRange();
              preRange.selectNodeContents(dnaInput);
              preRange.setEnd(range.startContainer, range.startOffset);
              clickPosition = preRange.toString().length;
            }
          } catch (err) {
            console.log("Erreur caretRangeFromPoint:", err);
          }
        }
        
        // Si on n'a pas pu trouver la position, utiliser le milieu de la séquence
        if (clickPosition < 0) {
          clickPosition = Math.floor(fullText.length / 2);
        }
        
        // Calculer la position de départ pour sélectionner 3 nucléotides
        // On veut sélectionner autour du point de clic, donc commencer 1 caractère avant si possible
        let startPos = Math.max(0, clickPosition - 1);
        let endPos = Math.min(fullText.length, startPos + 3);
        
        // Ajuster si on est trop près de la fin
        if (endPos - startPos < 3) {
          startPos = Math.max(0, endPos - 3);
        }
        
        // Trouver les nœuds texte dans dnaInput
        const walker = document.createTreeWalker(
          dnaInput,
          NodeFilter.SHOW_TEXT,
          null,
          false
        );
        let node;
        let currentPos = 0;
        let startNode = null;
        let startOffset = 0;
        let endNode = null;
        let endOffset = 0;
        
        while ((node = walker.nextNode())) {
          const nodeText = node.textContent;
          const nodeLength = nodeText.length;
          
          // Vérifier si startPos est dans ce nœud
          if (currentPos <= startPos && startPos < currentPos + nodeLength) {
            startNode = node;
            startOffset = startPos - currentPos;
          }
          
          // Vérifier si endPos est dans ce nœud
          if (currentPos <= endPos && endPos <= currentPos + nodeLength) {
            endNode = node;
            endOffset = endPos - currentPos;
            break;
          }
          
          currentPos += nodeLength;
        }
        
        // Créer la sélection
        if (startNode && endNode) {
          const selection = window.getSelection();
          selection.removeAllRanges();
          const newRange = document.createRange();
          newRange.setStart(startNode, startOffset);
          newRange.setEnd(endNode, endOffset);
          selection.addRange(newRange);
          return true;
        }
        return false;
      }
      
      // Sur touchend, gérer la sélection selon la durée du toucher
      dnaInput.addEventListener("touchend", function (e) {
        if (mutationModeActive) {
          const touchDuration = Date.now() - touchStartTime;
          const touch = e.changedTouches[0];
          
          // Si c'était un toucher court (< 300ms) sans mouvement, sélectionner 3 nucléotides
          if (preventAutoSelect && !hasMoved && touchDuration < 300) {
            e.preventDefault();
            
            // Sélectionner 3 nucléotides autour du point de clic
            setTimeout(function() {
              selectTripletAtPosition(touch.clientX, touch.clientY);
            }, 10);
          } else if (hasMoved) {
            // Si l'utilisateur a fait glisser, laisser la sélection manuelle
            // Ne rien faire, la sélection manuelle est déjà en place
          } else if (touchDuration >= 300 && touchDuration < 1000) {
            // Appui prolongé moyen : permettre la sélection manuelle
            // Ne rien faire, laisser le navigateur gérer
          } else {
            // Appui très long : empêcher la sélection complète automatique
            e.preventDefault();
            const selection = window.getSelection();
            const fullText = dnaInput.innerText || dnaInput.textContent || "";
            if (selection.rangeCount > 0) {
              const selectedText = selection.toString();
              if (selectedText === fullText && fullText.length > 0) {
                selection.removeAllRanges();
                // Sélectionner autour du point de toucher
                selectTripletAtPosition(touch.clientX, touch.clientY);
              }
            }
          }
        }
        preventAutoSelect = false;
        hasMoved = false;
      }, { passive: false });
      
      // Handler selectionchange pour détecter immédiatement les sélections complètes automatiques
      // et les remplacer par une sélection de 3 nucléotides
      let selectionChangeHandler = function() {
        if (mutationModeActive) {
          const selection = window.getSelection();
          if (selection.rangeCount > 0) {
            const fullText = dnaInput.innerText || dnaInput.textContent || "";
            const selectedText = selection.toString();
            const touchDuration = Date.now() - touchStartTime;
            
            // Si toute la séquence est sélectionnée automatiquement (sans drag)
            if (selectedText === fullText && fullText.length > 0 && !hasMoved) {
              // Pour les appuis courts, sélectionner 3 nucléotides
              if (touchDuration < 300) {
                setTimeout(function() {
                  const currentSelection = window.getSelection();
                  const currentText = currentSelection.toString();
                  if (currentText === fullText) {
                    selectTripletAtPosition(lastTouchX, lastTouchY);
                  }
                }, 10);
              } else {
                // Pour les appuis prolongés, supprimer la sélection complète
                // L'utilisateur pourra alors faire une sélection manuelle
                setTimeout(function() {
                  const currentSelection = window.getSelection();
                  const currentText = currentSelection.toString();
                  if (currentText === fullText) {
                    currentSelection.removeAllRanges();
                  }
                }, 10);
              }
            }
          }
        }
      };
      
      // Ajouter le handler selectionchange (mais seulement s'il n'existe pas déjà)
      if (!window.mobileSelectionChangeHandlerAdded) {
        document.addEventListener("selectionchange", selectionChangeHandler);
        window.mobileSelectionChangeHandlerAdded = true;
      }
      
      dnaInput.addEventListener("input", function () {
        setTimeout(colorizeDNAInput, 10);
      });
      dnaInput.addEventListener("paste", function () {
        // Vider les champs d'encodage lors du collage dans le champ de décodage
        const textInput = document.getElementById("textInput");
        const dnaOutput = document.getElementById("dnaOutput");
        if (textInput) textInput.value = "";
        if (dnaOutput) {
          dnaOutput.textContent = "";
          dnaOutput.removeAttribute("data-dna-sequence");
        }
        setTimeout(colorizeDNAInput, 10); // Attendre que le collage soit terminé
      });

      // Gestion du menu contextuel pour les modifications de séquence
      let contextMenu = document.getElementById("contextMenu");
      let selectedRange = null;
      let selectedText = "";
      let selectedStart = 0;
      let selectedEnd = 0;
      let mutationModeActive = false;

      // S'assurer que contextMenu est disponible
      if (!contextMenu) {
        console.error("contextMenu n'a pas été trouvé dans le DOM!");
      }

      // Fonction pour activer/désactiver le mode mutation
      function toggleMutationMode() {
        mutationModeActive = !mutationModeActive;
        const mutationBtn = document.getElementById("mutationBtn");
        console.log(
          "toggleMutationMode appelé, mutationModeActive:",
          mutationModeActive
        );

        if (mutationModeActive) {
          mutationBtn.style.background = "#51cf66";
          mutationBtn.textContent = "Mutation (ON)";
          // Ajouter un style visuel pour indiquer que le mode est actif
          dnaInput.style.cursor = "crosshair";
          // Permettre la sélection dans les spans avec arrière-plan rose
          const decodeSpans = dnaInput.querySelectorAll('.decode-dna');
          decodeSpans.forEach(span => {
            span.style.userSelect = 'text';
            span.style.webkitUserSelect = 'text';
            span.style.mozUserSelect = 'text';
            span.style.msUserSelect = 'text';
            span.style.pointerEvents = 'auto';
          });
          console.log("Mode mutation activé");
        } else {
          mutationBtn.style.background = "#ff6b6b";
          mutationBtn.textContent = "Mutation";
          if (contextMenu) {
            contextMenu.style.display = "none";
          }
          dnaInput.style.cursor = "text";
          // Restaurer user-select: none pour les spans (mais on garde text car on a changé le HTML)
          console.log("Mode mutation désactivé");
        }
      }

      // Fonction pour obtenir la sélection dans un élément contenteditable
      function getSelectionInEditable(element) {
        const selection = window.getSelection();
        if (selection.rangeCount === 0) return null;

        const range = selection.getRangeAt(0);

        // Vérifier si la sélection est dans l'élément
        let container = range.commonAncestorContainer;
        while (container && container !== element) {
          if (
            container.nodeType === Node.ELEMENT_NODE &&
            container.isContentEditable
          ) {
            // C'est un élément contenteditable parent, vérifier s'il contient notre élément
            if (!container.contains(element)) {
              return null;
            }
          }
          container = container.parentNode;
        }

        if (
          !element.contains(range.commonAncestorContainer) &&
          !range.commonAncestorContainer.contains(element)
        ) {
          return null;
        }

        // Créer une nouvelle plage pour éviter les problèmes
        const newRange = range.cloneRange();
        newRange.setStart(range.startContainer, range.startOffset);
        newRange.setEnd(range.endContainer, range.endOffset);

        // Obtenir le texte brut de la sélection (sans HTML)
        const text = newRange.toString();
        if (!text || text.trim().length === 0) return null;

        // Obtenir les positions dans le texte complet (texte brut sans HTML)
        const elementText = element.innerText || element.textContent || "";
        const preRange = newRange.cloneRange();
        preRange.selectNodeContents(element);
        preRange.setEnd(range.startContainer, range.startOffset);
        const start = preRange.toString().length;

        return {
          range: newRange,
          text: text,
          start: start,
          end: start + text.length,
        };
      }

      // Fonction pour obtenir le texte brut d'un élément contenteditable
      function getPlainText(element) {
        return element.innerText || element.textContent || "";
      }

      // Fonction pour obtenir les positions dans le texte brut
      function getTextPositions(element, range) {
        const text = getPlainText(element);
        const preRange = range.cloneRange();
        preRange.selectNodeContents(element);
        preRange.setEnd(range.startContainer, range.startOffset);
        const start = preRange.toString().length;
        const selectedText = range.toString();
        return {
          start: start,
          end: start + selectedText.length,
          text: selectedText,
        };
      }

      // Fonction pour obtenir la position du clic dans le texte
      function getClickPosition(element, e) {
        let range = null;

        // Essayer d'obtenir la position du clic
        if (document.caretRangeFromPoint) {
          range = document.caretRangeFromPoint(e.clientX, e.clientY);
        } else if (document.caretPositionFromPoint) {
          const caretPos = document.caretPositionFromPoint(
            e.clientX,
            e.clientY
          );
          if (caretPos) {
            range = document.createRange();
            range.setStart(caretPos.offsetNode, caretPos.offset);
            range.setEnd(caretPos.offsetNode, caretPos.offset);
          }
        } else {
          // Fallback : utiliser la sélection actuelle
          const selection = window.getSelection();
          if (selection.rangeCount > 0) {
            range = selection.getRangeAt(0).cloneRange();
          }
        }

        if (!range) {
          return null;
        }

        // Vérifier que le clic est dans l'élément
        if (!element.contains(range.commonAncestorContainer)) {
          return null;
        }

        // Obtenir la position dans le texte
        const preRange = range.cloneRange();
        preRange.selectNodeContents(element);
        preRange.setEnd(range.startContainer, range.startOffset);
        const position = preRange.toString().length;

        return position;
      }

      // Fonction pour sélectionner un nucléotide ou un triplet à la position donnée
      function selectNucleotideAtPosition(element, position) {
        const text = getPlainText(element);
        if (position < 0 || position >= text.length) return null;

        // Nettoyer le texte pour ne garder que les nucléotides valides
        const cleanedText = text.toUpperCase().replace(/[^ATCG]/g, "");
        if (cleanedText.length === 0) return null;

        // Compter les nucléotides valides jusqu'à la position
        let cleanedPos = 0;
        let rawPos = 0;
        for (let i = 0; i < text.length && i < position; i++) {
          const char = text[i].toUpperCase();
          if (char === "A" || char === "T" || char === "C" || char === "G") {
            cleanedPos++;
          }
          rawPos++;
        }

        // Trouver le triplet qui contient cette position (en position nettoyée)
        const tripletIndex = Math.floor(cleanedPos / 3);
        const tripletStartInCleaned = tripletIndex * 3;
        const tripletEndInCleaned = Math.min(
          tripletStartInCleaned + 3,
          cleanedText.length
        );

        // Convertir les positions nettoyées en positions brutes
        let rawStart = 0;
        let rawEnd = text.length;
        let currentCleanedPos = 0;

        for (let i = 0; i < text.length; i++) {
          const char = text[i].toUpperCase();
          if (char === "A" || char === "T" || char === "C" || char === "G") {
            if (currentCleanedPos === tripletStartInCleaned) {
              rawStart = i;
            }
            if (currentCleanedPos === tripletEndInCleaned) {
              rawEnd = i;
              break;
            }
            currentCleanedPos++;
          }
        }

        // Extraire le triplet
        const selectedText = cleanedText.substring(
          tripletStartInCleaned,
          tripletEndInCleaned
        );

        if (selectedText.length === 0) {
          return null;
        }

        return {
          start: rawStart,
          end: rawEnd,
          text: selectedText,
        };
      }

      // Fonction pour afficher le menu de mutation quand une sélection est faite
      function showMutationMenuForSelection(e) {
        console.log(
          "showMutationMenuForSelection appelée, mutationModeActive:",
          mutationModeActive
        );

        if (!mutationModeActive) {
          console.log("Mode mutation non actif, retour");
          return; // Ne rien faire si le mode mutation n'est pas actif
        }

        // Attendre un peu pour que la sélection soit complète
        setTimeout(function () {
          // Capturer la sélection
          const selection = window.getSelection();
          console.log(
            "showMutationMenuForSelection - selection:",
            selection.toString()
          );
          console.log(
            "showMutationMenuForSelection - rangeCount:",
            selection.rangeCount
          );

          if (
            selection.rangeCount === 0 ||
            selection.toString().trim().length === 0
          ) {
            console.log("Pas de sélection détectée");
            return; // Pas de sélection
          }

          // Vérifier que la sélection est dans dnaInput
          const range = selection.getRangeAt(0).cloneRange(); // Cloner pour préserver la sélection
          if (!dnaInput.contains(range.commonAncestorContainer)) {
            console.log("La sélection n'est pas dans dnaInput");
            return; // La sélection n'est pas dans dnaInput
          }

          console.log(
            "Sélection détectée dans dnaInput:",
            selection.toString()
          );
          // Utiliser la sélection capturée au lieu de la re-obtenir
          // Obtenir les informations de sélection à partir de la range capturée
          const selectionText = range.toString();
          if (!selectionText || selectionText.trim().length === 0) {
            console.log("selectionText est vide");
            return;
          }

          // Calculer les positions dans le texte visible
          const preRange = range.cloneRange();
          preRange.selectNodeContents(dnaInput);
          preRange.setEnd(range.startContainer, range.startOffset);
          const visibleStart = preRange.toString().length;
          const visibleEnd = visibleStart + selectionText.length;

          console.log("Positions visibles:", visibleStart, visibleEnd);

          // Obtenir le texte brut depuis data-full-sequence
          let plainText = dnaInput.getAttribute("data-full-sequence");
          if (!plainText) {
            plainText = dnaInput.innerText || dnaInput.textContent || "";
          }

          // Nettoyer pour ne garder que les nucléotides
          const cleanedText = plainText.toUpperCase().replace(/[^ATCG]/g, "");
          if (cleanedText.length === 0) {
            return;
          }

          // Convertir les positions visibles en positions dans plainText
          // On va chercher le texte sélectionné dans plainText
          const selectedTextInVisible = selectionText;
          const visibleText = dnaInput.innerText || dnaInput.textContent || "";

          // Trouver la position de la sélection dans visibleText
          const textBeforeSelection = visibleText.substring(0, visibleStart);

          // Compter les caractères dans plainText jusqu'à la position correspondante dans visibleText
          let plainTextPos = 0;
          let visibleTextPos = 0;

          while (
            plainTextPos < plainText.length &&
            visibleTextPos < visibleStart
          ) {
            const plainChar = plainText[plainTextPos];
            // Vérifier si ce caractère correspond à un caractère dans visibleText
            if (
              visibleTextPos < visibleText.length &&
              visibleText[visibleTextPos] === plainChar
            ) {
              visibleTextPos++;
            }
            plainTextPos++;
          }
          cleanedStart = plainTextPos;

          // Trouver la fin
          visibleTextPos = visibleStart;
          while (
            plainTextPos < plainText.length &&
            visibleTextPos < visibleEnd
          ) {
            const plainChar = plainText[plainTextPos];
            if (
              visibleTextPos < visibleText.length &&
              visibleText[visibleTextPos] === plainChar
            ) {
              visibleTextPos++;
            }
            plainTextPos++;
          }
          cleanedEnd = plainTextPos;

          // Extraire la sélection nettoyée
          const selectedTextValue = plainText
            .substring(cleanedStart, cleanedEnd)
            .toUpperCase()
            .replace(/[^ATCG]/g, "");

          if (selectedTextValue.length === 0) {
            console.log("selectedTextValue est vide après nettoyage");
            return;
          }

          // Stocker les informations de sélection
          selectedText = selectedTextValue;
          selectedStart = cleanedStart;
          selectedEnd = cleanedEnd;
          selectedRange = range;

          console.log(
            "Affichage du menu pour:",
            selectedTextValue,
            "positions:",
            cleanedStart,
            cleanedEnd
          );

          // Afficher le menu
          displayMutationMenu(e, selectedTextValue, cleanedStart, cleanedEnd);
        }, 100); // Petit délai pour s'assurer que la sélection est complète
      }

      // Fonction pour afficher le menu de mutation
      function displayMutationMenu(e, selectedTextValue, startPos, endPos) {
        // Ré-obtenir contextMenu au cas où il n'était pas disponible
        if (!contextMenu) {
          contextMenu = document.getElementById("contextMenu");
        }
        if (!contextMenu) {
          console.error("contextMenu n'existe pas!");
          return;
        }

        // Stocker les valeurs
        selectedText = selectedTextValue;
        selectedStart = startPos;
        selectedEnd = endPos;

        // Déplacer le menu dans le body si nécessaire
        if (contextMenu.parentNode !== document.body) {
          document.body.appendChild(contextMenu);
        }

        // Positionner le menu juste au-dessus de la sélection
        let menuX, menuY;
        const selection = window.getSelection();
        console.log(
          "displayMutationMenu - selection.rangeCount:",
          selection.rangeCount
        );

        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          const rect = range.getBoundingClientRect();
          
          // Détecter si on est sur mobile
          const isMobile = window.innerWidth <= 768;
          
          // Positionner le menu au-dessus de la sélection (centré horizontalement, 10px au-dessus)
          menuX = rect.left + rect.width / 2 - 90; // Centrer le menu (menuWidth/2 = 90)
          
          if (isMobile) {
            // Sur mobile, positionner le menu en dessous de la sélection pour éviter qu'il soit hors écran
            menuY = rect.bottom + 10; // 10px en dessous de la sélection
            // Faire défiler pour que la sélection soit visible (centrer la sélection dans la vue)
            setTimeout(() => {
              if (rect.top < window.scrollY || rect.bottom > window.scrollY + window.innerHeight) {
                const element = range.commonAncestorContainer.nodeType === Node.TEXT_NODE 
                  ? range.commonAncestorContainer.parentElement 
                  : range.commonAncestorContainer;
                if (element) {
                  element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
              }
            }, 100);
          } else {
            menuY = rect.top - 150; // 150px au-dessus de la sélection pour laisser de la place
          }

          console.log(
            "Position du menu calculée:",
            menuX,
            menuY,
            "rect:",
            rect,
            "isMobile:",
            isMobile
          );
        } else if (e && e.clientX !== undefined) {
          const isMobile = window.innerWidth <= 768;
          menuX = e.clientX - 90;
          menuY = isMobile ? e.clientY + 10 : e.clientY - 150;
        } else {
          menuX = window.innerWidth / 2 - 90;
          menuY = window.innerHeight / 2;
        }

        // Vérifier que le menu ne dépasse pas les bords
        const menuWidth = 180;
        const menuHeight = 142;
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        if (menuX + menuWidth > windowWidth) {
          menuX = windowWidth - menuWidth - 10;
        }
        if (menuY + menuHeight > windowHeight) {
          menuY = windowHeight - menuHeight - 10;
        }
        if (menuX < 10) {
          menuX = 10;
        }
        if (menuY < 10) {
          menuY = 10;
        }

        // Afficher le menu
        console.log("Affichage du menu à la position:", menuX, menuY);
        contextMenu.style.display = "block";
        contextMenu.style.position = "fixed";
        contextMenu.style.left = menuX + "px";
        contextMenu.style.top = menuY + "px";
        contextMenu.style.visibility = "visible";
        contextMenu.style.opacity = "1";
        contextMenu.style.zIndex = "99999";
        contextMenu.style.backgroundColor = "white";
        contextMenu.style.border = "2px solid #333";
        contextMenu.style.pointerEvents = "auto";

        // Vérifier que le menu est bien visible
        console.log(
          "Menu affiché - display:",
          contextMenu.style.display,
          "left:",
          contextMenu.style.left,
          "top:",
          contextMenu.style.top
        );
        console.log(
          "Menu computed style:",
          window.getComputedStyle(contextMenu).display
        );
      }

      // Gérer la sélection pour afficher le menu de mutation
      // Vérifier que dnaInput existe avant d'ajouter les listeners
      if (dnaInput) {
        console.log("Ajout des listeners mouseup/touchend sur dnaInput");

        // Sur PC : mouseup
        dnaInput.addEventListener(
          "mouseup",
          function (e) {
            console.log(
              "mouseup détecté dans dnaInput, mutationModeActive:",
              mutationModeActive
            );
            if (mutationModeActive) {
              showMutationMenuForSelection(e);
            }
          },
          true
        ); // Utiliser capture pour intercepter avant les autres handlers

        // Sur mobile/tablette : touchend
        dnaInput.addEventListener(
          "touchend",
          function (e) {
            console.log(
              "touchend détecté dans dnaInput, mutationModeActive:",
              mutationModeActive
            );
            if (mutationModeActive) {
              showMutationMenuForSelection(e);
            }
          },
          true
        );
      } else {
        console.error(
          "dnaInput n'existe pas au moment de l'ajout des listeners!"
        );
      }

      // Aussi écouter l'événement selectionchange pour détecter les changements de sélection
      document.addEventListener("selectionchange", function () {
        if (mutationModeActive) {
          const selection = window.getSelection();
          if (
            selection.rangeCount > 0 &&
            selection.toString().trim().length > 0
          ) {
            const range = selection.getRangeAt(0);
            if (dnaInput.contains(range.commonAncestorContainer)) {
              // Délai pour éviter les appels multiples
              clearTimeout(window.selectionChangeTimeout);
              window.selectionChangeTimeout = setTimeout(function () {
                showMutationMenuForSelection(null);
              }, 200);
            }
          }
        }
      });

      // Fonction pour obtenir tous les nœuds texte dans un élément
      function getTextNodesIn(node) {
        const textNodes = [];
        const walker = document.createTreeWalker(
          node,
          NodeFilter.SHOW_TEXT,
          null,
          false
        );
        let textNode;
        while ((textNode = walker.nextNode())) {
          textNodes.push(textNode);
        }
        return textNodes;
      }

      // Fermer le menu si on clique ailleurs
      document.addEventListener("click", function (e) {
        if (
          !contextMenu.contains(e.target) &&
          !dnaInput.contains(e.target) &&
          e.target !== dnaInput
        ) {
          contextMenu.style.display = "none";
        }
      });

      // Fonction pour générer un nucléotide aléatoire
      function getRandomNucleotide() {
        const nucleotides = ["A", "T", "C", "G"];
        return nucleotides[Math.floor(Math.random() * nucleotides.length)];
      }

      // Fonction pour convertir les positions du texte brut en positions du texte nettoyé (seulement ATCG)
      function convertToCleanedPositions(fullText, startPos, endPos) {
        let cleanedStart = 0;
        let cleanedEnd = 0;

        // Compter les caractères ATCG jusqu'à startPos
        for (let i = 0; i < startPos && i < fullText.length; i++) {
          const char = fullText[i].toUpperCase();
          if (char === "A" || char === "T" || char === "C" || char === "G") {
            cleanedStart++;
          }
        }

        // Compter les caractères ATCG jusqu'à endPos
        for (let i = 0; i < endPos && i < fullText.length; i++) {
          const char = fullText[i].toUpperCase();
          if (char === "A" || char === "T" || char === "C" || char === "G") {
            cleanedEnd++;
          }
        }

        return { start: cleanedStart, end: cleanedEnd };
      }

      // Fonction pour mettre à jour les positions des plages modifiées après une mutation
      function updateModifiedRangesAfterMutation(
        oldText,
        newText,
        mutationStart,
        mutationEnd,
        mutationType,
        newLength
      ) {
        const dnaInput = document.getElementById("dnaInput");
        let modifiedRanges = JSON.parse(
          dnaInput.getAttribute("data-modified-ranges") || "[]"
        );
        let deletedRanges = JSON.parse(
          dnaInput.getAttribute("data-deleted-ranges") || "[]"
        );

        // Convertir les positions de mutation en positions nettoyées
        let oldCleanedPos, newCleanedPos, lengthDiff;

        if (mutationType === "addition") {
          // Pour l'addition, on ajoute après mutationStart, donc pas de sélection à remplacer
          // oldCleanedPos est juste la position d'insertion (start = end)
          oldCleanedPos = convertToCleanedPositions(
            oldText,
            mutationStart,
            mutationStart
          );
          // newCleanedPos correspond aux nouveaux nucléotides ajoutés
          newCleanedPos = convertToCleanedPositions(
            newText,
            mutationStart,
            mutationStart + newLength
          );
          // Le décalage est simplement la longueur ajoutée
          lengthDiff = newLength;
        } else {
          // Pour substitution et suppression, on a une sélection à remplacer
          oldCleanedPos = convertToCleanedPositions(
            oldText,
            mutationStart,
            mutationEnd
          );
          newCleanedPos = convertToCleanedPositions(
            newText,
            mutationStart,
            mutationStart + newLength
          );
          // Calculer le décalage
          lengthDiff = newLength - (oldCleanedPos.end - oldCleanedPos.start);
        }

        // Mettre à jour les positions des plages modifiées existantes
        const updatedRanges = modifiedRanges.map((range) => {
          if (range.end <= oldCleanedPos.start) {
            // Avant la mutation, pas de changement
            return range;
          } else if (range.start >= oldCleanedPos.end) {
            // Après la mutation, décaler (préserver le type)
            return {
              start: range.start + lengthDiff,
              end: range.end + lengthDiff,
              type: range.type || "addition" // Préserver le type ou utiliser "addition" par défaut
            };
          } else {
            // Chevauchement, fusionner (préserver le type si identique)
            return {
              start: Math.min(range.start, oldCleanedPos.start),
              end: Math.max(range.end, oldCleanedPos.end) + lengthDiff,
              type: range.type || "addition" // Préserver le type ou utiliser "addition" par défaut
            };
          }
        });

        // Mettre à jour les positions des délétions
        const updatedDeletedRanges = deletedRanges.map((range) => {
          if (range.end <= oldCleanedPos.start) {
            return range;
          } else if (range.start >= oldCleanedPos.end) {
            return {
              start: range.start + lengthDiff,
              end: range.end + lengthDiff,
            };
          } else {
            // Chevauchement
            return {
              start: Math.min(range.start, oldCleanedPos.start),
              end: Math.max(range.end, oldCleanedPos.end) + lengthDiff,
            };
          }
        });

        // Ajouter la nouvelle plage modifiée ou supprimée
        if (mutationType === "suppression") {
          updatedDeletedRanges.push({
            start: oldCleanedPos.start,
            end: oldCleanedPos.end,
          });
        } else {
          // Stocker le type de mutation : "addition" ou "substitution"
          updatedRanges.push({
            start: newCleanedPos.start,
            end: newCleanedPos.end,
            type: mutationType === "addition" ? "addition" : "substitution"
          });
        }

        // Fusionner les plages qui se chevauchent (uniquement si même type)
        updatedRanges.sort((a, b) => a.start - b.start);
        const merged = [];
        for (let range of updatedRanges) {
          const lastRange = merged[merged.length - 1];
          if (
            merged.length === 0 ||
            lastRange.end < range.start ||
            (lastRange.type || "addition") !== (range.type || "addition")
          ) {
            merged.push(range);
          } else {
            // Fusionner uniquement si même type
            lastRange.end = Math.max(
              lastRange.end,
              range.end
            );
          }
        }

        updatedDeletedRanges.sort((a, b) => a.start - b.start);
        const mergedDeleted = [];
        for (let range of updatedDeletedRanges) {
          if (
            mergedDeleted.length === 0 ||
            mergedDeleted[mergedDeleted.length - 1].end < range.start
          ) {
            mergedDeleted.push(range);
          } else {
            mergedDeleted[mergedDeleted.length - 1].end = Math.max(
              mergedDeleted[mergedDeleted.length - 1].end,
              range.end
            );
          }
        }

        dnaInput.setAttribute("data-modified-ranges", JSON.stringify(merged));
        dnaInput.setAttribute(
          "data-deleted-ranges",
          JSON.stringify(mergedDeleted)
        );
      }

      // Fonction pour marquer les nucléotides comme modifiés dans le texte
      function markModifiedNucleotides(fullText, startPos, endPos) {
        // Convertir les positions du texte brut en positions du texte nettoyé
        const cleanedPos = convertToCleanedPositions(
          fullText,
          startPos,
          endPos
        );

        // Stocker les positions modifiées dans un attribut data (en positions nettoyées)
        const dnaInput = document.getElementById("dnaInput");
        let modifiedRanges = JSON.parse(
          dnaInput.getAttribute("data-modified-ranges") || "[]"
        );

        // Ajouter la nouvelle plage modifiée (par défaut, type "addition" pour compatibilité)
        modifiedRanges.push({ start: cleanedPos.start, end: cleanedPos.end, type: "addition" });

        // Fusionner les plages qui se chevauchent
        modifiedRanges.sort((a, b) => a.start - b.start);
        const merged = [];
        for (let range of modifiedRanges) {
          if (
            merged.length === 0 ||
            merged[merged.length - 1].end < range.start
          ) {
            merged.push(range);
          } else {
            merged[merged.length - 1].end = Math.max(
              merged[merged.length - 1].end,
              range.end
            );
          }
        }

        dnaInput.setAttribute("data-modified-ranges", JSON.stringify(merged));
      }

      // Gérer les actions du menu
      contextMenu.addEventListener("click", function (e) {
        const action = e.target.getAttribute("data-action");
        if (!action || !selectedRange) {
          contextMenu.style.display = "none";
          return;
        }

        const dnaInput = document.getElementById("dnaInput");
        const fullText = getPlainText(dnaInput);
        const validSelection = selectedText
          .toUpperCase()
          .replace(/[^ATCG]/g, "");

        if (validSelection.length === 0) {
          contextMenu.style.display = "none";
          return;
        }

        let newText = "";
        let modifiedStart = selectedStart;
        let modifiedEnd = selectedEnd;
        let validNewNucleotides = "";

        if (action === "substitution") {
          // Substitution : remplacer aléatoirement les nucléotides sélectionnés
          let substituted = "";
          for (let i = 0; i < validSelection.length; i++) {
            substituted += getRandomNucleotide();
          }

          // Remplacer dans le texte complet
          newText =
            fullText.substring(0, selectedStart) +
            substituted +
            fullText.substring(selectedEnd);

          modifiedStart = selectedStart;
          modifiedEnd = selectedStart + substituted.length;
        } else if (action === "addition") {
          // Addition : demander à l'utilisateur d'entrer de nouveaux nucléotides
          const newNucleotides = prompt(
            "Entrez les nouveaux nucléotides à ajouter à droite de la séquence sélectionnée (A, T, C, G uniquement) :",
            ""
          );
          if (newNucleotides === null) {
            contextMenu.style.display = "none";
            return;
          }

          validNewNucleotides = newNucleotides
            .toUpperCase()
            .replace(/[^ATCG]/g, "");
          if (validNewNucleotides.length === 0) {
            alert(
              "Aucun nucléotide valide entré. Seuls A, T, C et G sont autorisés."
            );
            contextMenu.style.display = "none";
            return;
          }

          // Insérer à droite de la sélection (après selectedEnd)
          newText =
            fullText.substring(0, selectedEnd) +
            validNewNucleotides +
            fullText.substring(selectedEnd);

          modifiedStart = selectedEnd;
          modifiedEnd = selectedEnd + validNewNucleotides.length;
        } else if (action === "suppression") {
          // Suppression : retirer la séquence sélectionnée
          newText =
            fullText.substring(0, selectedStart) +
            fullText.substring(selectedEnd);

          // Pas de nucléotides modifiés pour la suppression
          modifiedStart = -1;
          modifiedEnd = -1;
        }

        // Mettre à jour les plages modifiées/supprimées avant de modifier le texte
        const oldText = fullText;
        let newLength = 0;
        if (action === "substitution") {
          newLength = validSelection.length;
        } else if (action === "addition") {
          newLength = validNewNucleotides.length;
        } else if (action === "suppression") {
          newLength = 0;
        }

        // Mettre à jour le contenu
        dnaInput.textContent = newText;

        // Mettre à jour l'attribut data-full-sequence
        dnaInput.setAttribute("data-full-sequence", newText);

        // Mettre à jour toutes les plages modifiées/supprimées
        // Pour l'addition, on passe selectedEnd comme point d'insertion (pas selectedStart)
        if (action === "addition") {
          updateModifiedRangesAfterMutation(
            oldText,
            newText,
            selectedEnd, // Point d'insertion (après la sélection)
            selectedEnd, // Même point (pas de sélection à remplacer)
            action,
            newLength
          );
        } else {
          updateModifiedRangesAfterMutation(
            oldText,
            newText,
            selectedStart,
            selectedEnd,
            action,
            newLength
          );
        }

        // Recoloriser (la fonction colorizeDNAInput appliquera automatiquement le style aux nucléotides modifiés)
        setTimeout(colorizeDNAInput, 10);

        contextMenu.style.display = "none";
        selectedRange = null;
      });

      // Fonction pour vider tous les champs d'entrée et de sortie
      function clearAllFields() {
        // Vider les champs d'encodage
        const textInput = document.getElementById("textInput");
        const dnaOutput = document.getElementById("dnaOutput");
        if (textInput) {
          textInput.value = "";
        }
        if (dnaOutput) {
          dnaOutput.textContent = "";
          dnaOutput.removeAttribute("data-dna-sequence");
          // Supprimer l'icône d'avion en papier
          removeCopyToDecodeIcon();
        }

        // Vider les champs de décodage
        const dnaInput = document.getElementById("dnaInput");
        const output = document.getElementById("output");
        if (dnaInput) {
          dnaInput.textContent = "";
          dnaInput.removeAttribute("data-full-sequence");
          dnaInput.removeAttribute("data-modified-ranges");
          dnaInput.removeAttribute("data-deleted-ranges");
        }
        if (output) {
          output.innerHTML = "";
        }
      }

      // Fonction pour importer un fichier .edi
      function importEDIFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        // Vider tous les champs avant l'import
        clearAllFields();

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const text = e.target.result;
            const dnaInput = document.getElementById("dnaInput");

            // Vérifier si le fichier contient des métadonnées de mutations
            let mutationsData = null;
            const mutationsMatch = text.match(/#MUTATIONS:(.+)$/m);
            if (mutationsMatch) {
              try {
                mutationsData = JSON.parse(mutationsMatch[1]);
              } catch (e) {
                console.warn("Impossible de parser les mutations:", e);
              }
            }

            // Format .edi : extraire la séquence ADN complète (y compris les marqueurs "à trou" TGGTGG)
            // On extrait toutes les séquences de nucléotides (A, T, C, G) pour préserver TGGTGG et les positions
            // Exclure la ligne des mutations si présente
            const textWithoutMutations = text.split('\n').filter(line => !line.startsWith('#MUTATIONS:')).join('\n');
            const sequences = textWithoutMutations.match(/[ATCG]+/gi);

            if (sequences && sequences.length > 0) {
              // Concaténer toutes les séquences trouvées pour préserver les marqueurs "à trou"
              const dnaSequence = sequences.join("").toUpperCase();
              // Stocker la séquence complète (avec marqueurs) pour le décodage
              dnaInput.setAttribute("data-full-sequence", dnaSequence);
              
              // Restaurer les mutations si présentes
              if (mutationsData) {
                if (mutationsData.modified) {
                  dnaInput.setAttribute("data-modified-ranges", JSON.stringify(mutationsData.modified));
                }
                if (mutationsData.deleted) {
                  dnaInput.setAttribute("data-deleted-ranges", JSON.stringify(mutationsData.deleted));
                }
              } else {
                // Réinitialiser les mutations si aucune n'est trouvée
                dnaInput.removeAttribute("data-modified-ranges");
                dnaInput.removeAttribute("data-deleted-ranges");
              }
              
              // Afficher seulement la partie visible avant le marqueur
              const markerIndex = dnaSequence.indexOf(TROU_MARKER);
              const visible =
                markerIndex !== -1
                  ? dnaSequence.substring(0, markerIndex)
                  : dnaSequence;
              dnaInput.textContent = visible;
              colorizeDNAInput();
              alert("Fichier .edi importé avec succès !" + (mutationsData ? " Les mutations ont été restaurées." : ""));
            } else {
              alert("Aucune séquence ADN trouvée dans le fichier .edi");
            }

            event.target.value = "";
          } catch (error) {
            alert(
              "Erreur lors de la lecture du fichier .edi : " + error.message
            );
            event.target.value = "";
          }
        };
        reader.readAsText(file);
      }

      // Fonction pour importer un fichier .fasta
      function importFASTAFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        // Vider tous les champs avant l'import
        clearAllFields();

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const text = e.target.result;
            const dnaInput = document.getElementById("dnaInput");

            // Format FASTA : les lignes commençant par > sont des en-têtes, les autres sont des séquences
            const lines = text.split("\n");
            let sequences = [];
            let mutationsData = null;

            for (let line of lines) {
              line = line.trim();
              // Vérifier les lignes d'en-tête pour les métadonnées de mutations
              if (line.startsWith(">")) {
                const mutationsMatch = line.match(/mutations=({.+})/);
                if (mutationsMatch) {
                  try {
                    mutationsData = JSON.parse(mutationsMatch[1]);
                  } catch (e) {
                    console.warn("Impossible de parser les mutations:", e);
                  }
                }
              } else if (line) {
                // Extraire uniquement les caractères A, T, C, G (ignorer les espaces, retours à la ligne, etc.)
                const sequence = line.replace(/[^ATCGatcg]/g, "").toUpperCase();
                if (sequence.length > 0) {
                  sequences.push(sequence);
                }
              }
            }

            if (sequences.length > 0) {
              // Concaténer toutes les séquences trouvées
              const dnaSequence = sequences.join("");
              dnaInput.setAttribute("data-full-sequence", dnaSequence);
              
              // Restaurer les mutations si présentes
              if (mutationsData) {
                if (mutationsData.modified) {
                  dnaInput.setAttribute("data-modified-ranges", JSON.stringify(mutationsData.modified));
                }
                if (mutationsData.deleted) {
                  dnaInput.setAttribute("data-deleted-ranges", JSON.stringify(mutationsData.deleted));
                }
              } else {
                // Réinitialiser les mutations si aucune n'est trouvée
                dnaInput.removeAttribute("data-modified-ranges");
                dnaInput.removeAttribute("data-deleted-ranges");
              }
              
              dnaInput.textContent = dnaSequence;
              colorizeDNAInput();
              alert("Fichier .fasta importé avec succès !" + (mutationsData ? " Les mutations ont été restaurées." : ""));
            } else {
              alert("Aucune séquence ADN trouvée dans le fichier .fasta");
            }

            event.target.value = "";
          } catch (error) {
            alert(
              "Erreur lors de la lecture du fichier .fasta : " + error.message
            );
            event.target.value = "";
          }
        };
        reader.readAsText(file);
      }

      // Fonction pour charger la séquence de test texte (ancienne logique)
      // Fonction pour charger la séquence de test texte depuis Dropbox
      async function loadTestTextSequence() {
        const baseUrl =
          "https://www.dropbox.com/scl/fi/h4e1ey2h1rtaswu3pox4j/Tester-texte.fasta?rlkey=9kzlv41dyp4eo6gu222fkw3ce&st=8mbyoxmd&dl=0";

        // Essayer plusieurs formats d'URL Dropbox
        const urls = [
          baseUrl.replace("&dl=0", "&raw=1"),
          baseUrl.replace("www.dropbox.com", "dl.dropboxusercontent.com").replace("&dl=0", "&dl=1"),
          "https://dl.dropboxusercontent.com/scl/fi/h4e1ey2h1rtaswu3pox4j/Tester-texte.fasta?rlkey=9kzlv41dyp4eo6gu222fkw3ce&st=8mbyoxmd&dl=1",
        ];

        // Vider tous les champs avant le chargement
        clearAllFields();

        try {
          // Afficher un message de chargement
          const dnaInput = document.getElementById("dnaInput");
          dnaInput.textContent = "Chargement...";

          let text = null;
          let lastError = null;

          // Essayer chaque URL jusqu'à ce qu'une fonctionne
          for (const url of urls) {
            try {
              const response = await fetch(url);
              if (response.ok) {
                text = await response.text();
                break; // Succès, sortir de la boucle
              } else {
                lastError = new Error(`Erreur HTTP: ${response.status}`);
              }
            } catch (err) {
              console.log("Tentative avec URL échouée:", url, err);
              lastError = err;
              continue; // Essayer l'URL suivante
            }
          }

          if (!text) {
            throw (
              lastError ||
              new Error("Impossible de télécharger le fichier depuis Dropbox")
            );
          }

          // Parser le fichier FASTA
          const lines = text.split("\n");
          let sequence = "";

          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            // Ignorer les lignes vides et les en-têtes FASTA (commençant par >)
            if (line && !line.startsWith(">")) {
              // Retirer les espaces et caractères non-ADN
              sequence += line.replace(/\s+/g, "").toUpperCase();
            }
          }

          if (!sequence) {
            throw new Error("Aucune séquence ADN trouvée dans le fichier");
          }

          // Mettre la séquence dans le champ de décodage
          dnaInput.textContent = sequence;

          // Décoder automatiquement
          decodeDNA();
        } catch (error) {
          console.error("Erreur lors du chargement:", error);
          alert(
            "Erreur lors du chargement du fichier de test : " + error.message
          );
          dnaInput.textContent = "";
        }
      }

      // Fonction pour charger la séquence de test image depuis Dropbox
      async function loadTestImageSequence() {
        const baseUrl =
          "https://www.dropbox.com/scl/fi/e6ncor4jypa2cflibj1o2/Tester-Image-Ana-s.fasta?rlkey=o35n93giiplx5w234a4zdm2j2&st=0i89j6os&dl=0";

        // Essayer plusieurs formats d'URL Dropbox (comme pour l'image)
        const urls = [
          baseUrl.replace("&dl=0", "&raw=1"),
          baseUrl.replace("www.dropbox.com", "dl.dropboxusercontent.com").replace("&dl=0", "&dl=1"),
          "https://dl.dropboxusercontent.com/scl/fi/e6ncor4jypa2cflibj1o2/Tester-Image-Ana-s.fasta?rlkey=o35n93giiplx5w234a4zdm2j2&st=0i89j6os&dl=1",
        ];

        // Vider tous les champs avant le chargement
        clearAllFields();

        try {
          // Afficher un message de chargement
          const dnaInput = document.getElementById("dnaInput");
          dnaInput.textContent = "Chargement...";

          let text = null;
          let lastError = null;

          // Essayer chaque URL jusqu'à ce qu'une fonctionne
          for (const url of urls) {
            try {
              const response = await fetch(url);
              if (response.ok) {
                text = await response.text();
                break; // Succès, sortir de la boucle
              } else {
                lastError = new Error(`Erreur HTTP: ${response.status}`);
              }
            } catch (err) {
              console.log("Tentative avec URL échouée:", url, err);
              lastError = err;
              continue; // Essayer l'URL suivante
            }
          }

          if (!text) {
            throw (
              lastError ||
              new Error("Impossible de télécharger le fichier depuis Dropbox")
            );
          }

          // Parser le fichier FASTA (même logique que importFASTAFile)
          const lines = text.split("\n");
          let sequences = [];

          for (let line of lines) {
            line = line.trim();
            // Ignorer les lignes d'en-tête (commencent par >)
            if (line && !line.startsWith(">")) {
              // Extraire uniquement les caractères A, T, C, G (ignorer les espaces, retours à la ligne, etc.)
              const sequence = line.replace(/[^ATCGatcg]/g, "").toUpperCase();
              if (sequence.length > 0) {
                sequences.push(sequence);
              }
            }
          }

          if (sequences.length > 0) {
            // Concaténer toutes les séquences trouvées
            const dnaSequence = sequences.join("");
            dnaInput.textContent = dnaSequence;
            colorizeDNAInput();
            alert("Fichier .fasta importé avec succès depuis Dropbox !");
          } else {
            alert("Aucune séquence ADN trouvée dans le fichier .fasta");
            dnaInput.textContent = "";
          }
        } catch (error) {
          console.error("Erreur lors du téléchargement:", error);
          alert(
            "Erreur lors du téléchargement du fichier .fasta depuis Dropbox : " +
              error.message
          );
          const dnaInput = document.getElementById("dnaInput");
          dnaInput.textContent = "";
        }
      }

      // Fonction pour charger la séquence "Joyeuse fête" depuis Dropbox
      async function loadJoyeuseFeteSequence() {
        const baseUrl =
          "https://www.dropbox.com/scl/fi/bp4toea0a0xse9hzdlvvz/Noel-Ana-s.fasta?rlkey=jcq7bsvghct59jvywhflmt0s2&dl=0";

        // Essayer plusieurs formats d'URL Dropbox (comme pour l'image)
        const urls = [
          baseUrl.replace("&dl=0", "&raw=1"),
          baseUrl.replace("www.dropbox.com", "dl.dropboxusercontent.com").replace("&dl=0", "&dl=1"),
          "https://dl.dropboxusercontent.com/scl/fi/bp4toea0a0xse9hzdlvvz/Noel-Ana-s.fasta?rlkey=jcq7bsvghct59jvywhflmt0s2&dl=1",
        ];

        // Vider tous les champs avant le chargement
        clearAllFields();

        try {
          // Afficher un message de chargement
          const dnaInput = document.getElementById("dnaInput");
          dnaInput.textContent = "Chargement...";

          let text = null;
          let lastError = null;

          // Essayer chaque URL jusqu'à ce qu'une fonctionne
          for (const url of urls) {
            try {
              const response = await fetch(url);
              if (response.ok) {
                text = await response.text();
                break; // Succès, sortir de la boucle
              } else {
                lastError = new Error(`Erreur HTTP: ${response.status}`);
              }
            } catch (err) {
              console.log("Tentative avec URL échouée:", url, err);
              lastError = err;
              continue; // Essayer l'URL suivante
            }
          }

          if (!text) {
            throw (
              lastError ||
              new Error("Impossible de télécharger le fichier depuis Dropbox")
            );
          }

          // Parser le fichier FASTA (même logique que importFASTAFile)
          const lines = text.split("\n");
          let sequences = [];

          for (let line of lines) {
            line = line.trim();
            // Ignorer les lignes d'en-tête (commencent par >)
            if (line && !line.startsWith(">")) {
              // Extraire uniquement les caractères A, T, C, G (ignorer les espaces, retours à la ligne, etc.)
              const sequence = line.replace(/[^ATCGatcg]/g, "").toUpperCase();
              if (sequence.length > 0) {
                sequences.push(sequence);
              }
            }
          }

          if (sequences.length > 0) {
            // Concaténer toutes les séquences trouvées
            const dnaSequence = sequences.join("");
            dnaInput.textContent = dnaSequence;
            colorizeDNAInput();
            alert("Fichier .fasta importé avec succès depuis Dropbox !");
          } else {
            alert("Aucune séquence ADN trouvée dans le fichier .fasta");
            dnaInput.textContent = "";
          }
        } catch (error) {
          console.error("Erreur lors du téléchargement:", error);
          alert(
            "Erreur lors du téléchargement du fichier .fasta depuis Dropbox : " +
              error.message
          );
          const dnaInput = document.getElementById("dnaInput");
          dnaInput.textContent = "";
        }
      }

      // Fonction pour charger la séquence de test (ancienne version - conservée pour référence)
      function loadTestSequenceOld() {
        // Séquence ADN de test à mettre directement dans le champ de décodage
        let baseSequence =
          "ATGGGCACACCCACTCTTACAACTTTTGGCAAACTTGGCTTTACAGACCTTGGCACACCCACTCTTACAACTTTTCTTTTCACTGGCGTATTTGCCGTGACTTTTGCTGTGCCCCTTACTTTTACGACTTTTCGTTTCAAGCTCACTTAATTTATTGCTAAACTTACCGACCCCGGCTTTGCTAAAAATACTCGTAAACCCGGCTAA";

        // Nettoyer la séquence : retirer les espaces (TTT) qui suivent directement un point (TAA, TAG, TGA)
        // Cela évite d'avoir un espace entre deux phrases qui cause un deuxième point
        baseSequence = baseSequence.replace(/(TAA|TAG|TGA)TTT+/g, "$1");

        // Séquences ADN à garder encodées (à deviner)
        const sequencesToKeep = [
          "ACAGACCTTGGCACACCCACTCTTACAACT",
          "CGTTTCAAGCTCACT",
          "GCTAAAAATACTCGTAAACCCGGC",
        ];

        // Décoder temporairement la séquence pour trouver les positions des mots
        // On va simuler le décodage pour trouver les indices
        const input = baseSequence;
        const startIndex = input.indexOf("ATG");
        if (startIndex === -1) {
          alert("Séquence invalide : pas de codon START (ATG)");
          return;
        }

        // Trouver les positions des séquences à garder
        const wordIndices = new Set();
        let wordIndex = 0;
        let currentWordDNA = "";

        for (let i = startIndex + 3; i <= input.length - 3; i += 3) {
          const codon = input.substring(i, i + 3);

          if (["TAA", "TAG", "TGA"].includes(codon)) {
            // Fin de mot (point)
            if (currentWordDNA) {
              // Vérifier si cette séquence ADN correspond à une des séquences à garder
              for (const seqToKeep of sequencesToKeep) {
                if (currentWordDNA === seqToKeep) {
                  wordIndices.add(wordIndex);
                  break;
                }
              }
              currentWordDNA = "";
              wordIndex++;
            }
            // Ignorer les codons stop consécutifs
            while (i + 3 <= input.length - 3) {
              const nextCodon = input.substring(i + 3, i + 6);
              if (["TAA", "TAG", "TGA"].includes(nextCodon)) {
                i += 3;
              } else {
                break;
              }
            }
          } else if (codon === "TTT") {
            // Espace - fin de mot
            if (currentWordDNA) {
              for (const seqToKeep of sequencesToKeep) {
                if (currentWordDNA === seqToKeep) {
                  wordIndices.add(wordIndex);
                  break;
                }
              }
              currentWordDNA = "";
              wordIndex++;
            }
          } else {
            // Caractère normal - ajouter au mot actuel
            currentWordDNA += codon;
          }
        }

        // Ajouter le dernier mot s'il existe
        if (currentWordDNA) {
          for (const seqToKeep of sequencesToKeep) {
            if (currentWordDNA === seqToKeep) {
              wordIndices.add(wordIndex);
              break;
            }
          }
        }

        // S'assurer que la séquence se termine par un seul point (TAA, TAG ou TGA)
        // Retirer tout ce qui suit le dernier point
        let cleanedSequence = baseSequence;
        let lastStopIndex = -1;
        for (let i = cleanedSequence.length - 3; i >= 0; i -= 3) {
          const codon = cleanedSequence.substring(i, i + 3);
          if (["TAA", "TAG", "TGA"].includes(codon)) {
            lastStopIndex = i;
            // Vérifier s'il y a des codons stop consécutifs avant
            let j = i - 3;
            while (j >= 0) {
              const prevCodon = cleanedSequence.substring(j, j + 3);
              if (["TAA", "TAG", "TGA"].includes(prevCodon)) {
                lastStopIndex = j;
                j -= 3;
              } else {
                break;
              }
            }
            break;
          }
        }

        if (lastStopIndex !== -1) {
          // Garder seulement jusqu'au dernier point (inclus)
          cleanedSequence = cleanedSequence.substring(0, lastStopIndex + 3);
        }

        // Encoder les positions "à trou" pour que le décodage sache quels mots garder en ADN
        let fullSequence = cleanedSequence;
        if (wordIndices.size > 0) {
          const trouPositions = encodeTrouPositions(wordIndices);
          fullSequence = cleanedSequence + trouPositions;
        }

        // Mettre la séquence dans le champ de décodage
        // Les marqueurs "à trou" seront présents mais masqués visuellement
        const dnaInput = document.getElementById("dnaInput");
        dnaInput.textContent = fullSequence;

        // Masquer visuellement les marqueurs "à trou" (TGGTGG et ce qui suit) dans le champ d'entrée
        setTimeout(() => {
          colorizeDNAInput();
          // Après le coloriage, masquer la partie avec les marqueurs "à trou"
          const markerIndex = fullSequence.indexOf(TROU_MARKER);
          if (markerIndex !== -1) {
            // Créer un style pour masquer la partie après le marqueur
            const visiblePart = fullSequence.substring(0, markerIndex);
            const hiddenPart = fullSequence.substring(markerIndex);
            // Remplacer le contenu pour n'afficher que la partie visible
            // Mais garder la séquence complète dans un attribut data pour le décodage
            dnaInput.setAttribute("data-full-sequence", fullSequence);
            dnaInput.textContent = visiblePart;
            colorizeDNAInput();
          }
        }, 10);
      }

      // Fonction pour copier l'adresse email dans le presse-papier
      function copyEmailToClipboard() {
        const email = "michawaro.mail@gmail.com";
        navigator.clipboard
          .writeText(email)
          .then(() => {
            // Feedback visuel temporaire
            const icon = document.getElementById("emailIcon");
            const originalTitle = icon.title;
            icon.title = "Copié !";
            icon.style.transform = "scale(1.2)";
            setTimeout(() => {
              icon.title = originalTitle;
              icon.style.transform = "scale(1)";
            }, 1000);
          })
          .catch((err) => {
            console.error("Erreur lors de la copie :", err);
            alert("Erreur lors de la copie de l'adresse email");
          });
      }

      // Ouvrir la vidéo du scénario (Dropbox - mode lecture directe)
      function openScenarioVideo() {
        const url =
          "https://www.dropbox.com/scl/fi/5tp7jra3qf1ycya8j3jqs/Th-1A-C3-Rosalind-Message-final.mp4?rlkey=qwg9xohhya7c7t29cmrwi585f&raw=1";
        window.open(url, "_blank", "noopener,noreferrer");
      }

      // Fonction pour générer tous les triplets possibles (64 triplets)
      function generateAllTriplets() {
        const bases = ["A", "T", "C", "G"];
        const triplets = [];
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            for (let k = 0; k < 4; k++) {
              triplets.push(bases[i] + bases[j] + bases[k]);
            }
          }
        }
        return triplets;
      }

      // Fonction pour générer 64 couleurs distinctes
      function generate64Colors() {
        // Palette personnalisée avec exactement 64 couleurs
        // AAA (index 0) = Blanc
        const colors = [
          // Blancs (3) - AAA doit être blanc
         "#FFFFFF", // 0 - AAA
"#CD5870", // 1
"#D98294", // 2

// Rouges → Oranges
"#5A0F14", // 3
"#7A1C18", // 4
"#9E2A1D", // 5
"#C23B22", // 6
"#E5532D", // 7
"#F06A3C", // 8
"#F5834C", // 9
"#F89C5C", // 10
"#FBB56D", // 11
"#FECB7E", // 12

// Jaunes
"#FEE08B", // 13
"#FEEB9C", // 14
"#FFF2AE", // 15
"#FFF7C0", // 16
"#F3F4B2", // 17
"#E6EE9C", // 18
"#D9E785", // 19
"#CCE16F", // 20

// Verts
"#BFD95A", // 21
"#A9CF5A", // 22
"#93C55A", // 23
"#7DBB5A", // 24
"#67B15A", // 25
"#52A75A", // 26
"#3D9D5A", // 27
"#2F8F5C", // 28
"#23815E", // 29
"#1B735F", // 30
"#16655E", // 31

// Tons chair / transition
"#D09D93", // 32
"#DFA795", // 33
"#E4CCC7", // 34
"#FCE9E1", // 35

// Turquoises → Cyans
"#A1B5C7", // 36
"#22A1A6", // 37
"#36B2B7", // 38
"#4EC3C8", // 39

// Bleus
"#7BDDE1", // 40
"#6CC9E0", // 41
"#5CB4DF", // 42
"#4C9FDE", // 43
"#3C8ADD", // 44
"#2F75CC", // 45
"#2460BB", // 46
"#1A4AAA", // 47
"#123495", // 48
"#0C1F7F", // 49

// Violets → Magentas
"#3E1F7F", // 50
"#6A2E9B", // 51
"#8E6FBF", // 52 - violet doux

// Marrons
"#5A3A1E", // 53
"#7A4A2E", // 54
"#9B6A4A", // 55

// Noir
"#000000", // 56

// Gris
"#2E2E2E", // 57
"#7A7A7A", // 58
"#BFBFBF", // 59
"#D9D9D9", // 60

// Couleurs de transition / équilibre visuel
"#C77D3B", // 61 - ocre
"#4F6D7A", // 62 - bleu ardoise
"#9FB8A0", // 63 - vert grisé

        ];

        // S'assurer qu'on a exactement 64 couleurs
        if (colors.length !== 64) {
          console.warn(
            `Attention: la palette contient ${colors.length} couleurs au lieu de 64`
          );
        }

        return colors;
      }

      // Fonction pour générer la palette Van Gogh (64 couleurs)
      // L'index 0 (CCC) doit toujours être blanc pour que la feuille reste blanche lors du changement de palette
      // RÈGLES STRICTES :
      // - Exactement 64 codes HEX uniques
      // - Aucun doublon strict (#RRGGBB)
      // - Chaque couleur différente d'au moins 5 unités RGB de toute autre
      // - Ordre : Blancs, Bleus nuits, Jaunes/Oranges, Blancs chauds/crèmes, Gris/Noirs, Marrons/Terres, Violets/Pourpres
      function generateVanGoghColors() {
        const colors = [
          // BLANCS (1 couleur)
          "#FFFFFF", // 0 - CCC (blanc pour que la feuille reste blanche)

          // BLEUS NUITS (13 couleurs)
          "#0B1D51", // 1
          "#0E245F", // 2
          "#102A8C", // 3
          "#132FA3", // 4
          "#1636C8", // 5
          "#1A3BFF", // 6
          "#213FAE", // 7
          "#2346A1", // 8
          "#2C3E9F", // 9
          "#304FFE", // 10
          "#3949AB", // 11
          "#1A237E", // 12
          "#0D1B7E", // 13 - nouveau bleu nuit unique

          // JAUNES / ORANGES (11 couleurs)
          "#FFD200", // 14
          "#FFEA00", // 15
          "#FFC300", // 16
          "#FFB000", // 17
          "#FFA000", // 18
          "#FF9500", // 19
          "#FF9F00", // 20
          "#FFCC33", // 21
          "#FFE066", // 22
          "#F4D03F", // 23
          "#EAC100", // 24

          // BLANCS CHAUDS / CRÈMES (8 couleurs)
          "#FFFDF7", // 25
          "#FFF9E6", // 26
          "#FFF6CC", // 27
          "#FFF2B3", // 28
          "#FDF5E6", // 29
          "#FAF3DD", // 30
          "#FFFBEA", // 31
          "#FFF8DC", // 32

          // GRIS / NOIRS (6 couleurs)
          "#141414", // 33
          "#1C1C1C", // 34
          "#2B2B2B", // 35
          "#3A3A3A", // 36
          "#555555", // 37
          "#666666", // 38 - nouveau gris unique

          // MARRONS / TERRES (7 couleurs)
          "#4A2C1D", // 39
          "#5C4033", // 40
          "#6B3E26", // 41
          "#7A4A2E", // 42
          "#8B5A2B", // 43
          "#A97142", // 44
          "#9B6A3B", // 45 - nouveau marron unique

          // VIOLETS / POURPRES (9 couleurs)
          "#3E2A5A", // 46
          "#4B3B6E", // 47
          "#5E2D79", // 48
          "#6A1B9A", // 49
          "#7B1FA2", // 50
          "#8E24AA", // 51
          "#9370DB", // 52 - violet moyen
          "#5A2040", // 53
          "#7A003C", // 54
          "#9C2542", // 55

          // COMPLÉMENT POUR ATTEINDRE 64 (8 couleurs : 5 verts + or, argent, bronze)
          // 5 VERTS DIFFÉRENTS
          "#046205", // 56 - vert foncé
          "#137F41", // 57 - vert moyen
          "#4BB74C", // 58 - vert pastel
          "#2E7D32", // 59 - vert forêt
          "#66BB6A", // 60 - vert clair
          // MÉTAUX
          "#FFD700", // 61 - or
          "#C0C0C0", // 62 - argent
          "#CD7F32", // 63 - bronze
        ];

        // Vérification stricte : exactement 64 couleurs uniques
        const uniqueColors = new Set(colors);
        if (colors.length !== 64) {
          console.error(
            `ERREUR: la palette Van Gogh contient ${colors.length} couleurs au lieu de 64`
          );
        }
        if (uniqueColors.size !== 64) {
          console.error(
            `ERREUR: la palette Van Gogh contient ${
              colors.length - uniqueColors.size
            } doublons`
          );
        }

        // Vérification de la distance RGB minimale (5 unités)
        function hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result
            ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16),
              }
            : null;
        }

        function rgbDistance(color1, color2) {
          const rgb1 = hexToRgb(color1);
          const rgb2 = hexToRgb(color2);
          if (!rgb1 || !rgb2) return Infinity;
          return Math.sqrt(
            Math.pow(rgb1.r - rgb2.r, 2) +
              Math.pow(rgb1.g - rgb2.g, 2) +
              Math.pow(rgb1.b - rgb2.b, 2)
          );
        }

        // Vérifier que chaque couleur est à au moins 5 unités de distance des autres
        for (let i = 0; i < colors.length; i++) {
          for (let j = i + 1; j < colors.length; j++) {
            const distance = rgbDistance(colors[i], colors[j]);
            if (distance < 5) {
              console.warn(
                `ATTENTION: Les couleurs ${colors[i]} et ${
                  colors[j]
                } sont trop proches (distance: ${distance.toFixed(2)})`
              );
            }
          }
        }

        return colors;
      }

      // Fonction pour générer la palette Gustav Klimt (64 couleurs)
      // L'index 0 (GGG) doit toujours être blanc pour que la feuille reste blanche lors du changement de palette
      // RÈGLES STRICTES :
      // - Exactement 64 codes HEX uniques
      // - Aucun doublon strict (#RRGGBB)
      // - Chaque couleur différente d'au moins 5 unités RGB de toute autre
      function generateKlimtColors() {
        const colors = [
          // BLANC (1 couleur) - index 0 doit être blanc pour que la feuille reste blanche
          "#FFFFFF", // 0 - GGG (blanc pour que la feuille reste blanche)

          // COULEURS GUSTAV KLIMT (63 couleurs fournies, numérotées 1-64 dans la liste)
          // Utilisation des couleurs 2-64 de la liste (la couleur 1 #F2D3CC est remplacée par #FFFFFF)
          "#9B7C74", // 1 (couleur 2 de la liste)
          "#F3BDAE", // 2 (couleur 3)
          "#E48E73", // 3 (couleur 4)
          "#F1A58D", // 4 (couleur 5)
          "#30150B", // 5 (couleur 6)
          "#4B3026", // 6 (couleur 7)
          "#5B4035", // 7 (couleur 8)
          "#8A6757", // 8 (couleur 9)
          "#422314", // 9 (couleur 10)
          "#A49B96", // 10 (couleur 11)
          "#DE7B3C", // 11 (couleur 12)
          "#221F1D", // 12 (couleur 13)
          "#75543D", // 13 (couleur 14)
          "#552F12", // 14 (couleur 15)
          "#CBA789", // 15 (couleur 16)
          "#6F4725", // 16 (couleur 17)
          "#633B19", // 17 (couleur 18)
          "#BB8D64", // 18 (couleur 19)
          "#B76419", // 19 (couleur 20)
          "#CA7625", // 20 (couleur 21)
          "#805428", // 21 (couleur 22)
          "#AC7E50", // 22 (couleur 23)
          "#8C6135", // 23 (couleur 24)
          "#965A1C", // 24 (couleur 25)
          "#7C4A16", // 25 (couleur 26)
          "#9C7042", // 26 (couleur 27)
          "#A26B2A", // 27 (couleur 28)
          "#B47B35", // 28 (couleur 29)
          "#F4EDE4", // 29 (couleur 30)
          "#EF941F", // 30 (couleur 31)
          "#E99F3E", // 31 (couleur 32)
          "#C68F41", // 32 (couleur 33)
          "#D2A25B", // 33 (couleur 34)
          "#EDB356", // 34 (couleur 35)
          "#F5AF20", // 35 (couleur 36)
          "#F6BC37", // 36 (couleur 37)
          "#E7C473", // 37 (couleur 38)
          "#F6D451", // 38 (couleur 39)
          "#F8CE18", // 39 (couleur 40)
          "#F8D635", // 40 (couleur 41)
          "#C5C4BE", // 41 (couleur 42)
          "#CABA44", // 42 (couleur 43)
          "#FBF092", // 43 (couleur 44)
          "#FBEB21", // 44 (couleur 45)
          "#FCF163", // 45 (couleur 46)
          "#FCF041", // 46 (couleur 47)
          "#A09B3A", // 47 (couleur 48)
          "#768032", // 48 (couleur 49)
          "#58641F", // 49 (couleur 50)
          "#79955C", // 50 (couleur 51)
          "#90AE74", // 51 (couleur 52)
          "#2D4617", // 52 (couleur 53)
          "#64824C", // 53 (couleur 54)
          "#53703E", // 54 (couleur 55)
          "#A9CC93", // 55 (couleur 56)
          "#3F5C32", // 56 (couleur 57)
          "#4E6259", // 57 (couleur 58)
          "#63787D", // 58 (couleur 59)
          "#33383A", // 59 (couleur 60)
          "#334D76", // 60 (couleur 61)
          "#5872B2", // 61 (couleur 62)
          "#7B95D7", // 62 (couleur 63)
          "#D27FA7", // 63 (couleur 64)
          // Note: La couleur #F2D3CC (couleur 1 de la liste) est remplacée par #FFFFFF à l'index 0
        ];

        // Vérification stricte : exactement 64 couleurs uniques
        const uniqueColors = new Set(colors);
        if (colors.length !== 64) {
          console.error(
            `ERREUR: la palette Gustav Klimt contient ${colors.length} couleurs au lieu de 64`
          );
        }
        if (uniqueColors.size !== 64) {
          console.error(
            `ERREUR: la palette Gustav Klimt contient ${
              colors.length - uniqueColors.size
            } doublons`
          );
        }

        // Vérification de la distance RGB minimale (5 unités)
        function hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result
            ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16),
              }
            : null;
        }

        function rgbDistance(color1, color2) {
          const rgb1 = hexToRgb(color1);
          const rgb2 = hexToRgb(color2);
          if (!rgb1 || !rgb2) return Infinity;
          return Math.sqrt(
            Math.pow(rgb1.r - rgb2.r, 2) +
              Math.pow(rgb1.g - rgb2.g, 2) +
              Math.pow(rgb1.b - rgb2.b, 2)
          );
        }

        // Vérifier que chaque couleur est à au moins 5 unités de distance des autres
        for (let i = 0; i < colors.length; i++) {
          for (let j = i + 1; j < colors.length; j++) {
            const distance = rgbDistance(colors[i], colors[j]);
            if (distance < 5) {
              console.warn(
                `ATTENTION: Les couleurs ${colors[i]} et ${
                  colors[j]
                } sont trop proches (distance: ${distance.toFixed(2)})`
              );
            }
          }
        }

        return colors;
      }

      // Fonction pour générer la palette Claude Monet (64 couleurs)
      // L'index 0 (TTT) doit toujours être blanc pour que la feuille reste blanche lors du changement de palette
      // RÈGLES STRICTES :
      // - Exactement 64 codes HEX uniques
      // - Aucun doublon strict (#RRGGBB)
      // - Chaque couleur différente d'au moins 5 unités RGB de toute autre
      function generateMonetColors() {
        const colors = [
          // BLANC (1 couleur) - index 0 doit être blanc pour que la feuille reste blanche
          "#FFFFFF", // 0 - TTT (blanc pour que la feuille reste blanche)

          // COULEURS CLAUDE MONET (63 couleurs fournies, numérotées 1-64 dans la liste)
          // Utilisation des couleurs 2-64 de la liste (la couleur 1 #B94C43 est remplacée par #FFFFFF)
          "#A8635C", // 1 (couleur 2 de la liste)
          "#FFE4E1", // 2 (couleur 3)
          "#9E4737", // 3 (couleur 4)
          "#9A6141", // 4 (couleur 5)
          "#7C6556", // 5 (couleur 6)
          "#FFF5EE", // 6 (couleur 7)
          "#805B39", // 7 (couleur 8)
          "#FFE4C4", // 8 (couleur 9)
          "#FAEBD7", // 9 (couleur 10)
          "#FFEBCD", // 10 (couleur 11)
          "#FFEFD5", // 11 (couleur 12)
          "#867543", // 12 (couleur 13)
          "#736B46", // 13 (couleur 14)
          "#FFFACD", // 14 (couleur 15)
          "#736D35", // 15 (couleur 16)
          "#666341", // 16 (couleur 17)
          "#656133", // 17 (couleur 18)
          "#FFFDD0", // 18 (couleur 19)
          "#949261", // 19 (couleur 20)
          "#767556", // 20 (couleur 21)
          "#7A7B67", // 21 (couleur 22)
          "#718235", // 22 (couleur 23)
          "#545D36", // 23 (couleur 24)
          "#666E50", // 24 (couleur 25)
          "#607139", // 25 (couleur 26)
          "#414937", // 26 (couleur 27)
          "#4F6A3E", // 27 (couleur 28)
          "#3F6138", // 28 (couleur 29)
          "#F5FFF5", // 29 (couleur 30)
          "#F0FFF0", // 30 (couleur 31)
          "#88A589", // 31 (couleur 32)
          "#303C32", // 32 (couleur 33)
          "#2C5738", // 33 (couleur 34)
          "#B6D0C0", // 34 (couleur 35)
          "#F5FFFA", // 35 (couleur 36)
          "#2A2C2B", // 36 (couleur 37)
          "#95B7AD", // 37 (couleur 38)
          "#B8D6D7", // 38 (couleur 39)
          "#9FC5CA", // 39 (couleur 40)
          "#425A5E", // 40 (couleur 41)
          "#8DBBC4", // 41 (couleur 42)
          "#A7CDD9", // 42 (couleur 43)
          "#125E7A", // 43 (couleur 44)
          "#73B1CB", // 44 (couleur 45)
          "#52A0C5", // 45 (couleur 46)
          "#8CBED6", // 46 (couleur 47)
          "#B1D5E9", // 47 (couleur 48)
          "#3598D5", // 48 (couleur 49)
          "#96C5E2", // 49 (couleur 50)
          "#138FDF", // 50 (couleur 51)
          "#7AB8E2", // 51 (couleur 52)
          "#C2DFF3", // 52 (couleur 53)
          "#A2CDEB", // 53 (couleur 54)
          "#65AEE3", // 54 (couleur 55)
          "#4FA4E2", // 55 (couleur 56)
          "#F8F8FF", // 56 (couleur 57)
          "#E6E6FA", // 57 (couleur 58)
          "#F0E6FF", // 58 (couleur 59)
          "#FFF0F5", // 59 (couleur 60)
          "#FFDAE0", // 60 (couleur 61)
          "#DF1A33", // 61 (couleur 62)
          "#D63645", // 62 (couleur 63)
          "#BE2D32", // 63 (couleur 64)
          // Note: La couleur #B94C43 (couleur 1 de la liste) est remplacée par #FFFFFF à l'index 0
        ];

        // Vérification stricte : exactement 64 couleurs uniques
        const uniqueColors = new Set(colors);
        if (colors.length !== 64) {
          console.error(
            `ERREUR: la palette Claude Monet contient ${colors.length} couleurs au lieu de 64`
          );
        }
        if (uniqueColors.size !== 64) {
          console.error(
            `ERREUR: la palette Claude Monet contient ${
              colors.length - uniqueColors.size
            } doublons`
          );
        }

        // Vérification de la distance RGB minimale (5 unités)
        function hexToRgb(hex) {
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result
            ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16),
              }
            : null;
        }

        function rgbDistance(color1, color2) {
          const rgb1 = hexToRgb(color1);
          const rgb2 = hexToRgb(color2);
          if (!rgb1 || !rgb2) return Infinity;
          return Math.sqrt(
            Math.pow(rgb1.r - rgb2.r, 2) +
              Math.pow(rgb1.g - rgb2.g, 2) +
              Math.pow(rgb1.b - rgb2.b, 2)
          );
        }

        // Vérifier que chaque couleur est à au moins 5 unités de distance des autres
        for (let i = 0; i < colors.length; i++) {
          for (let j = i + 1; j < colors.length; j++) {
            const distance = rgbDistance(colors[i], colors[j]);
            if (distance < 5) {
              console.warn(
                `ATTENTION: Les couleurs ${colors[i]} et ${
                  colors[j]
                } sont trop proches (distance: ${distance.toFixed(2)})`
              );
            }
          }
        }

        return colors;
      }

      // Variables globales pour le pixel art
      let pixelArtGrid = []; // Grille 50x50 stockant les indices de couleur
      let currentPaletteType = "AAA"; // Type de palette actuelle : "AAA" (classique) ou "CCC" (Van Gogh)
      let tripletToColorMap = {}; // Mapping triplet -> couleur
      let colorToTripletMap = {}; // Mapping couleur -> triplet
      let colorPalette = []; // Palette de 64 couleurs
      let pixelArtHistory = []; // Historique pour undo/redo
      let pixelBorderColor = "black"; // Couleur de bordure des pixels : "black" ou "white"
      let pixelArtHistoryIndex = -1; // Index actuel dans l'historique
      let currentTool = "paint"; // Outil actuel : "paint", "spray", "erase", "eyedropper", "circle", "square", "triangle", "star"
      let shapeStartPos = null; // Position de départ pour les formes
      let shapePreviewGrid = null; // Grille sauvegardée avant le dessin de forme (pour prévisualisation)
      let brushSize = 1; // Taille du pinceau (en pixels)
      let spraySize = 1; // Taille de l'aérographe (en pixels)
      let eraserSize = 1; // Taille de la gomme (en pixels)

      // Fonction pour enregistrer le pixel art (export direct en .fasta)
      async function savePixelArt() {
        // Vérifier que la séquence existe dans dnaOutput
        const output = document.getElementById("dnaOutput");
        if (!output) {
          alert("Erreur : impossible de trouver la séquence ADN.");
          return;
        }

        const fullSequence = output.getAttribute("data-dna-sequence");
        if (!fullSequence) {
          alert(
            "Aucune séquence à exporter. Veuillez d'abord créer un dessin."
          );
          return;
        }

        // Télécharger directement sans passer par la modale (compatible mobile/tablette)
        try {
          // Format FASTA : en-tête suivi de la séquence (60 caractères par ligne)
          const fastaContent = `>Sequence_ADN_encodee\n`;
          const sequenceLines = fullSequence.match(/.{1,60}/g) || [
            fullSequence,
          ];
          const fastaFile = fastaContent + sequenceLines.join("\n") + "\n";

          // Créer un Blob avec le contenu
          const blob = new Blob([fastaFile], {
            type: "text/plain;charset=utf-8;",
          });

          // Utiliser la fonction utilitaire pour télécharger
          downloadFile(blob, "sequence_encodée.fasta");
        } catch (error) {
          console.error("Erreur lors de l'enregistrement:", error);
          alert("Erreur lors de l'enregistrement du fichier.");
        }
      }

      // Fonction pour vérifier si un dessin existe (au moins un pixel n'est pas blanc)
      function hasDrawing() {
        const gridSize = 70;
        if (pixelArtGrid.length === 0) return false;

        for (let i = 0; i < gridSize; i++) {
          if (!pixelArtGrid[i]) continue;
          for (let j = 0; j < gridSize; j++) {
            if (pixelArtGrid[i][j] !== undefined && pixelArtGrid[i][j] !== 0) {
              return true; // Au moins un pixel n'est pas blanc (index 0)
            }
          }
        }
        return false; // Tous les pixels sont blancs
      }

      // Fonction pour charger l'image de la fabrique depuis Dropbox
      async function loadFabriqueImage() {
        const container = document.getElementById("fabriqueImageContainer");
        if (!container) return;

        const dropboxUrl =
          "https://www.dropbox.com/scl/fi/dubr39pke2v6k2xo48o4m/La-fabrique-images.png?rlkey=ms3wb24udc2hfk6gjd78siid2&st=z4lzeiyy&raw=1";

        try {
          // Essayer plusieurs formats d'URL Dropbox
          const urls = [
            dropboxUrl,
            dropboxUrl
              .replace("www.dropbox.com", "dl.dropboxusercontent.com")
              .replace("&raw=1", "&dl=1"),
            "https://dl.dropboxusercontent.com/scl/fi/dubr39pke2v6k2xo48o4m/La-fabrique-images.png?rlkey=ms3wb24udc2hfk6gjd78siid2&st=z4lzeiyy&dl=1",
          ];

          let imageLoaded = false;
          for (const url of urls) {
            try {
              const response = await fetch(url);
              if (response.ok) {
                const blob = await response.blob();
                const imageUrl = URL.createObjectURL(blob);
                const img = document.createElement("img");
                img.src = imageUrl;
                img.alt = "La fabrique";
                img.className = "pixel-art-illustration";
                img.style.maxWidth = "100%";
                img.style.height = "auto";
                img.onload = () => {
                  container.innerHTML = "";
                  container.appendChild(img);
                  imageLoaded = true;

                  // Ajouter les événements pour l'agrandissement
                  setupFabriqueZoom(img);
                };
                img.onerror = () => {
                  URL.revokeObjectURL(imageUrl);
                };
                break;
              }
            } catch (err) {
              console.log("Tentative avec URL échouée:", url, err);
              continue;
            }
          }

          if (!imageLoaded) {
            container.innerHTML =
              '<span style="color: #999; font-size: 0.85rem;">Image non disponible</span>';
          }
        } catch (error) {
          console.error("Erreur lors du chargement de l'image:", error);
          container.innerHTML =
            '<span style="color: #999; font-size: 0.85rem;">Erreur de chargement</span>';
        }
      }

      // Fonction pour charger l'image de la vidéo explicative avec plusieurs formats d'URL
      function loadVideoExplicativeImage() {
        const img = document.getElementById("videoExplicativeImg");
        if (!img) return;

        const dropboxUrl =
          "https://www.dropbox.com/scl/fi/kmx268y2xchlu1objbjo4/ADN-Mut.jpg?rlkey=lziujwhr354lq43r3j28t2nfl&st=1mzqlzub&dl=1";

        // Essayer plusieurs formats d'URL Dropbox
        const urls = [
          "https://dl.dropboxusercontent.com/scl/fi/kmx268y2xchlu1objbjo4/ADN-Mut.jpg?rlkey=lziujwhr354lq43r3j28t2nfl&st=1mzqlzub&dl=1",
          dropboxUrl.replace("www.dropbox.com", "dl.dropboxusercontent.com"),
          dropboxUrl.replace("&dl=1", "&raw=1"),
          dropboxUrl,
          "https://www.dropbox.com/scl/fi/kmx268y2xchlu1objbjo4/ADN-Mut.jpg?rlkey=lziujwhr354lq43r3j28t2nfl&st=1mzqlzub&raw=1",
        ];

        let currentIndex = 0;
        function tryNextUrl() {
          if (currentIndex >= urls.length) {
            console.warn("Impossible de charger l'image de la vidéo explicative");
            return;
          }

          const testImg = new Image();
          testImg.onload = function() {
            img.src = urls[currentIndex];
          };
          testImg.onerror = function() {
            currentIndex++;
            tryNextUrl();
          };
          testImg.src = urls[currentIndex];
        }

        tryNextUrl();
      }

      // Fonction pour configurer l'agrandissement de l'image La fabrique
      function setupFabriqueZoom(img) {
        // Créer le modal s'il n'existe pas
        let modal = document.getElementById("fabriqueZoomModal");
        if (!modal) {
          modal = document.createElement("div");
          modal.id = "fabriqueZoomModal";
          modal.className = "fabrique-zoom-modal";

          const content = document.createElement("div");
          content.className = "fabrique-zoom-content";

          const zoomImg = document.createElement("img");
          zoomImg.src = img.src;
          zoomImg.alt = "La fabrique - Agrandissement";

          const closeBtn = document.createElement("div");
          closeBtn.className = "fabrique-zoom-close";
          closeBtn.title = "Fermer";

          content.appendChild(zoomImg);
          content.appendChild(closeBtn);
          modal.appendChild(content);
          document.body.appendChild(modal);

          // Fermer au clic sur le fond (modal)
          modal.addEventListener("click", function (e) {
            if (e.target === modal) {
              closeFabriqueZoom();
            }
          });

          // Fermer au clic sur le bouton de fermeture
          closeBtn.addEventListener("click", function (e) {
            e.stopPropagation();
            closeFabriqueZoom();
          });

          // Empêcher la fermeture au clic sur le contenu
          content.addEventListener("click", function (e) {
            e.stopPropagation();
          });

          // Fermer quand la souris quitte le modal
          modal.addEventListener("mouseleave", function () {
            closeFabriqueZoom();
          });
        } else {
          // Mettre à jour l'image dans le modal existant
          const zoomImg = modal.querySelector("img");
          if (zoomImg) {
            zoomImg.src = img.src;
          }
        }

        // Afficher le modal au survol
        let hoverTimeout;
        img.addEventListener("mouseenter", function () {
          hoverTimeout = setTimeout(function () {
            showFabriqueZoom(img.src);
          }, 300); // Délai de 300ms pour éviter les affichages intempestifs
        });

        img.addEventListener("mouseleave", function (e) {
          clearTimeout(hoverTimeout);
          // Ne pas fermer immédiatement si la souris passe sur le modal
          setTimeout(function () {
            const modal = document.getElementById("fabriqueZoomModal");
            if (modal && !modal.classList.contains("active")) {
              return;
            }
            // Vérifier si la souris est toujours sur l'image ou le modal
            const relatedTarget = e.relatedTarget;
            if (
              relatedTarget &&
              (modal.contains(relatedTarget) || img.contains(relatedTarget))
            ) {
              return;
            }
            closeFabriqueZoom();
          }, 100);
        });

        // Afficher le modal au clic
        img.addEventListener("click", function (e) {
          e.stopPropagation();
          showFabriqueZoom(img.src);
        });
      }

      // Fonction pour afficher le modal d'agrandissement
      function showFabriqueZoom(imageSrc) {
        const modal = document.getElementById("fabriqueZoomModal");
        if (modal) {
          const zoomImg = modal.querySelector("img");
          if (zoomImg && imageSrc) {
            zoomImg.src = imageSrc;
          }
          modal.classList.add("active");
        }
      }

      // Fonction pour fermer le modal d'agrandissement
      function closeFabriqueZoom() {
        const modal = document.getElementById("fabriqueZoomModal");
        if (modal) {
          modal.classList.remove("active");
        }
      }

      // Variable globale pour empêcher le dessin pendant le zoom
      let isZooming = false;
      let pixelGridCurrentScale = 1;

      // Fonction pour configurer le zoom pinch sur la grille (mobile) et molette (PC)
      function setupPixelGridZoom() {
        const pixelGrid = document.getElementById("pixelGrid");
        if (!pixelGrid) return;

        let initialDistance = 0;
        let minScale = 0.5;
        let maxScale = 3;
        pixelGridCurrentScale = 1;

        // Calculer la distance entre deux points tactiles
        function getDistance(touch1, touch2) {
          const dx = touch2.clientX - touch1.clientX;
          const dy = touch2.clientY - touch1.clientY;
          return Math.sqrt(dx * dx + dy * dy);
        }

        // Zoom pinch sur mobile/tablette
        pixelGrid.addEventListener(
          "touchstart",
          function (e) {
            if (e.touches.length === 2) {
              e.preventDefault();
              isZooming = true;
              initialDistance = getDistance(e.touches[0], e.touches[1]);
            } else if (e.touches.length === 1) {
              isZooming = false;
            }
          },
          { passive: false }
        );

        pixelGrid.addEventListener(
          "touchmove",
          function (e) {
            if (e.touches.length === 2) {
              e.preventDefault();
              isZooming = true;
              const currentDistance = getDistance(e.touches[0], e.touches[1]);
              if (initialDistance > 0) {
                const scale = currentDistance / initialDistance;
                const newScale = Math.max(
                  minScale,
                  Math.min(maxScale, pixelGridCurrentScale * scale)
                );

                pixelGrid.style.transform = `scale(${newScale})`;
                pixelGrid.style.transformOrigin = "center center";
              }
            } else if (e.touches.length === 1 && isZooming) {
              // Si on passe de 2 doigts à 1, arrêter le zoom
              isZooming = false;
            }
          },
          { passive: false }
        );

        pixelGrid.addEventListener(
          "touchend",
          function (e) {
            if (e.touches.length < 2 && initialDistance > 0) {
              if (pixelGrid.style.transform) {
                const match =
                  pixelGrid.style.transform.match(/scale\(([^)]+)\)/);
                if (match) {
                  pixelGridCurrentScale = parseFloat(match[1]);
                }
              }
              initialDistance = 0;
              // Attendre un peu avant de réactiver le dessin pour éviter les tracés accidentels
              setTimeout(() => {
                isZooming = false;
              }, 100);
            } else if (e.touches.length === 0) {
              isZooming = false;
            }
          },
          { passive: false }
        );

        // Zoom molette sur PC
        pixelGrid.addEventListener(
          "wheel",
          function (e) {
            e.preventDefault();
            isZooming = true;

            const delta = e.deltaY > 0 ? 0.9 : 1.1; // Réduire ou augmenter de 10%
            const newScale = Math.max(
              minScale,
              Math.min(maxScale, pixelGridCurrentScale * delta)
            );

            pixelGridCurrentScale = newScale;
            pixelGrid.style.transform = `scale(${newScale})`;
            pixelGrid.style.transformOrigin = "center center";

            // Réactiver le dessin après un court délai
            setTimeout(() => {
              isZooming = false;
            }, 100);
          },
          { passive: false }
        );
      }

      // Fonction pour fermer le modal pixel art
      function closePixelArtModal() {
        const modal = document.getElementById("pixelArtModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Fonction pour améliorer le bouton d'enregistrement sur mobile/tablette
      function setupSaveButton() {
        const saveBtn = document.getElementById("savePixelArtBtn");
        if (!saveBtn) return;

        // Empêcher le double déclenchement
        let isSaving = false;
        const handleSave = async function (e) {
          if (e) {
            e.preventDefault();
            e.stopPropagation();
          }

          if (isSaving) return;
          isSaving = true;

          try {
            await savePixelArt();
          } finally {
            setTimeout(() => {
              isSaving = false;
            }, 500);
          }
        };

        // Supprimer les anciens event listeners pour éviter les doublons
        const newSaveBtn = saveBtn.cloneNode(true);
        saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);

        // Ajouter les événements pour mobile et desktop
        newSaveBtn.addEventListener("click", handleSave);
        newSaveBtn.addEventListener("touchend", handleSave, { passive: false });
      }

      // Fonction pour améliorer le bouton de fermeture sur mobile/tablette
      function setupCloseButton() {
        const closeBtn = document.getElementById("closePixelArtModal");
        if (!closeBtn) return;

        // Empêcher le double déclenchement
        let isClosing = false;
        const handleClose = function (e) {
          if (e) {
            e.preventDefault();
            e.stopPropagation();
          }

          if (isClosing) return;
          isClosing = true;

          try {
            closePixelArtModal();
          } finally {
            setTimeout(() => {
              isClosing = false;
            }, 300);
          }
        };

        // Supprimer les anciens event listeners pour éviter les doublons
        const newCloseBtn = closeBtn.cloneNode(true);
        closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

        // Ajouter les événements pour mobile et desktop
        newCloseBtn.addEventListener("click", handleClose);
        newCloseBtn.addEventListener("touchend", handleClose, {
          passive: false,
        });
      }

      // Fonction pour améliorer tous les boutons pour mobile/tablette
      function setupAllButtonsForMobile() {
        // Sélectionner tous les boutons
        const allButtons = document.querySelectorAll("button");

        allButtons.forEach((button) => {
          // Éviter de traiter plusieurs fois le même bouton
          if (button.dataset.mobileSetup === "true") return;
          button.dataset.mobileSetup = "true";

          // Ajouter les styles CSS pour mobile
          button.style.touchAction = "manipulation";
          button.style.userSelect = "none";
          button.style.webkitUserSelect = "none";
          button.style.mozUserSelect = "none";
          button.style.msUserSelect = "none";
          button.style.webkitTapHighlightColor = "transparent";

          // S'assurer que le bouton a un cursor pointer
          if (!button.style.cursor || button.style.cursor === "auto") {
            button.style.cursor = "pointer";
          }

          // Ajouter un gestionnaire touchend pour mobile
          // Empêcher le double déclenchement
          let isHandling = false;

          const handleTouch = function (e) {
            if (isHandling) {
              e.preventDefault();
              e.stopPropagation();
              return;
            }

            isHandling = true;
            e.preventDefault();
            e.stopPropagation();

            // Déclencher le clic programmatiquement
            button.click();

            setTimeout(() => {
              isHandling = false;
            }, 300);
          };

          // Ajouter l'événement touchend
          button.addEventListener("touchend", handleTouch, { passive: false });
        });
      }

      // Fonction pour changer de palette
      function changePalette(paletteType) {
        // Vérifier si un dessin existe
        if (hasDrawing()) {
          alert(
            "Impossible de changer de palette !\n\n" +
              "Un dessin a déjà été commencé avec la palette actuelle.\n" +
              "Vous devez terminer ou effacer votre dessin (page blanche) avant de pouvoir changer de palette."
          );
          // Remettre le sélecteur à la palette actuelle
          const paletteSelector = document.getElementById("paletteSelector");
          if (paletteSelector) {
            paletteSelector.value = currentPaletteType;
          }
          return; // Empêcher le changement
        }

        // Si pas de dessin, permettre le changement
        currentPaletteType = paletteType;
        // Recharger l'éditeur avec la nouvelle palette
        openPixelArtEditor();
      }

      // Fonction pour ouvrir l'éditeur pixel art
      function openPixelArtEditor() {
        const modal = document.getElementById("pixelArtModal");
        const content = document.getElementById("pixelArtContent");

        // Générer les triplets et les couleurs selon la palette sélectionnée
        const triplets = generateAllTriplets();
        let colors;
        let paletteName;
        if (currentPaletteType === "CCC") {
          colors = generateVanGoghColors();
          paletteName = "Palette Van Gogh";
        } else if (currentPaletteType === "GGG") {
          colors = generateKlimtColors();
          paletteName = "Palette Gustav Klimt";
        } else if (currentPaletteType === "TTT") {
          colors = generateMonetColors();
          paletteName = "Palette Claude Monet";
        } else {
          colors = generate64Colors();
          paletteName = "Palette classique";
          currentPaletteType = "AAA"; // S'assurer que c'est AAA par défaut
        }
        colorPalette = colors;

        // Créer les mappings
        triplets.forEach((triplet, index) => {
          tripletToColorMap[triplet] = colors[index];
          colorToTripletMap[colors[index]] = triplet;
        });

        // Initialiser la grille avec la première couleur de la palette pour tous les carreaux si elle n'existe pas déjà
        const gridWidth = 70;
        const gridHeight = 70; // Hauteur de base
        if (pixelArtGrid.length === 0) {
          // Créer une nouvelle grille 70x70
          pixelArtGrid = [];
          for (let i = 0; i < gridHeight; i++) {
            pixelArtGrid[i] = [];
            for (let j = 0; j < gridWidth; j++) {
              pixelArtGrid[i][j] = 0; // Index 0 = première couleur de la palette
            }
          }
        } else {
          // S'assurer que toutes les lignes existantes ont 70 colonnes
          for (let i = 0; i < pixelArtGrid.length; i++) {
            if (!pixelArtGrid[i]) {
              pixelArtGrid[i] = [];
            }
            // Compléter les colonnes manquantes
            for (let j = pixelArtGrid[i].length; j < gridWidth; j++) {
              pixelArtGrid[i][j] = 0;
            }
          }
        }

        // Initialiser la séquence dans dnaOutput seulement si un dessin existe déjà
        // Sinon, laisser dnaOutput vide pour afficher le message par défaut
        const dnaOutput = document.getElementById("dnaOutput");
        if (hasDrawing()) {
          // Si un dessin existe, mettre à jour la séquence
          updateDNASequence();
        } else {
          // Si pas de dessin, vider dnaOutput pour afficher le message par défaut
          dnaOutput.textContent = "";
          dnaOutput.removeAttribute("data-dna-sequence");
          // Cacher le label
          updateDnaOutputLabel();
        }

        // Afficher le bouton d'export
        const exportBtn = document.getElementById("exportBtn");
        if (exportBtn) exportBtn.style.display = "inline-block";

        // Initialiser l'historique
        pixelArtHistory = [JSON.parse(JSON.stringify(pixelArtGrid))];
        pixelArtHistoryIndex = 0;
        currentTool = "paint";
        shapeStartPos = null;

        // Créer l'interface
        let html = '<div style="display: flex; gap: 20px; flex-wrap: wrap;">';

        // Palette de couleurs (64 couleurs)
        html += '<div style="flex: 0 0 200px;">';
        html += '<div style="margin-bottom: 15px;">';

        // Vérifier si un dessin existe
        const drawingExists = hasDrawing();
        const disabledStyle = drawingExists
          ? "padding: 8px; border: 2px solid #ccc; border-radius: 6px; font-size: 1rem; width: 100%; background-color: #f5f5f5; color: #999; cursor: not-allowed;"
          : "padding: 8px; border: 2px solid #667eea; border-radius: 6px; font-size: 1rem; width: 100%;";

        html +=
          '<label style="display: block; margin-bottom: 5px; font-weight: bold; color: #667eea;">Sélectionner la palette :</label>';
        html += `<select id="paletteSelector" onchange="changePalette(this.value)" ${
          drawingExists ? "disabled" : ""
        } style="${disabledStyle}">`;
        html += `<option value="AAA" ${
          currentPaletteType === "AAA" ? "selected" : ""
        }>Palette classique (AAA)</option>`;
        html += `<option value="CCC" ${
          currentPaletteType === "CCC" ? "selected" : ""
        }>Palette Van Gogh (CCC)</option>`;
        html += `<option value="GGG" ${
          currentPaletteType === "GGG" ? "selected" : ""
        }>Palette Gustav Klimt (GGG)</option>`;
        html += `<option value="TTT" ${
          currentPaletteType === "TTT" ? "selected" : ""
        }>Palette Claude Monet (TTT)</option>`;
        html += "</select>";

        // Afficher un message d'avertissement si un dessin existe
        if (drawingExists) {
          html +=
            '<div style="margin-top: 8px; padding: 8px; background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; font-size: 0.85rem; color: #856404;">';
          html +=
            "⚠️ Impossible de changer de palette : un dessin a déjà été commencé.";
          html += "</div>";
        }

        html += "</div>";
        html += `<h3 style="margin-top: 0; color: #667eea;">${paletteName}</h3>`;
        html +=
          '<div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 5px; margin-bottom: 20px;">';
        colors.forEach((color, index) => {
          const triplet = triplets[index];
          html += `<div
            class="color-swatch"
            data-color-index="${index}"
            data-triplet="${triplet}"
            style="
              width: 20px;
              height: 20px;
              background: ${color};
              border: 2px solid #333;
              cursor: pointer;
              border-radius: 3px;
            "
            title="${triplet} - ${color}"
            onclick="selectColor(${index})"
          ></div>`;
        });
        html += "</div>";
        html +=
          '<div id="selectedColorInfo" style="padding: 10px; background: #f0f0f0; border-radius: 6px; margin-top: 10px;">';
        html +=
          '<strong>Triplet sélectionné:</strong> <span id="selectedTriplet">AAA</span>';
        html += "</div>";
        // Ajouter l'image de la fabrique en dessous de la palette
        html +=
          '<div class="pixel-art-illustration" id="fabriqueImageContainer" style="flex-shrink: 0; max-width: 100%; width: 100%; margin-top: 20px; display: flex; align-items: center; justify-content: center; background: #f0f0f0; border-radius: 8px; min-height: 200px;">';
        html +=
          '<span style="color: #666; font-size: 0.9rem;">Chargement de l\'image...</span>';
        html += "</div>";
        html += "</div>";

        // Grille de pixel art (image maintenant sous la palette)
        html += '<div style="flex: 1; min-width: 0; width: 100%; max-width: 100%; box-sizing: border-box;">';
        html += '<h3 style="margin-top: 0; color: #667eea;">Grille 70×70</h3>';
        html +=
          '<div style="display: flex; flex-direction: column; width: 100%;">';

        // Barre d'outils
        html +=
          '<div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; align-items: center;">';
        html +=
          '<button id="undoBtn" onclick="undoPixelArt()" style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Annuler (Ctrl+Z)">↶ Annuler</button>';
        html +=
          '<button id="redoBtn" onclick="redoPixelArt()" style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Refaire (Ctrl+Y)">↷ Refaire</button>';
        html +=
          '<button id="clearBtn" onclick="clearPixelArt()" style="padding: 8px 16px; background: #ff6b6b; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Effacer toute la grille">🧼 Page blanche</button>';
        html +=
          '<button id="toggleBorderBtn" onclick="togglePixelBorder()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Basculer entre contour blanc et noir">⚫ Contour ' +
          (pixelBorderColor === "black" ? "noir" : "blanc") +
          "</button>";
        html +=
          '<div style="width: 1px; height: 30px; background: #ccc; margin: 0 5px;"></div>';
        html +=
          '<button id="paintToolBtn" onclick="openSizeModal(\'brush\')" style="padding: 8px 16px; background: #51cf66; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Pinceau (Taille: ' +
          brushSize +
          ') - Cliquez pour changer la taille">🖌️ Pinceau (' +
          brushSize +
          ")</button>";
        html +=
          '<button id="sprayToolBtn" onclick="openSizeModal(\'spray\')" style="padding: 8px 16px; background: #51cf66; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Aérographe (Taille: ' +
          spraySize +
          ') - Cliquez pour changer la taille">🎨 Aérographe (' +
          spraySize +
          ")</button>";
        html +=
          '<button id="eyedropperToolBtn" onclick="selectTool(\'eyedropper\')" style="padding: 8px 16px; background: #9b59b6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Pipette - Cliquez sur un pixel pour prélever sa couleur">💧 Pipette</button>';
        html +=
          '<button id="eraseToolBtn" onclick="openSizeModal(\'eraser\')" style="padding: 8px 16px; background: #ff6b6b; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Gomme (Taille: ' +
          eraserSize +
          ') - Cliquez pour changer la taille">🧹 Gomme (' +
          eraserSize +
          ")</button>";
        html += "</div>";

        // Deuxième ligne : Formes géométriques
        html +=
          '<div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; align-items: center;">';
        html +=
          '<button id="circleToolBtn" onclick="selectTool(\'circle\')" style="padding: 8px 16px; background: #ffa94d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Cercle - Cliquez et glissez">⭕ Cercle</button>';
        html +=
          '<button id="squareToolBtn" onclick="selectTool(\'square\')" style="padding: 8px 16px; background: #ffa94d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Carré - Cliquez et glissez">⬜ Carré</button>';
        html +=
          '<button id="triangleToolBtn" onclick="selectTool(\'triangle\')" style="padding: 8px 16px; background: #ffa94d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Triangle - Cliquez et glissez">🔺 Triangle</button>';
        html +=
          '<button id="starToolBtn" onclick="selectTool(\'star\')" style="padding: 8px 16px; background: #ffa94d; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem; text-shadow: -1px -1px 0 rgba(0, 0, 0, 0.9), 1px -1px 0 rgba(0, 0, 0, 0.9), -1px 1px 0 rgba(0, 0, 0, 0.9), 1px 1px 0 rgba(0, 0, 0, 0.9), 0 0 3px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);" title="Étoile - Cliquez et glissez">⭐ Étoile</button>';
        html += "</div>";
        html +=
          '<div id="toolStatus" style="margin-bottom: 10px; padding: 8px; background: #f0f0f0; border-radius: 6px; font-size: 0.9rem; color: #666;"></div>';

        // Déterminer la taille réelle de la grille
        const actualGridWidth = 70;
        const actualGridHeight = pixelArtGrid.length || 70;

        // Conteneur pour la grille (image maintenant sous la palette)
        html += '<div id="pixelGrid" style="display: grid; grid-template-columns: repeat(' +
          actualGridWidth +
          ', 1fr); grid-template-rows: repeat(' +
          actualGridHeight +
          ', 1fr); gap: 0; background: ' +
          pixelBorderColor +
          '; border: 2px solid #333; padding: 0; width: 100%; max-width: 100%; aspect-ratio: ' +
          actualGridWidth +
          '/' +
          actualGridHeight +
          '; user-select: none; touch-action: pan-x pan-y pinch-zoom; flex: 1; overflow: visible; transition: transform 0.1s ease-out; box-sizing: border-box;">';

        for (let i = 0; i < actualGridHeight; i++) {
          for (let j = 0; j < actualGridWidth; j++) {
            const colorIndex =
              pixelArtGrid[i] && pixelArtGrid[i][j] !== undefined
                ? pixelArtGrid[i][j]
                : 0;
            const color = colors[colorIndex];
            // Bordures uniquement sur le côté droit et le bas pour créer un seul trait entre les pixels
            const borderRight =
              j < actualGridWidth - 1
                ? `1px solid ${pixelBorderColor}`
                : "none";
            const borderBottom =
              i < actualGridHeight - 1
                ? `1px solid ${pixelBorderColor}`
                : "none";
            html += `<div
              class="pixel-cell"
              data-row="${i}"
              data-col="${j}"
              style="
                width: 100%;
                height: 100%;
                aspect-ratio: 1;
                background: ${color};
                cursor: crosshair;
                border-right: ${borderRight};
                border-bottom: ${borderBottom};
                touch-action: none;
              "
            ></div>`;
          }
        }
        html += "</div>"; // Fin de pixelGrid
        html += "</div>"; // Fin du conteneur flex de la grille
        html += "</div>"; // Fin du conteneur flex principal

        // Mettre à jour la séquence ADN avec la grille actuelle
        updateDNASequence();

        html += "</div>";

        content.innerHTML = html;
        modal.style.display = "block";

        // Charger l'image de la fabrique depuis Dropbox
        loadFabriqueImage();

        // Configurer le zoom pinch pour la grille sur mobile
        setupPixelGridZoom();

        // Configurer les boutons pour mobile/tablette
        setupSaveButton();
        setupCloseButton();

        // Configurer tous les autres boutons du modal pour mobile/tablette
        setTimeout(setupAllButtonsForMobile, 100);

        // Mettre à jour le sélecteur de palette
        const paletteSelector = document.getElementById("paletteSelector");
        if (paletteSelector) {
          paletteSelector.value = currentPaletteType;
        }

        // Mettre à jour l'état du sélecteur (actif/désactivé selon si un dessin existe)
        // Ne pas appeler updatePaletteSelectorState() ici car le message est déjà dans le HTML
        // On met juste à jour l'état du sélecteur sans recréer le message
        setTimeout(() => {
          const drawingExists = hasDrawing();
          if (paletteSelector) {
            paletteSelector.disabled = drawingExists;
            if (drawingExists) {
              paletteSelector.style.border = "2px solid #ccc";
              paletteSelector.style.backgroundColor = "#f5f5f5";
              paletteSelector.style.color = "#999";
              paletteSelector.style.cursor = "not-allowed";
            } else {
              paletteSelector.style.border = "2px solid #667eea";
              paletteSelector.style.backgroundColor = "";
              paletteSelector.style.color = "";
              paletteSelector.style.cursor = "";
            }
          }
        }, 100);

        // Initialiser la couleur sélectionnée (noir par défaut, index 56)
        window.selectedColorIndex = 56;
        updateSelectedColorDisplay();
        updateDNASequence();

        // Sélectionner visuellement la couleur noire dans la palette et le pinceau
        setTimeout(() => {
          selectColor(56);
          selectTool("paint");
        }, 100);

        // Ajouter les event listeners pour les pixels
        setTimeout(() => {
          const pixelCells = document.querySelectorAll(".pixel-cell");
          let isPainting = false;
          let lastPaintRow = -1;
          let lastPaintCol = -1;

          pixelCells.forEach((cell) => {
            // Utiliser l'API Pointer Events pour une meilleure prise en charge des stylets et du tactile
            cell.addEventListener("pointerdown", function (e) {
              // Empêcher le dessin pendant le zoom
              if (isZooming) return;

              e.preventDefault();
              const row = parseInt(this.getAttribute("data-row"));
              const col = parseInt(this.getAttribute("data-col"));

              if (
                currentTool === "paint" ||
                currentTool === "spray" ||
                currentTool === "erase" ||
                currentTool === "eyedropper"
              ) {
                if (currentTool === "eyedropper") {
                  // Pour la pipette, pas besoin de capturer le pointeur, juste prélever la couleur
                  pickColorWithEyedropper(row, col);
                } else {
                  isPainting = true;
                  lastPaintRow = -1;
                  lastPaintCol = -1;
                  paintPixel(row, col);
                  // Capturer le pointeur sur la grille pour une meilleure fluidité
                  const pixelGrid = document.getElementById("pixelGrid");
                  if (pixelGrid) {
                    pixelGrid.setPointerCapture(e.pointerId);
                  }
                }
              } else if (
                currentTool === "circle" ||
                currentTool === "square" ||
                currentTool === "triangle" ||
                currentTool === "star"
              ) {
                // Formes géométriques : clic = point de départ, glissement pour ajuster
                isPainting = true;
                shapeStartPos = { row, col };
                // Sauvegarder l'état actuel de la grille pour la prévisualisation
                shapePreviewGrid = JSON.parse(JSON.stringify(pixelArtGrid));
                // Capturer le pointeur sur la grille
                const pixelGrid = document.getElementById("pixelGrid");
                if (pixelGrid) {
                  pixelGrid.setPointerCapture(e.pointerId);
                }
              }
            });

            cell.addEventListener("pointerup", function (e) {
              // Libérer le pointeur sur la grille
              const pixelGrid = document.getElementById("pixelGrid");
              if (pixelGrid) {
                pixelGrid.releasePointerCapture(e.pointerId);
              }
              if (isPainting) {
                const row = parseInt(this.getAttribute("data-row"));
                const col = parseInt(this.getAttribute("data-col"));

                if (
                  currentTool === "paint" ||
                  currentTool === "spray" ||
                  currentTool === "erase"
                ) {
                  isPainting = false;
                  lastPaintRow = -1;
                  lastPaintCol = -1;
                  // Annuler le requestAnimationFrame en cours
                  if (rafId !== null) {
                    cancelAnimationFrame(rafId);
                    rafId = null;
                  }
                  // Mettre à jour la séquence ADN et sauvegarder l'historique à la fin du trait
                  updateDNASequence();
                  saveToHistory();
                } else if (
                  currentTool === "circle" ||
                  currentTool === "square" ||
                  currentTool === "triangle" ||
                  currentTool === "star"
                ) {
                  // Finaliser la forme
                  if (shapeStartPos) {
                    finalizeShape(
                      shapeStartPos.row,
                      shapeStartPos.col,
                      row,
                      col
                    );
                    shapeStartPos = null;
                    shapePreviewGrid = null;
                    isPainting = false;
                    saveToHistory();
                  }
                }
              }
            });

            cell.addEventListener("pointerleave", function (e) {
              // Libérer le pointeur si on sort de la cellule
              if (e.pointerId !== undefined) {
                this.releasePointerCapture(e.pointerId);
              }
            });
          });

          // Gestionnaire pointermove sur la grille entière pour une meilleure fluidité
          const pixelGrid = document.getElementById("pixelGrid");
          let rafId = null;
          if (pixelGrid) {
            pixelGrid.addEventListener("pointermove", function (e) {
              // Empêcher le dessin pendant le zoom
              if (isZooming) {
                isPainting = false;
                return;
              }

              if (e.buttons === 1 && isPainting) {
                e.preventDefault();

                // Utiliser requestAnimationFrame pour une meilleure fluidité
                if (rafId !== null) {
                  cancelAnimationFrame(rafId);
                }

                rafId = requestAnimationFrame(function () {
                  // Trouver la cellule sous le pointeur en utilisant elementFromPoint
                  const element = document.elementFromPoint(
                    e.clientX,
                    e.clientY
                  );
                  if (element && element.classList.contains("pixel-cell")) {
                    const row = parseInt(element.getAttribute("data-row"));
                    const col = parseInt(element.getAttribute("data-col"));

                    if (row >= 0 && row < 70 && col >= 0 && col < 70) {
                      if (
                        currentTool === "paint" ||
                        currentTool === "spray" ||
                        currentTool === "erase"
                      ) {
                        // Interpolation : peindre toutes les cellules entre la dernière position et la position actuelle
                        if (lastPaintRow >= 0 && lastPaintCol >= 0) {
                          const dx = col - lastPaintCol;
                          const dy = row - lastPaintRow;
                          const distance = Math.max(Math.abs(dx), Math.abs(dy));

                          if (distance > 1) {
                            // Remplir les trous entre les positions
                            for (let i = 0; i <= distance; i++) {
                              const t = distance > 0 ? i / distance : 0;
                              const interpRow = Math.round(
                                lastPaintRow + dy * t
                              );
                              const interpCol = Math.round(
                                lastPaintCol + dx * t
                              );
                              if (
                                interpRow >= 0 &&
                                interpRow < 70 &&
                                interpCol >= 0 &&
                                interpCol < 70
                              ) {
                                paintPixel(interpRow, interpCol, true);
                              }
                            }
                          } else {
                            paintPixel(row, col, true);
                          }
                        } else {
                          paintPixel(row, col, true);
                        }
                        lastPaintRow = row;
                        lastPaintCol = col;
                      } else if (
                        currentTool === "circle" ||
                        currentTool === "square" ||
                        currentTool === "triangle" ||
                        currentTool === "star"
                      ) {
                        // Restaurer la grille sauvegardée puis dessiner la forme
                        if (shapePreviewGrid && shapeStartPos) {
                          pixelArtGrid = JSON.parse(
                            JSON.stringify(shapePreviewGrid)
                          );
                          previewShape(
                            shapeStartPos.row,
                            shapeStartPos.col,
                            row,
                            col
                          );
                        }
                      }
                    }
                  }
                  rafId = null;
                });
              }
            });

            pixelGrid.addEventListener("pointerleave", function (e) {
              if (isPainting) {
                if (
                  currentTool === "paint" ||
                  currentTool === "spray" ||
                  currentTool === "erase"
                ) {
                  isPainting = false;
                  lastPaintRow = -1;
                  lastPaintCol = -1;
                  // Annuler le requestAnimationFrame en cours
                  if (rafId !== null) {
                    cancelAnimationFrame(rafId);
                    rafId = null;
                  }
                  updateDNASequence();
                  saveToHistory();
                } else if (
                  currentTool === "circle" ||
                  currentTool === "square" ||
                  currentTool === "triangle" ||
                  currentTool === "star"
                ) {
                  // Finaliser la forme avec la dernière position connue
                  if (shapeStartPos) {
                    // Utiliser la position de départ comme position finale si on sort
                    finalizeShape(
                      shapeStartPos.row,
                      shapeStartPos.col,
                      shapeStartPos.row,
                      shapeStartPos.col
                    );
                    shapeStartPos = null;
                    shapePreviewGrid = null;
                    isPainting = false;
                    saveToHistory();
                  }
                }
              }
            });
          }

          // Arrêter de peindre si on relâche le pointeur n'importe où
          document.addEventListener("pointerup", function (e) {
            // Libérer le pointeur sur la grille
            const pixelGrid = document.getElementById("pixelGrid");
            if (pixelGrid) {
              pixelGrid.releasePointerCapture(e.pointerId);
            }
            if (isPainting) {
              if (
                currentTool === "paint" ||
                currentTool === "spray" ||
                currentTool === "erase"
              ) {
                isPainting = false;
                lastPaintRow = -1;
                lastPaintCol = -1;
                // Annuler le requestAnimationFrame en cours
                if (rafId !== null) {
                  cancelAnimationFrame(rafId);
                  rafId = null;
                }
                updateDNASequence();
                saveToHistory();
              } else if (
                currentTool === "circle" ||
                currentTool === "square" ||
                currentTool === "triangle" ||
                currentTool === "star"
              ) {
                // Finaliser la forme
                if (shapeStartPos) {
                  // Utiliser la position de départ comme position finale
                  finalizeShape(
                    shapeStartPos.row,
                    shapeStartPos.col,
                    shapeStartPos.row,
                    shapeStartPos.col
                  );
                  shapeStartPos = null;
                  shapePreviewGrid = null;
                  isPainting = false;
                  saveToHistory();
                }
              }
            }
          });

          // Désactiver les actions par défaut du navigateur (zoom, sélection, etc.)
          if (pixelGrid) {
            pixelGrid.addEventListener(
              "touchstart",
              function (e) {
                if (e.touches.length > 1) {
                  e.preventDefault(); // Empêcher le zoom à deux doigts
                }
              },
              { passive: false }
            );

            pixelGrid.addEventListener(
              "touchmove",
              function (e) {
                if (e.touches.length > 1) {
                  e.preventDefault(); // Empêcher le zoom à deux doigts
                }
              },
              { passive: false }
            );
          }

          // Raccourcis clavier pour undo/redo
          document.addEventListener("keydown", function (e) {
            if ((e.ctrlKey || e.metaKey) && e.key === "z" && !e.shiftKey) {
              e.preventDefault();
              undoPixelArt();
            } else if (
              (e.ctrlKey || e.metaKey) &&
              (e.key === "y" || (e.key === "z" && e.shiftKey))
            ) {
              e.preventDefault();
              redoPixelArt();
            }
          });

          // Initialiser les boutons de taille
          setBrushSize(brushSize);
          setSpraySize(spraySize);
          setEraserSize(eraserSize);

          // Initialiser les boutons d'outils (après l'initialisation des tailles)
          selectTool("paint");
          updateUndoRedoButtons();

          // Fermer la modale de taille
          const closeSizeModalBtn = document.getElementById("closeSizeModal");
          if (closeSizeModalBtn) {
            closeSizeModalBtn.addEventListener("click", closeSizeModal);
          }
          const sizeModal = document.getElementById("sizeModal");
          if (sizeModal) {
            sizeModal.addEventListener("click", function (e) {
              if (e.target === this) {
                closeSizeModal();
              }
            });
          }

          // Fermer les modales d'import/export
          const closeImportModalBtn =
            document.getElementById("closeImportModal");
          if (closeImportModalBtn) {
            closeImportModalBtn.addEventListener("click", closeImportModal);
          }
          const importModal = document.getElementById("importModal");
          if (importModal) {
            importModal.addEventListener("click", function (e) {
              if (e.target === this) {
                closeImportModal();
              }
            });
          }

          const closeExportModalBtn =
            document.getElementById("closeExportModal");
          if (closeExportModalBtn) {
            closeExportModalBtn.addEventListener("click", closeExportModal);
          }
          const exportModal = document.getElementById("exportModal");
          if (exportModal) {
            exportModal.addEventListener("click", function (e) {
              if (e.target === this) {
                closeExportModal();
              }
            });
          }

          // Event listeners pour la modale de sauvegarde
          const closeSaveFileModalBtn =
            document.getElementById("closeSaveFileModal");
          if (closeSaveFileModalBtn) {
            closeSaveFileModalBtn.addEventListener("click", closeSaveFileModal);
          }
          const saveFileModal = document.getElementById("saveFileModal");
          if (saveFileModal) {
            saveFileModal.addEventListener("click", function (e) {
              if (e.target === this) {
                closeSaveFileModal();
              }
            });
          }

          // Permettre d'appuyer sur Entrée pour confirmer
          const fileNameInput = document.getElementById("fileNameInput");
          if (fileNameInput) {
            fileNameInput.addEventListener("keypress", function (e) {
              if (e.key === "Enter") {
                confirmSaveFile();
              }
            });
          }
        }, 10);
      }

      // Fonction pour sélectionner une couleur
      function selectColor(colorIndex) {
        window.selectedColorIndex = colorIndex;
        updateSelectedColorDisplay();

        // Mettre à jour l'affichage des swatches
        document.querySelectorAll(".color-swatch").forEach((swatch, index) => {
          if (index === colorIndex) {
            swatch.style.border = "3px solid #667eea";
            swatch.style.transform = "scale(1.1)";
          } else {
            swatch.style.border = "2px solid #333";
            swatch.style.transform = "scale(1)";
          }
        });
      }

      // Fonction pour mettre à jour l'affichage de la couleur sélectionnée
      function updateSelectedColorDisplay() {
        const selectedTripletSpan = document.getElementById("selectedTriplet");
        if (selectedTripletSpan && window.selectedColorIndex !== undefined) {
          const triplets = generateAllTriplets();
          selectedTripletSpan.textContent = triplets[window.selectedColorIndex];
        }
      }

      // Fonction pour sauvegarder l'état actuel dans l'historique
      function saveToHistory() {
        // Supprimer les états futurs si on n'est pas à la fin
        pixelArtHistory = pixelArtHistory.slice(0, pixelArtHistoryIndex + 1);
        // Ajouter le nouvel état
        pixelArtHistory.push(JSON.parse(JSON.stringify(pixelArtGrid)));
        pixelArtHistoryIndex++;
        // Limiter l'historique à 50 états
        if (pixelArtHistory.length > 50) {
          pixelArtHistory.shift();
          pixelArtHistoryIndex--;
        }
        updateUndoRedoButtons();
        // Mettre à jour l'état du sélecteur de palette après chaque modification
        updatePaletteSelectorState();
      }

      // Fonction pour annuler
      function undoPixelArt() {
        if (pixelArtHistoryIndex > 0) {
          pixelArtHistoryIndex--;
          pixelArtGrid = JSON.parse(
            JSON.stringify(pixelArtHistory[pixelArtHistoryIndex])
          );
          refreshPixelGrid();
          updateDNASequence();
          updateUndoRedoButtons();
          // Mettre à jour l'état du sélecteur de palette
          updatePaletteSelectorState();
        }
      }

      // Fonction pour refaire
      function redoPixelArt() {
        if (pixelArtHistoryIndex < pixelArtHistory.length - 1) {
          pixelArtHistoryIndex++;
          pixelArtGrid = JSON.parse(
            JSON.stringify(pixelArtHistory[pixelArtHistoryIndex])
          );
          refreshPixelGrid();
          updateDNASequence();
          updateUndoRedoButtons();
          // Mettre à jour l'état du sélecteur de palette
          updatePaletteSelectorState();
        }
      }

      // Fonction pour mettre à jour les boutons undo/redo
      function updateUndoRedoButtons() {
        const undoBtn = document.getElementById("undoBtn");
        const redoBtn = document.getElementById("redoBtn");
        if (undoBtn) {
          undoBtn.disabled = pixelArtHistoryIndex <= 0;
          undoBtn.style.opacity = undoBtn.disabled ? "0.5" : "1";
        }
        if (redoBtn) {
          redoBtn.disabled = pixelArtHistoryIndex >= pixelArtHistory.length - 1;
          redoBtn.style.opacity = redoBtn.disabled ? "0.5" : "1";
        }
      }

      // Fonction pour sélectionner un outil
      function selectTool(tool) {
        currentTool = tool;
        shapeStartPos = null;

        // Mettre à jour l'apparence des boutons
        const tools = [
          "paint",
          "spray",
          "eyedropper",
          "erase",
          "circle",
          "square",
          "triangle",
          "star",
        ];
        tools.forEach((t) => {
          const btn = document.getElementById(t + "ToolBtn");
          if (btn) {
            if (t === tool) {
              btn.style.background = "#667eea";
              btn.style.transform = "scale(1.05)";
            } else {
              if (t === "paint" || t === "spray")
                btn.style.background = "#51cf66";
              else if (t === "eyedropper") btn.style.background = "#9b59b6";
              else if (t === "erase") btn.style.background = "#ff6b6b";
              else btn.style.background = "#ffa94d";
              btn.style.transform = "scale(1)";
            }
          }
        });

        // Mettre à jour le message d'état
        const toolStatus = document.getElementById("toolStatus");
        if (toolStatus) {
          if (tool === "paint") {
            toolStatus.textContent =
              "Outil: Pinceau - Cliquez et glissez pour peindre";
          } else if (tool === "spray") {
            toolStatus.textContent =
              "Outil: Aérographe - Cliquez et glissez pour peindre avec effet spray";
          } else if (tool === "eyedropper") {
            toolStatus.textContent =
              "Outil: Pipette - Cliquez sur un pixel pour prélever sa couleur";
          } else if (tool === "erase") {
            toolStatus.textContent =
              "Outil: Gomme - Cliquez et glissez pour effacer (remet en blanc)";
          } else if (tool === "circle") {
            toolStatus.textContent =
              "Outil: Cercle - Cliquez et glissez pour dessiner un cercle";
          } else if (tool === "square") {
            toolStatus.textContent =
              "Outil: Carré - Cliquez et glissez pour dessiner un carré";
          } else if (tool === "triangle") {
            toolStatus.textContent =
              "Outil: Triangle - Cliquez et glissez pour dessiner un triangle équilatéral";
          } else if (tool === "star") {
            toolStatus.textContent =
              "Outil: Étoile - Cliquez et glissez pour dessiner une étoile";
          }
        }
      }

      // Fonction pour rafraîchir l'affichage de la grille
      function refreshPixelGrid() {
        const gridSize = 70;
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            const pixel = document.querySelector(
              `.pixel-cell[data-row="${i}"][data-col="${j}"]`
            );
            if (pixel) {
              const colorIndex =
                pixelArtGrid[i] && pixelArtGrid[i][j] !== undefined
                  ? pixelArtGrid[i][j]
                  : 0;
              pixel.style.background = colorPalette[colorIndex];
              // Appliquer les bordures uniquement sur les côtés droit et bas (comme dans togglePixelBorder)
              const borderRight =
                j < gridSize - 1 ? `1px solid ${pixelBorderColor}` : "none";
              const borderBottom =
                i < gridSize - 1 ? `1px solid ${pixelBorderColor}` : "none";
              pixel.style.borderRight = borderRight;
              pixel.style.borderBottom = borderBottom;
              pixel.style.borderTop = "none";
              pixel.style.borderLeft = "none";
            }
          }
        }
      }

      // Fonction pour basculer la couleur de bordure des pixels
      function togglePixelBorder() {
        // Basculer entre noir et blanc
        pixelBorderColor = pixelBorderColor === "black" ? "white" : "black";

        // Mettre à jour tous les pixels avec les nouvelles bordures (droite et bas uniquement)
        const pixels = document.querySelectorAll(".pixel-cell");
        const gridSize = 70;
        pixels.forEach((pixel) => {
          const row = parseInt(pixel.getAttribute("data-row"));
          const col = parseInt(pixel.getAttribute("data-col"));
          const borderRight =
            col < gridSize - 1 ? `1px solid ${pixelBorderColor}` : "none";
          const borderBottom =
            row < gridSize - 1 ? `1px solid ${pixelBorderColor}` : "none";
          pixel.style.borderRight = borderRight;
          pixel.style.borderBottom = borderBottom;
          pixel.style.borderTop = "none";
          pixel.style.borderLeft = "none";
        });

        // Mettre à jour le fond de la grille pour correspondre à la couleur de bordure
        const pixelGrid = document.getElementById("pixelGrid");
        if (pixelGrid) {
          pixelGrid.style.background = pixelBorderColor;
        }

        // Mettre à jour le texte du bouton
        const toggleBtn = document.getElementById("toggleBorderBtn");
        if (toggleBtn) {
          toggleBtn.textContent = `⚫ Contour ${
            pixelBorderColor === "black" ? "noir" : "blanc"
          }`;
        }
      }

      // Fonction pour mettre à jour un pixel spécifique dans l'affichage
      function updatePixelDisplay(row, col) {
        const pixel = document.querySelector(
          `.pixel-cell[data-row="${row}"][data-col="${col}"]`
        );
        if (pixel) {
          const colorIndex =
            pixelArtGrid[row] && pixelArtGrid[row][col] !== undefined
              ? pixelArtGrid[row][col]
              : 0;
          pixel.style.background = colorPalette[colorIndex];
        }
      }

      // Fonction pour prélever une couleur avec la pipette
      function pickColorWithEyedropper(row, col) {
        if (row < 0 || row >= 70 || col < 0 || col >= 70) return;

        const colorIndex =
          pixelArtGrid[row] && pixelArtGrid[row][col] !== undefined
            ? pixelArtGrid[row][col]
            : 0;

        // Sélectionner cette couleur dans la palette
        selectColor(colorIndex);

        // Mettre à jour le message d'état
        const toolStatus = document.getElementById("toolStatus");
        if (toolStatus) {
          const triplets = generateAllTriplets();
          const triplet = triplets[colorIndex];
          const color = colorPalette[colorIndex];
          toolStatus.textContent = `Couleur prélevée : ${triplet} (${color})`;
        }
      }

      // Fonction pour peindre un pixel (ou une zone selon la taille)
      function paintPixel(row, col, skipHistory = false) {
        // Si l'outil pipette est sélectionné, prélever la couleur au lieu de peindre
        if (currentTool === "eyedropper") {
          pickColorWithEyedropper(row, col);
          return;
        }

        if (currentTool === "paint") {
          if (window.selectedColorIndex === undefined) return;
          const size = brushSize;
          const halfSize = Math.floor(size / 2);
          // Peindre un carré centré sur le pixel
          for (
            let i = Math.max(0, row - halfSize);
            i <= Math.min(69, row + halfSize);
            i++
          ) {
            for (
              let j = Math.max(0, col - halfSize);
              j <= Math.min(69, col + halfSize);
              j++
            ) {
              pixelArtGrid[i][j] = window.selectedColorIndex;
              // Mettre à jour uniquement ce pixel dans l'affichage
              updatePixelDisplay(i, j);
            }
          }
        } else if (currentTool === "spray") {
          if (window.selectedColorIndex === undefined) return;
          const size = spraySize;
          const radius = size;
          // Aérographe : peindre aléatoirement quelques pixels dans un cercle
          const sprayDensity = 0.25; // 25% de densité
          const numPixels = Math.max(
            1,
            Math.floor(Math.PI * radius * radius * sprayDensity)
          );

          for (let n = 0; n < numPixels; n++) {
            // Générer un point aléatoire dans un cercle
            const angle = Math.random() * 2 * Math.PI;
            const distance = Math.random() * radius;
            const randomRow = Math.round(row + distance * Math.cos(angle));
            const randomCol = Math.round(col + distance * Math.sin(angle));

            if (
              randomRow >= 0 &&
              randomRow < 70 &&
              randomCol >= 0 &&
              randomCol < 70
            ) {
              // Probabilité décroissante avec la distance du centre (effet spray réaliste)
              const distFromCenter = Math.sqrt(
                Math.pow(randomRow - row, 2) + Math.pow(randomCol - col, 2)
              );
              const probability = Math.max(0, 1 - distFromCenter / radius);
              if (Math.random() < probability) {
                pixelArtGrid[randomRow][randomCol] = window.selectedColorIndex;
                updatePixelDisplay(randomRow, randomCol);
              }
            }
          }
        } else if (currentTool === "erase") {
          const size = eraserSize;
          const halfSize = Math.floor(size / 2);
          // Effacer un carré centré sur le pixel
          for (
            let i = Math.max(0, row - halfSize);
            i <= Math.min(69, row + halfSize);
            i++
          ) {
            for (
              let j = Math.max(0, col - halfSize);
              j <= Math.min(69, col + halfSize);
              j++
            ) {
              pixelArtGrid[i][j] = 0; // Blanc (AAA)
              updatePixelDisplay(i, j);
            }
          }
        } else {
          // Pour les formes, on gère différemment
          return;
        }

        // Mettre à jour la séquence ADN seulement si on n'a pas demandé de skip
        if (!skipHistory) {
          // Utiliser un debounce pour éviter trop de mises à jour
          clearTimeout(window.dnaUpdateTimeout);
          window.dnaUpdateTimeout = setTimeout(() => {
            updateDNASequence();
          }, 200);

          // Sauvegarder dans l'historique avec debounce
          clearTimeout(window.paintTimeout);
          window.paintTimeout = setTimeout(() => {
            saveToHistory();
          }, 300);
        }
      }

      // Fonction pour effacer toute la grille (page blanche)
      // Fonction pour mettre à jour l'état du sélecteur de palette
      function updatePaletteSelectorState() {
        const paletteSelector = document.getElementById("paletteSelector");
        if (!paletteSelector) return;

        const drawingExists = hasDrawing();
        if (drawingExists) {
          paletteSelector.disabled = true;
          paletteSelector.style.border = "2px solid #ccc";
          paletteSelector.style.backgroundColor = "#f5f5f5";
          paletteSelector.style.color = "#999";
          paletteSelector.style.cursor = "not-allowed";

          // Vérifier si le message d'avertissement existe déjà (soit dans le HTML généré, soit créé dynamiquement)
          let warningMsg =
            paletteSelector.parentElement.querySelector(".palette-warning") ||
            paletteSelector.parentElement.querySelector(
              'div[style*="background-color: #fff3cd"]'
            );
          if (!warningMsg) {
            warningMsg = document.createElement("div");
            warningMsg.className = "palette-warning";
            warningMsg.style.cssText =
              "margin-top: 8px; padding: 8px; background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; font-size: 0.85rem; color: #856404;";
            warningMsg.textContent =
              "⚠️ Impossible de changer de palette : un dessin a déjà été commencé.";
            paletteSelector.parentElement.appendChild(warningMsg);
          }
        } else {
          paletteSelector.disabled = false;
          paletteSelector.style.border = "2px solid #667eea";
          paletteSelector.style.backgroundColor = "";
          paletteSelector.style.color = "";
          paletteSelector.style.cursor = "";

          // Supprimer le message d'avertissement (soit créé dynamiquement, soit dans le HTML)
          const warningMsg =
            paletteSelector.parentElement.querySelector(".palette-warning") ||
            paletteSelector.parentElement.querySelector(
              'div[style*="background-color: #fff3cd"]'
            );
          if (warningMsg) {
            warningMsg.remove();
          }
        }
      }

      function clearPixelArt() {
        if (
          confirm(
            "Voulez-vous effacer toute la grille ? Cette action ne peut pas être annulée."
          )
        ) {
          const gridSize = 70;
          for (let i = 0; i < gridSize; i++) {
            for (let j = 0; j < gridSize; j++) {
              pixelArtGrid[i][j] = 0; // Blanc (AAA)
            }
          }
          refreshPixelGrid();
          updateDNASequence();
          // Réinitialiser l'historique avec cette nouvelle grille
          pixelArtHistory = [JSON.parse(JSON.stringify(pixelArtGrid))];
          pixelArtHistoryIndex = 0;
          updateUndoRedoButtons();
          // Réactiver le sélecteur de palette car le dessin est effacé
          updatePaletteSelectorState();
        }
      }

      // Fonction pour définir la taille du pinceau
      function setBrushSize(size) {
        brushSize = size;
        // Mettre à jour le texte du bouton
        const btn = document.getElementById("paintToolBtn");
        if (btn) {
          btn.textContent = "🖌️ Pinceau (" + size + ")";
          btn.title =
            "Pinceau (Taille: " + size + ") - Cliquez pour changer la taille";
        }
        // Sélectionner l'outil si ce n'est pas déjà fait
        if (currentTool !== "paint") {
          selectTool("paint");
        }
        closeSizeModal();
      }

      // Fonction pour définir la taille de la gomme
      function setEraserSize(size) {
        eraserSize = size;
        // Mettre à jour le texte du bouton
        const btn = document.getElementById("eraseToolBtn");
        if (btn) {
          btn.textContent = "🧹 Gomme (" + size + ")";
          btn.title =
            "Gomme (Taille: " + size + ") - Cliquez pour changer la taille";
        }
        // Sélectionner l'outil si ce n'est pas déjà fait
        if (currentTool !== "erase") {
          selectTool("erase");
        }
        closeSizeModal();
      }

      // Fonction pour définir la taille de l'aérographe
      function setSpraySize(size) {
        spraySize = size;
        // Mettre à jour le texte du bouton
        const btn = document.getElementById("sprayToolBtn");
        if (btn) {
          btn.textContent = "🎨 Aérographe (" + size + ")";
          btn.title =
            "Aérographe (Taille: " +
            size +
            ") - Cliquez pour changer la taille";
        }
        // Sélectionner l'outil si ce n'est pas déjà fait
        if (currentTool !== "spray") {
          selectTool("spray");
        }
        closeSizeModal();
      }

      // Fonction pour ouvrir la modale de choix de taille
      function openSizeModal(toolType) {
        const modal = document.getElementById("sizeModal");
        const content = document.getElementById("sizeModalContent");
        const title = document.getElementById("sizeModalTitle");

        if (!modal || !content || !title) return;

        let currentSize = 1;
        let toolName = "";
        if (toolType === "brush") {
          currentSize = brushSize;
          toolName = "Pinceau";
        } else if (toolType === "spray") {
          currentSize = spraySize;
          toolName = "Aérographe";
        } else if (toolType === "eraser") {
          currentSize = eraserSize;
          toolName = "Gomme";
        }

        title.textContent = "Choisir la taille - " + toolName;
        content.innerHTML = "";

        for (let i = 1; i <= 10; i++) {
          const btn = document.createElement("button");
          btn.textContent = i;
          btn.style.padding = "15px";
          btn.style.border = "2px solid #ccc";
          btn.style.borderRadius = "8px";
          btn.style.cursor = "pointer";
          btn.style.fontSize = "1.2rem";
          btn.style.fontWeight = "bold";
          if (i === currentSize) {
            btn.style.background = "#667eea";
            btn.style.color = "white";
            btn.style.borderColor = "#667eea";
          } else {
            btn.style.background = "white";
            btn.style.color = "#333";
            btn.style.borderColor = "#ccc";
          }
          btn.onclick = function () {
            if (toolType === "brush") {
              setBrushSize(i);
            } else if (toolType === "spray") {
              setSpraySize(i);
            } else if (toolType === "eraser") {
              setEraserSize(i);
            }
          };
          content.appendChild(btn);
        }

        modal.style.display = "block";
      }

      // Fonction pour fermer la modale de taille
      function closeSizeModal() {
        const modal = document.getElementById("sizeModal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Fonction pour dessiner un cercle
      function drawCircle(
        centerRow,
        centerCol,
        radius,
        colorIndex = null,
        preview = false
      ) {
        if (colorIndex === null) {
          colorIndex =
            currentTool === "erase"
              ? 0
              : window.selectedColorIndex !== undefined
              ? window.selectedColorIndex
              : 0;
        }
        for (let i = 0; i < 70; i++) {
          for (let j = 0; j < 70; j++) {
            const dx = j - centerCol;
            const dy = i - centerRow;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance <= radius) {
              pixelArtGrid[i][j] = colorIndex;
            }
          }
        }
        refreshPixelGrid();
        updateDNASequence();
        if (!preview) {
          saveToHistory();
        }
      }

      // Fonction pour dessiner un carré
      function drawSquare(
        startRow,
        startCol,
        endRow,
        endCol,
        colorIndex = null,
        preview = false
      ) {
        if (colorIndex === null) {
          colorIndex =
            currentTool === "erase"
              ? 0
              : window.selectedColorIndex !== undefined
              ? window.selectedColorIndex
              : 0;
        }
        const minRow = Math.min(startRow, endRow);
        const maxRow = Math.max(startRow, endRow);
        const minCol = Math.min(startCol, endCol);
        const maxCol = Math.max(startCol, endCol);

        for (let i = minRow; i <= maxRow && i < 70; i++) {
          for (let j = minCol; j <= maxCol && j < 70; j++) {
            pixelArtGrid[i][j] = colorIndex;
          }
        }
        refreshPixelGrid();
        updateDNASequence();
        if (!preview) {
          saveToHistory();
        }
      }

      // Fonction pour dessiner un triangle
      function drawTriangle(
        row1,
        col1,
        row2,
        col2,
        row3,
        col3,
        colorIndex = null,
        preview = false
      ) {
        if (colorIndex === null) {
          colorIndex =
            currentTool === "erase"
              ? 0
              : window.selectedColorIndex !== undefined
              ? window.selectedColorIndex
              : 0;
        }

        // Calculer les limites
        const minRow = Math.min(row1, row2, row3);
        const maxRow = Math.max(row1, row2, row3);
        const minCol = Math.min(col1, col2, col3);
        const maxCol = Math.max(col1, col2, col3);

        // Fonction pour vérifier si un point est dans le triangle
        function pointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {
          const d1 = sign(px, py, x1, y1, x2, y2);
          const d2 = sign(px, py, x2, y2, x3, y3);
          const d3 = sign(px, py, x3, y3, x1, y1);
          const hasNeg = d1 < 0 || d2 < 0 || d3 < 0;
          const hasPos = d1 > 0 || d2 > 0 || d3 > 0;
          return !(hasNeg && hasPos);
        }

        function sign(x1, y1, x2, y2, x3, y3) {
          return (x1 - x3) * (y2 - y3) - (x2 - x3) * (y1 - y3);
        }

        for (let i = minRow; i <= maxRow && i < 70; i++) {
          for (let j = minCol; j <= maxCol && j < 70; j++) {
            if (pointInTriangle(j, i, col1, row1, col2, row2, col3, row3)) {
              pixelArtGrid[i][j] = colorIndex;
            }
          }
        }
        refreshPixelGrid();
        updateDNASequence();
        if (!preview) {
          saveToHistory();
        }
      }

      // Fonction pour dessiner une étoile
      function drawStar(
        centerRow,
        centerCol,
        outerRadius,
        innerRadius,
        colorIndex = null,
        preview = false
      ) {
        if (colorIndex === null) {
          colorIndex =
            currentTool === "erase"
              ? 0
              : window.selectedColorIndex !== undefined
              ? window.selectedColorIndex
              : 0;
        }
        const points = 5; // Étoile à 5 branches

        // Calculer les points de l'étoile
        const starPoints = [];
        for (let i = 0; i < points * 2; i++) {
          const angle = (i * Math.PI) / points;
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const x = centerCol + radius * Math.cos(angle - Math.PI / 2);
          const y = centerRow + radius * Math.sin(angle - Math.PI / 2);
          starPoints.push({ x: Math.round(x), y: Math.round(y) });
        }

        // Remplir l'étoile en utilisant un polygone
        const minRow = Math.max(0, Math.min(...starPoints.map((p) => p.y)) - 2);
        const maxRow = Math.min(
          69,
          Math.max(...starPoints.map((p) => p.y)) + 2
        );
        const minCol = Math.max(0, Math.min(...starPoints.map((p) => p.x)) - 2);
        const maxCol = Math.min(
          69,
          Math.max(...starPoints.map((p) => p.x)) + 2
        );

        for (let i = minRow; i <= maxRow; i++) {
          for (let j = minCol; j <= maxCol; j++) {
            if (pointInPolygon(j, i, starPoints)) {
              pixelArtGrid[i][j] = colorIndex;
            }
          }
        }
        refreshPixelGrid();
        updateDNASequence();
        if (!preview) {
          saveToHistory();
        }
      }

      // Fonction pour vérifier si un point est dans un polygone
      function pointInPolygon(x, y, points) {
        let inside = false;
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
          const xi = points[i].x,
            yi = points[i].y;
          const xj = points[j].x,
            yj = points[j].y;
          const intersect =
            yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
          if (intersect) inside = !inside;
        }
        return inside;
      }

      // Fonction pour prévisualiser une forme (sans sauvegarder dans l'historique)
      function previewShape(startRow, startCol, endRow, endCol) {
        // Restaurer la grille sauvegardée avant de dessiner
        if (shapePreviewGrid) {
          pixelArtGrid = JSON.parse(JSON.stringify(shapePreviewGrid));
        }

        const colorIndex =
          currentTool === "erase"
            ? 0
            : window.selectedColorIndex !== undefined
            ? window.selectedColorIndex
            : 0;

        if (currentTool === "circle") {
          const radius = Math.max(
            Math.abs(startRow - endRow),
            Math.abs(startCol - endCol)
          );
          drawCircle(startRow, startCol, radius, colorIndex, true);
        } else if (currentTool === "square") {
          drawSquare(startRow, startCol, endRow, endCol, colorIndex, true);
        } else if (currentTool === "triangle") {
          const centerRow = startRow;
          const centerCol = startCol;
          const point2Row = endRow;
          const point2Col = endCol;
          const dx = point2Col - centerCol;
          const dy = point2Row - centerRow;
          const point3Row = centerRow - dy;
          const point3Col = centerCol + dx;
          drawTriangle(
            centerRow,
            centerCol,
            point2Row,
            point2Col,
            point3Row,
            point3Col,
            colorIndex,
            true
          );
        } else if (currentTool === "star") {
          const outerRadius = Math.max(
            Math.abs(startRow - endRow),
            Math.abs(startCol - endCol)
          );
          const innerRadius = Math.floor(outerRadius * 0.4);
          drawStar(
            startRow,
            startCol,
            outerRadius,
            innerRadius,
            colorIndex,
            true
          );
        }
      }

      // Fonction pour finaliser une forme (sauvegarder dans l'historique)
      function finalizeShape(startRow, startCol, endRow, endCol) {
        const colorIndex =
          currentTool === "erase"
            ? 0
            : window.selectedColorIndex !== undefined
            ? window.selectedColorIndex
            : 0;

        if (currentTool === "circle") {
          const radius = Math.max(
            Math.abs(startRow - endRow),
            Math.abs(startCol - endCol)
          );
          drawCircle(startRow, startCol, radius, colorIndex, false);
        } else if (currentTool === "square") {
          drawSquare(startRow, startCol, endRow, endCol, colorIndex, false);
        } else if (currentTool === "triangle") {
          const centerRow = startRow;
          const centerCol = startCol;
          const point2Row = endRow;
          const point2Col = endCol;
          const dx = point2Col - centerCol;
          const dy = point2Row - centerRow;
          const point3Row = centerRow - dy;
          const point3Col = centerCol + dx;
          drawTriangle(
            centerRow,
            centerCol,
            point2Row,
            point2Col,
            point3Row,
            point3Col,
            colorIndex,
            false
          );
        } else if (currentTool === "star") {
          const outerRadius = Math.max(
            Math.abs(startRow - endRow),
            Math.abs(startCol - endCol)
          );
          const innerRadius = Math.floor(outerRadius * 0.4);
          drawStar(
            startRow,
            startCol,
            outerRadius,
            innerRadius,
            colorIndex,
            false
          );
        }
      }

      // Fonction pour mettre à jour la séquence ADN dans dnaOutput
      function updateDNASequence() {
        const triplets = generateAllTriplets();
        let sequence = "";

        // Déterminer la taille réelle de la grille
        const gridWidth = 70;
        const gridHeight = pixelArtGrid.length || 70;

        // Parcourir la grille ligne par ligne
        for (let i = 0; i < gridHeight; i++) {
          for (let j = 0; j < gridWidth; j++) {
            if (pixelArtGrid[i] && pixelArtGrid[i][j] !== undefined) {
              const colorIndex = pixelArtGrid[i][j];
              const triplet = triplets[colorIndex] || triplets[0];
              sequence += triplet;
            } else {
              // Pixel vide, utiliser AAA (blanc)
              sequence += triplets[0];
            }
          }
        }

        // Ajouter le triplet de palette au début
        const fullSequence = currentPaletteType + sequence;

        // Mettre à jour dnaOutput
        const dnaOutput = document.getElementById("dnaOutput");
        dnaOutput.textContent = fullSequence;
        dnaOutput.setAttribute("data-dna-sequence", fullSequence);

        // Afficher le bouton d'export
        const exportBtn = document.getElementById("exportBtn");
        if (exportBtn) exportBtn.style.display = "inline-block";

        // Afficher le label
        updateDnaOutputLabel();
      }

      // Fonction pour charger une séquence ADN dans l'éditeur pixel art
      function loadPixelArtFromSequence(sequence) {
        const triplets = generateAllTriplets();
        const baseGridSize = 70; // Taille de base 70x70
        const baseSize = baseGridSize * baseGridSize * 3; // 14700 nucléotides
        const maxAdditionalPixels = 70; // Maximum 70 pixels supplémentaires

        // Vérifier que la séquence a la bonne longueur (>= 14700 nucléotides)
        let paletteTriplet = null;
        let imageSequence = sequence;
        let hasPaletteIndicator = false;

        // Vérifier si le premier triplet est un indicateur de palette
        if (sequence.length > 3) {
          const firstTriplet = sequence.substring(0, 3);
          if (
            firstTriplet === "AAA" ||
            firstTriplet === "CCC" ||
            firstTriplet === "GGG" ||
            firstTriplet === "TTT"
          ) {
            // Le premier triplet est un indicateur de palette
            paletteTriplet = firstTriplet;
            imageSequence = sequence.substring(3); // Le reste de la séquence
            hasPaletteIndicator = true;
            currentPaletteType = paletteTriplet;
          } else {
            // Pas d'indicateur de palette, utiliser AAA par défaut
            currentPaletteType = "AAA";
            imageSequence = sequence;
          }
        } else {
          // Séquence trop courte
          alert(
            "La séquence doit contenir au moins 14700 nucléotides pour être une image pixel art."
          );
          return;
        }

        // Calculer le nombre de triplets dans la séquence d'image
        const numberOfTriplets = Math.floor(imageSequence.length / 3);
        const baseTriplets = baseGridSize * baseGridSize; // 4900 triplets pour 70x70

        // Calculer le nombre de pixels supplémentaires (au-delà de 70x70)
        let additionalPixels = 0;
        if (numberOfTriplets > baseTriplets) {
          additionalPixels = numberOfTriplets - baseTriplets;
          // Limiter à 70 pixels supplémentaires max
          if (additionalPixels > maxAdditionalPixels) {
            additionalPixels = maxAdditionalPixels;
          }
        }

        // Calculer la taille de la grille : 70 colonnes, 70+ lignes supplémentaires
        const gridHeight =
          baseGridSize + Math.ceil(additionalPixels / baseGridSize);
        const gridWidth = baseGridSize;

        // Extraire les triplets et trouver leurs indices dans la palette
        pixelArtGrid = [];
        for (let i = 0; i < gridHeight; i++) {
          pixelArtGrid[i] = [];
          for (let j = 0; j < gridWidth; j++) {
            const tripletIndex = i * gridWidth + j;
            if (tripletIndex * 3 + 3 <= imageSequence.length) {
              const triplet = imageSequence.substring(
                tripletIndex * 3,
                tripletIndex * 3 + 3
              );
              const colorIndex = triplets.indexOf(triplet);
              if (colorIndex === -1) {
                // Triplet non trouvé, utiliser l'index 0 par défaut
                pixelArtGrid[i][j] = 0;
              } else {
                pixelArtGrid[i][j] = colorIndex;
              }
            } else {
              // Au-delà de la séquence, pixel vide
              pixelArtGrid[i][j] = 0;
            }
          }
        }

        // Ouvrir l'éditeur avec la grille chargée
        openPixelArtEditor();
        // Mettre à jour l'état du sélecteur de palette après le chargement
        // Ne pas appeler updatePaletteSelectorState() car le message est déjà dans le HTML généré
        // On met juste à jour l'état du sélecteur sans recréer le message
        setTimeout(() => {
          const paletteSelector = document.getElementById("paletteSelector");
          if (paletteSelector) {
            const drawingExists = hasDrawing();
            paletteSelector.disabled = drawingExists;
            if (drawingExists) {
              paletteSelector.style.border = "2px solid #ccc";
              paletteSelector.style.backgroundColor = "#f5f5f5";
              paletteSelector.style.color = "#999";
              paletteSelector.style.cursor = "not-allowed";
            } else {
              paletteSelector.style.border = "2px solid #667eea";
              paletteSelector.style.backgroundColor = "";
              paletteSelector.style.color = "";
              paletteSelector.style.cursor = "";
            }
          }
        }, 100);
      }

      // Fonction pour créer les mosaïques colorées sur le bouton pixel art
      function createPixelArtMosaic() {
        const mosaicContainer = document.getElementById("pixelArtMosaic");
        if (!mosaicContainer) return;

        // Vider le conteneur avant de créer de nouveaux carreaux
        mosaicContainer.innerHTML = "";

        // Couleurs variées pour les mosaïques
        const mosaicColors = [
          "#FF6B6B",
          "#4ECDC4",
          "#45B7D1",
          "#FFA07A",
          "#98D8C8",
          "#F7DC6F",
          "#BB8FCE",
          "#85C1E2",
          "#F8B739",
          "#E74C3C",
          "#3498DB",
          "#2ECC71",
          "#9B59B6",
          "#1ABC9C",
          "#E67E22",
          "#34495E",
          "#FFD700",
          "#FF6347",
          "#00CED1",
          "#9370DB",
          "#FF1493",
          "#00FF7F",
          "#FF4500",
          "#1E90FF",
          "#FF69B4",
          "#32CD32",
          "#FF8C00",
          "#8A2BE2",
          "#DC143C",
          "#00FA9A",
          "#FFD700",
          "#FF1493",
          "#00CED1",
          "#9370DB",
          "#FF6347",
          "#00FF7F",
        ];

        // Créer 32 carreaux (8x4)
        for (let i = 0; i < 32; i++) {
          const tile = document.createElement("div");
          const colorIndex = Math.floor(Math.random() * mosaicColors.length);
          tile.style.backgroundColor = mosaicColors[colorIndex];
          tile.style.border = "none";
          mosaicContainer.appendChild(tile);
        }
      }

      // Fonction pour exporter le code génétique en CSV
      function exportGeneticCode() {
        const entries = Object.entries(geneticCode)
          .filter(([k, v]) => v !== "START")
          .sort(([a], [b]) => a.localeCompare(b));

        // Créer le contenu CSV
        let csvContent = "Codon,Symbole\n";
        entries.forEach(([codon, symbol]) => {
          // Échapper les virgules et guillemets dans les symboles
          const escapedSymbol =
            symbol.includes(",") || symbol.includes('"')
              ? `"${symbol.replace(/"/g, '""')}"`
              : symbol;
          csvContent += `${codon},${escapedSymbol}\n`;
        });

        // Créer un blob et télécharger
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        downloadFile(blob, "code_genetique.csv");
      }

      // Fonction pour importer le code génétique depuis un CSV
      function importGeneticCode(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const text = e.target.result;
            const lines = text.split("\n").filter((line) => line.trim() !== "");

            // Ignorer la première ligne (en-tête)
            const dataLines = lines.slice(1);

            // Créer un nouveau code génétique
            const newGeneticCode = { ATG: "START" };
            let hasError = false;
            let errorMessage = "";

            dataLines.forEach((line, index) => {
              // Parser la ligne CSV (gérer les virgules dans les valeurs)
              const match = line.match(/^([^,]+),(".*"|[^,]*)$/);
              if (match) {
                const codon = match[1].trim();
                let symbol = match[2].trim();

                // Enlever les guillemets si présents
                if (symbol.startsWith('"') && symbol.endsWith('"')) {
                  symbol = symbol.slice(1, -1).replace(/""/g, '"');
                }

                // Valider le codon (3 lettres A, T, C, G)
                if (/^[ATCG]{3}$/.test(codon)) {
                  newGeneticCode[codon] = symbol;
                } else {
                  hasError = true;
                  errorMessage += `Ligne ${
                    index + 2
                  }: Codon invalide "${codon}"\n`;
                }
              } else if (line.trim() !== "") {
                hasError = true;
                errorMessage += `Ligne ${index + 2}: Format invalide\n`;
              }
            });

            if (hasError) {
              alert("Erreurs lors de l'importation :\n" + errorMessage);
              return;
            }

            // Demander confirmation avant de remplacer
            if (
              confirm(
                "Voulez-vous remplacer le code génétique actuel par celui du fichier CSV ?"
              )
            ) {
              // Remplacer le code génétique
              Object.keys(geneticCode).forEach((key) => {
                if (key !== "ATG") delete geneticCode[key];
              });
              Object.assign(geneticCode, newGeneticCode);

              // Reconstruire le reverseCode global
              Object.keys(reverseCode).forEach(
                (key) => delete reverseCode[key]
              );
              for (let [codon, char] of Object.entries(geneticCode)) {
                if (char !== "START" && char !== "Majuscule") {
                  if (!reverseCode[char]) reverseCode[char] = [];
                  reverseCode[char].push(codon);
                }
              }

              // Recharger le tableau
              const tbody = document.getElementById("codeTable");
              tbody.innerHTML = "";
              const entries = Object.entries(geneticCode)
                .filter(([k, v]) => v !== "START")
                .sort(([a], [b]) => a.localeCompare(b));

              const numColumns = 4;
              const entriesPerColumn = Math.ceil(entries.length / numColumns);

              const rows = [];
              for (let i = 0; i < entriesPerColumn; i++) {
                const row = document.createElement("tr");
                for (let j = 0; j < numColumns * 2; j++) {
                  const cell = document.createElement("td");
                  row.appendChild(cell);
                }
                rows.push(row);
                tbody.appendChild(row);
              }

              entries.forEach(([codon, symbol], index) => {
                const columnIndex = Math.floor(index / entriesPerColumn);
                const rowIndex = index % entriesPerColumn;
                if (columnIndex >= numColumns) return;
                const row = rows[rowIndex];
                const codonCellIndex = columnIndex * 2;
                const symbolCellIndex = codonCellIndex + 1;
                row.cells[codonCellIndex].textContent = codon;
                row.cells[symbolCellIndex].textContent = symbol;

                // Colorer les codons stop en rose pastel
                if (["TAA", "TAG", "TGA"].includes(codon)) {
                  row.cells[codonCellIndex].style.backgroundColor = "#ffb3d9";
                  row.cells[symbolCellIndex].style.backgroundColor = "#ffb3d9";
                }
              });

              alert("Code génétique importé avec succès !");
            }

            // Réinitialiser l'input file
            event.target.value = "";
          } catch (error) {
            alert("Erreur lors de la lecture du fichier : " + error.message);
            event.target.value = "";
          }
        };
        reader.readAsText(file);
      }

      // Initialiser les mosaïques du bouton pixel art au chargement
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", function () {
          createPixelArtMosaic();
          setupAllButtonsForMobile();
          loadVideoExplicativeImage();
          populateCodeTable();
        });
      } else {
        // Le DOM est déjà chargé
        createPixelArtMosaic();
        setupAllButtonsForMobile();
        populateCodeTable();
      }

      // Réappliquer la configuration des boutons après un court délai pour les boutons créés dynamiquement
      setTimeout(setupAllButtonsForMobile, 1000);

      // Fonction pour scroller vers un bouton et le highlight
      function highlightButton(buttonId, duration) {
        const button = document.getElementById(buttonId);
        if (!button) {
          console.warn("Bouton non trouvé :", buttonId);
          return;
        }

        // Scroller vers le bouton
        button.scrollIntoView({ behavior: "smooth", block: "center" });

        // Sauvegarder le style original
        const originalStyle = button.style.cssText;
        const originalBoxShadow = button.style.boxShadow;

        // Appliquer le highlight
        button.style.transition = "all 0.3s ease";
        button.style.boxShadow = "0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6)";
        button.style.transform = "scale(1.1)";
        button.style.zIndex = "1000";

        // Retirer le highlight après la durée spécifiée
        setTimeout(() => {
          button.style.boxShadow = originalBoxShadow;
          button.style.transform = "";
          button.style.zIndex = "";
          setTimeout(() => {
            button.style.transition = "";
          }, 300);
        }, duration);
      }

      // Système de navigation pour les highlights
      let currentHighlightSequence = null;
      let currentHighlightStep = 0;
      let highlightSteps = [];
      let highlightTimeouts = [];
      let highlightKeyboardListener = null;
      let currentTooltip = null;
      let previousHighlightedElement = null;
      let previousElementStyles = null;

      // Fonction helper pour créer un tooltip avec navigation
      function createTooltipWithNavigation(message, stepIndex, totalSteps, onNext, onPrevious, onClose) {
        const tooltip = document.createElement("div");
        tooltip.className = "highlight-tooltip";
        
        // Conteneur pour le texte principal
        const tooltipContent = document.createElement("div");
        tooltipContent.style.cssText = `
          padding: 15px 15px 10px 15px;
          text-align: center;
        `;
        tooltipContent.innerHTML = message;
        
        // Conteneur pour les boutons de navigation (centré)
        const buttonsContainer = document.createElement("div");
        buttonsContainer.style.cssText = `
          display: flex;
          justify-content: center;
          align-items: center;
          gap: 15px;
          padding: 10px 15px 15px 15px;
          border-top: 1px solid rgba(102, 126, 234, 0.2);
        `;
        
        // Ajouter bouton "Précédent" si nécessaire
        if (stepIndex > 0 && onPrevious) {
          const prevBtn = document.createElement("div");
          prevBtn.innerHTML = "← Précédent";
          prevBtn.style.cssText = `
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            font-size: 0.9rem;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s ease;
          `;
          prevBtn.onmouseover = () => prevBtn.style.background = "rgba(102, 126, 234, 0.1)";
          prevBtn.onmouseout = () => prevBtn.style.background = "transparent";
          prevBtn.onclick = (e) => {
            e.stopPropagation();
            if (onPrevious) onPrevious();
          };
          buttonsContainer.appendChild(prevBtn);
        }
        
        // Ajouter bouton "Suivant" ou "Terminer" selon l'étape
        if (stepIndex < totalSteps - 1) {
          const nextBtn = document.createElement("div");
          nextBtn.innerHTML = "→ Suivant";
          nextBtn.style.cssText = `
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            font-size: 0.9rem;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s ease;
          `;
          nextBtn.onmouseover = () => nextBtn.style.background = "rgba(102, 126, 234, 0.1)";
          nextBtn.onmouseout = () => nextBtn.style.background = "transparent";
          nextBtn.onclick = (e) => {
            e.stopPropagation();
            if (onNext) onNext();
          };
          buttonsContainer.appendChild(nextBtn);
        } else {
          // Dernière étape : afficher "Terminer" qui revient à la première étape
          const finishBtn = document.createElement("div");
          finishBtn.innerHTML = "Terminer";
          finishBtn.style.cssText = `
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            font-size: 0.9rem;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s ease;
          `;
          finishBtn.onmouseover = () => finishBtn.style.background = "rgba(102, 126, 234, 0.1)";
          finishBtn.onmouseout = () => finishBtn.style.background = "transparent";
          finishBtn.onclick = (e) => {
            e.stopPropagation();
            // Revenir à la première étape (comme si on appuyait sur flèche droite)
            if (onNext) onNext(); // onNext sera showStep(0) pour la dernière étape
          };
          buttonsContainer.appendChild(finishBtn);
        }
        
        // Taille adaptée selon mobile/PC
        const isMobile = window.innerWidth <= 768;
        const tooltipMaxWidth = isMobile ? 500 : 460; // +25% mobile, +15% PC
        const tooltipFontSize = isMobile ? '1.1875rem' : '1.0925rem'; // +25% mobile, +15% PC
        
        tooltip.style.cssText = `
          position: fixed;
          background: rgba(255, 255, 255, 0.98);
          border: 2px solid #667eea;
          border-radius: 8px;
          padding: 0;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
          z-index: 10000;
          max-width: ${tooltipMaxWidth}px;
          font-size: ${tooltipFontSize};
          line-height: 1.6;
          color: #333;
          cursor: pointer;
        `;
        
        tooltip.appendChild(tooltipContent);
        if (buttonsContainer.children.length > 0) {
          tooltip.appendChild(buttonsContainer);
        }
        
        // Gestion du clic sur la fenêtre pour passer au suivant (si ce n'est pas le dernier)
        if (stepIndex < totalSteps - 1) {
          tooltip.onclick = (e) => {
            // Ne pas déclencher si on clique sur les boutons de navigation
            if (!e.target.closest('div[style*="cursor: pointer"]') || e.target === tooltipContent) {
              if (onNext) onNext();
            }
          };
        } else {
          // Dernière étape : clic sur la fenêtre = terminer (arrêter et remonter à la première fenêtre)
          tooltip.onclick = (e) => {
            // Ne pas déclencher si on clique sur les boutons de navigation
            if (!e.target.closest('div[style*="cursor: pointer"]') || e.target === tooltipContent) {
              if (onNext) onNext(); // onNext arrêtera les highlights et remontera à la première fenêtre
            }
          };
        }
        
        return tooltip;
      }

      // Fonction pour positionner un tooltip
      function positionTooltip(tooltip, targetElement) {
        document.body.appendChild(tooltip);
        
        // Fonction pour calculer et appliquer la position
        const calculatePosition = () => {
          const rect = targetElement.getBoundingClientRect();
          const isMobile = window.innerWidth <= 768;
          const tooltipWidth = isMobile ? 500 : 460; // +25% mobile, +15% PC
          const tooltipHeight = tooltip.offsetHeight;
          const leftPosition = rect.left + (rect.width / 2) - (tooltipWidth / 2);
          const spacing = isMobile ? 5 : 10;
          
          // Utiliser window.innerWidth et window.innerHeight pour une meilleure compatibilité Android
          const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
          const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
          
          // Calculer la position horizontale
          let left = Math.max(10, Math.min(leftPosition, viewportWidth - tooltipWidth - 10));
          
          // Calculer la position verticale
          let top = rect.top - spacing - tooltipHeight;
          
          // Vérifier si le tooltip dépasse en haut de l'écran (problème fréquent sur Android)
          if (top < 10) {
            // Si oui, le positionner en dessous de l'élément
            top = rect.bottom + spacing;
            // Si ça dépasse toujours, le centrer verticalement par rapport à l'élément
            if (top + tooltipHeight > viewportHeight - 10) {
              top = rect.top + (rect.height / 2) - (tooltipHeight / 2);
            }
          }
          
          // S'assurer que le tooltip reste dans les limites de la fenêtre
          top = Math.max(10, Math.min(top, viewportHeight - tooltipHeight - 10));
          
          return { left, top };
        };
        
        // Calculer et appliquer la position
        const position = calculatePosition();
        tooltip.style.left = position.left + "px";
        tooltip.style.top = position.top + "px";
        tooltip.style.transform = "none";
        tooltip.style.position = "fixed";
        
        // Recalculer après un court délai pour corriger les problèmes de rendu Android
        setTimeout(() => {
          if (tooltip.parentNode) {
            const newPosition = calculatePosition();
            tooltip.style.left = newPosition.left + "px";
            tooltip.style.top = newPosition.top + "px";
          }
        }, 50);
      }

      // Fonction pour nettoyer les highlights
      function cleanupHighlights() {
        highlightTimeouts.forEach(timeout => clearTimeout(timeout));
        highlightTimeouts = [];
        if (currentTooltip && currentTooltip.parentNode) {
          currentTooltip.remove();
        }
        // Restaurer les styles de l'élément précédemment highlighté
        if (previousHighlightedElement && previousElementStyles && previousHighlightedElement.parentNode) {
          previousHighlightedElement.style.transition = "all 0.3s ease";
          Object.keys(previousElementStyles).forEach(key => {
            if (previousElementStyles[key] === '' || previousElementStyles[key] === 'none' || previousElementStyles[key] === 'auto') {
              previousHighlightedElement.style[key] = '';
            } else {
              previousHighlightedElement.style[key] = previousElementStyles[key];
            }
          });
          setTimeout(() => {
            if (previousHighlightedElement && previousHighlightedElement.parentNode) {
              previousHighlightedElement.style.transition = "";
            }
          }, 300);
        }
        if (highlightKeyboardListener) {
          document.removeEventListener('keydown', highlightKeyboardListener);
          highlightKeyboardListener = null;
        }
        currentHighlightSequence = null;
        currentHighlightStep = 0;
        highlightSteps = [];
        previousHighlightedElement = null;
        previousElementStyles = null;
      }

      // Fonction pour highlight la séquence d'encodage de texte
      function highlightEncodeTextSequence() {
        const textInput = document.getElementById("textInput");
        const encodeTextBtn = document.getElementById("encodeTextBtn");
        const trouModeBtn = document.getElementById("trouModeBtn");
        const dnaOutput = document.getElementById("dnaOutput");
        const codeTable = document.getElementById("codeTable");

        if (!textInput || !encodeTextBtn || !trouModeBtn) {
          console.warn("Éléments d'encodage texte non trouvés");
          return;
        }

        // Nettoyer les highlights précédents
        cleanupHighlights();
        currentHighlightSequence = 'encodeText';

        // Définir les steps
        const steps = [
          {
            element: textInput,
            message: "C'est ici que tu peux écrire ou coller un texte que tu aimerais transformer en ADN",
            highlightStyle: { boxShadow: "0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6)", border: "3px solid rgba(255, 215, 0, 0.8)", zIndex: "1000", position: "relative" }
          },
          {
            element: encodeTextBtn,
            message: "Clique sur le bouton Texte ou Texte à trous selon le résultat souhaité",
            highlightStyle: { boxShadow: "0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6)", transform: "scale(1.1)", zIndex: "1000" }
          },
          {
            element: trouModeBtn,
            message: "Clique sur le bouton Texte ou Texte à trous selon le résultat souhaité",
            highlightStyle: { boxShadow: "0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6)", transform: "scale(1.1)", zIndex: "1000" }
          }
        ];

        // Ajouter le tableau du code génétique si disponible
        if (codeTable) {
          const codeTableElement = codeTable.closest('table') || codeTable.closest('.section');
          if (codeTableElement) {
            steps.push({
              element: codeTableElement,
              message: "Le logiciel va ensuite utiliser ce code génétique fictif pour encoder ton message en une séquence ADN",
              highlightStyle: { boxShadow: "0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6)", border: "3px solid rgba(255, 215, 0, 0.8)", zIndex: "1000", position: "relative" }
            });
          }
        }

        // Ajouter la zone de résultat si disponible
        if (dnaOutput) {
          steps.push({
            element: dnaOutput,
            message: "La séquence ADN correspondante s'affichera alors ici. Tu peux la copier, l'enregistrer et l'envoyer à quelqu'un. Décode là avant, pour tester qu'il n'y a pas eu de problème",
            highlightStyle: { boxShadow: "0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6)", border: "3px solid rgba(255, 215, 0, 0.8)", zIndex: "1000", position: "relative" }
          });
        }

        highlightSteps = steps;
        currentHighlightStep = 0;

        // Fonction pour afficher un step
        function showStep(stepIndex) {
          // Si on dépasse la dernière étape, revenir à la première
          if (stepIndex >= highlightSteps.length) {
            stepIndex = 0;
          }
          
          if (stepIndex < 0) {
            cleanupHighlights();
            // Recentrer vers la première fenêtre
            setTimeout(() => {
              const fenetre1 = document.getElementById("demarrageFenetre1");
              if (fenetre1) {
                fenetre1.scrollIntoView({ behavior: "smooth", block: "center" });
              }
            }, 500);
            return;
          }

          // Restaurer les styles de l'élément précédent
          if (previousHighlightedElement && previousElementStyles && previousHighlightedElement.parentNode) {
            previousHighlightedElement.style.transition = "all 0.3s ease";
            Object.keys(previousElementStyles).forEach(key => {
              if (previousElementStyles[key] === '' || previousElementStyles[key] === 'none' || previousElementStyles[key] === 'auto') {
                previousHighlightedElement.style[key] = '';
              } else {
                previousHighlightedElement.style[key] = previousElementStyles[key];
              }
            });
            setTimeout(() => {
              if (previousHighlightedElement && previousHighlightedElement.parentNode) {
                previousHighlightedElement.style.transition = "";
              }
            }, 300);
          }

          currentHighlightStep = stepIndex;
          const step = highlightSteps[stepIndex];
          const element = step.element;

          // Nettoyer le step précédent
          if (currentTooltip && currentTooltip.parentNode) {
            currentTooltip.remove();
          }

          // Scroller vers l'élément
          element.scrollIntoView({ behavior: "smooth", block: "center" });

          setTimeout(() => {
            // Sauvegarder les styles originaux avant d'appliquer le highlight
            const originalStyles = {};
            Object.keys(step.highlightStyle).forEach(key => {
              originalStyles[key] = element.style[key] || window.getComputedStyle(element)[key];
            });

            // Stocker l'élément et ses styles pour la restauration suivante
            previousHighlightedElement = element;
            previousElementStyles = originalStyles;

            // Appliquer le highlight
            element.style.transition = "all 0.3s ease";
            Object.assign(element.style, step.highlightStyle);

            // Déterminer la fonction onNext : si dernière étape, arrêter et remonter à la première fenêtre, sinon étape suivante
            const isLastStep = stepIndex === highlightSteps.length - 1;
            const onNextFunction = isLastStep ? () => {
              cleanupHighlights();
              setTimeout(() => {
                const fenetre1 = document.getElementById("demarrageFenetre1");
                if (fenetre1) {
                  fenetre1.scrollIntoView({ behavior: "smooth", block: "center" });
                }
              }, 500);
            } : () => showStep(stepIndex + 1);

            // Créer le tooltip avec navigation
            currentTooltip = createTooltipWithNavigation(
              step.message,
              stepIndex,
              highlightSteps.length,
              onNextFunction, // onNext
              () => showStep(stepIndex - 1), // onPrevious
              () => cleanupHighlights() // onClose
            );

            positionTooltip(currentTooltip, element);

            // Gérer les événements clavier
            if (!highlightKeyboardListener) {
              highlightKeyboardListener = (e) => {
                if (currentHighlightSequence === 'encodeText') {
                  if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    // Si on est à la dernière étape, déclencher la même action que le bouton "Terminer"
                    if (currentHighlightStep === highlightSteps.length - 1) {
                      cleanupHighlights();
                      setTimeout(() => {
                        const fenetre1 = document.getElementById("demarrageFenetre1");
                        if (fenetre1) {
                          fenetre1.scrollIntoView({ behavior: "smooth", block: "center" });
                        }
                      }, 500);
                    } else {
                      showStep(currentHighlightStep + 1);
                    }
                  } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    showStep(currentHighlightStep - 1);
                  }
                }
              };
              document.addEventListener('keydown', highlightKeyboardListener);
            }

            // Pas de timeout automatique - navigation uniquement manuelle
          }, 500);
        }

        // Démarrer avec le premier step
        showStep(0);
      }

      // Fonction pour highlight Pixel Art avec tooltip
      function highlightPixelArtWithTooltip() {
        const pixelArtBtn = document.getElementById("pixelArtBtn");
        const importBtn = document.getElementById("importDnaBtn");
        const decodeBtn = document.getElementById("decodeBtn");
        
        if (!pixelArtBtn) {
          console.warn("Bouton Pixel Art non trouvé");
          return;
        }

        // Nettoyer les highlights précédents
        cleanupHighlights();
        currentHighlightSequence = 'pixelArt';

        // Définir les steps
        const steps = [
          {
            element: pixelArtBtn,
            message: "Une fois cliqué il te suffit de sélectionner une palette (= un code génétique) et de dessiner. Chaque pixel coloré correspond à un triplet de nucléotide (par exemple AAA = pixel blanc), Enregistre alors ton dessin en ADN. Quand tu souhaites revoir ton dessin il te suffira de l'importer dans la fenêtre de décodage",
            highlightStyle: { boxShadow: "0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6)", transform: "scale(1.1)", zIndex: "1000" }
          }
        ];

        // Ajouter le bouton "Importer de l'ADN" si disponible
        if (importBtn) {
          steps.push({
            element: importBtn,
            message: "Pour récupérer ton dessin si tu l'as enregistré",
            highlightStyle: { boxShadow: "0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6)", transform: "scale(1.1)", zIndex: "1000" }
          });
        }

        // Ajouter le bouton "Décoder" si disponible
        if (decodeBtn) {
          steps.push({
            element: decodeBtn,
            message: "Ce bouton va alors reconstituer ton image en lisant la séquence ADN que tu as chargé. Tu peux aussi découvrir l'image surprise que quelqu'un t'a envoyée !",
            highlightStyle: { boxShadow: "0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6)", transform: "scale(1.1)", zIndex: "1000" }
          });
        }

        highlightSteps = steps;
        currentHighlightStep = 0;

        // Fonction pour afficher un step
        function showStep(stepIndex) {
          // Si on dépasse la dernière étape, revenir à la première
          if (stepIndex >= highlightSteps.length) {
            stepIndex = 0;
          }
          
          if (stepIndex < 0) {
            cleanupHighlights();
            // Recentrer vers la première fenêtre
            setTimeout(() => {
              const fenetre1 = document.getElementById("demarrageFenetre1");
              if (fenetre1) {
                fenetre1.scrollIntoView({ behavior: "smooth", block: "center" });
              }
            }, 500);
            return;
          }

          // Restaurer les styles de l'élément précédent
          if (previousHighlightedElement && previousElementStyles && previousHighlightedElement.parentNode) {
            previousHighlightedElement.style.transition = "all 0.3s ease";
            Object.keys(previousElementStyles).forEach(key => {
              if (previousElementStyles[key] === '' || previousElementStyles[key] === 'none' || previousElementStyles[key] === 'auto') {
                previousHighlightedElement.style[key] = '';
              } else {
                previousHighlightedElement.style[key] = previousElementStyles[key];
              }
            });
            setTimeout(() => {
              if (previousHighlightedElement && previousHighlightedElement.parentNode) {
                previousHighlightedElement.style.transition = "";
              }
            }, 300);
          }

          currentHighlightStep = stepIndex;
          const step = highlightSteps[stepIndex];
          const element = step.element;

          // Nettoyer le step précédent
          if (currentTooltip && currentTooltip.parentNode) {
            currentTooltip.remove();
          }

          // Scroller vers l'élément
          element.scrollIntoView({ behavior: "smooth", block: "center" });

          setTimeout(() => {
            // Sauvegarder les styles originaux avant d'appliquer le highlight
            const originalStyles = {};
            Object.keys(step.highlightStyle).forEach(key => {
              originalStyles[key] = element.style[key] || window.getComputedStyle(element)[key];
            });

            // Stocker l'élément et ses styles pour la restauration suivante
            previousHighlightedElement = element;
            previousElementStyles = originalStyles;

            // Appliquer le highlight
            element.style.transition = "all 0.3s ease";
            Object.assign(element.style, step.highlightStyle);

            // Déterminer la fonction onNext : si dernière étape, arrêter et remonter à la première fenêtre, sinon étape suivante
            const isLastStep = stepIndex === highlightSteps.length - 1;
            const onNextFunction = isLastStep ? () => {
              cleanupHighlights();
              setTimeout(() => {
                const fenetre1 = document.getElementById("demarrageFenetre1");
                if (fenetre1) {
                  fenetre1.scrollIntoView({ behavior: "smooth", block: "center" });
                }
              }, 500);
            } : () => showStep(stepIndex + 1);

            // Créer le tooltip avec navigation
            currentTooltip = createTooltipWithNavigation(
              step.message,
              stepIndex,
              highlightSteps.length,
              onNextFunction, // onNext
              () => showStep(stepIndex - 1), // onPrevious
              () => cleanupHighlights() // onClose
            );

            positionTooltip(currentTooltip, element);

            // Gérer les événements clavier
            if (!highlightKeyboardListener) {
              highlightKeyboardListener = (e) => {
                if (currentHighlightSequence === 'pixelArt') {
                  if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    // Si on est à la dernière étape, déclencher la même action que le bouton "Terminer"
                    if (currentHighlightStep === highlightSteps.length - 1) {
                      cleanupHighlights();
                      setTimeout(() => {
                        const fenetre1 = document.getElementById("demarrageFenetre1");
                        if (fenetre1) {
                          fenetre1.scrollIntoView({ behavior: "smooth", block: "center" });
                        }
                      }, 500);
                    } else {
                      showStep(currentHighlightStep + 1);
                    }
                  } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    showStep(currentHighlightStep - 1);
                  }
                }
              };
              document.addEventListener('keydown', highlightKeyboardListener);
            }

            // Pas de timeout automatique - navigation uniquement manuelle
          }, 500);
        }

        // Démarrer avec le premier step
        showStep(0);
      }

      // Script pour améliorer les animations de la première fenêtre
      document.addEventListener('DOMContentLoaded', function() {
        const fenetre1 = document.getElementById('demarrageFenetre1');
        if (fenetre1) {
          const links = fenetre1.querySelectorAll('a');
          
          // Ajouter un effet de brillance au survol
          links.forEach((link, index) => {
            link.addEventListener('mouseenter', function() {
              this.style.background = 'linear-gradient(90deg, transparent, rgba(76, 175, 80, 0.3), transparent)';
              this.style.backgroundSize = '200% 100%';
              this.style.animation = 'shineLink 1.5s ease-in-out';
            });
            
            link.addEventListener('mouseleave', function() {
              this.style.background = '';
              this.style.backgroundSize = '';
              this.style.animation = '';
            });
            
            // Ajouter un effet de pulse au clic
            link.addEventListener('click', function() {
              this.style.transform = 'scale(0.95)';
              setTimeout(() => {
                this.style.transform = '';
              }, 150);
            });
          });
          
          // Animation de la fenêtre au chargement
          fenetre1.style.opacity = '0';
          fenetre1.style.transform = 'translateY(-20px)';
          setTimeout(() => {
            fenetre1.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
            fenetre1.style.opacity = '1';
            fenetre1.style.transform = 'translateY(0)';
          }, 100);
        }
      });

      // Fonction pour highlight la séquence de décodage (Importer puis Décoder)
      function highlightDecodeSequence() {
        const importBtn = document.getElementById("importDnaBtn");
        const decodeBtn = document.getElementById("decodeBtn");
        const codeTable = document.getElementById("codeTable");

        if (!importBtn || !decodeBtn) {
          console.warn("Boutons de décodage non trouvés");
          return;
        }

        // Nettoyer les highlights précédents
        cleanupHighlights();
        currentHighlightSequence = 'decodeSequence';

        // Définir les steps
        const steps = [
          {
            element: importBtn,
            message: "Tu peux charger une séquence ADN enregistrée avec ce bouton ou coller directement ci-dessous une séquence",
            highlightStyle: { boxShadow: "0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6)", transform: "scale(1.1)", zIndex: "1000" }
          },
          {
            element: decodeBtn,
            message: "Ce bouton va te permettre de déchiffrer le message qui se cache dans l'ADN que tu as chargé",
            highlightStyle: { boxShadow: "0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6)", transform: "scale(1.1)", zIndex: "1000" }
          }
        ];

        // Ajouter le tableau du code génétique si disponible
        if (codeTable) {
          const codeTableElement = codeTable.closest('table') || codeTable.closest('.section');
          if (codeTableElement) {
            steps.push({
              element: codeTableElement,
              message: "Le logiciel va ensuite utiliser ce code génétique fictif pour encoder ton message en une séquence ADN",
              highlightStyle: { boxShadow: "0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.6)", border: "3px solid rgba(255, 215, 0, 0.8)", zIndex: "1000", position: "relative" }
            });
          }
        }

        highlightSteps = steps;
        currentHighlightStep = 0;

        // Fonction pour afficher un step
        function showStep(stepIndex) {
          // Si on dépasse la dernière étape, revenir à la première
          if (stepIndex >= highlightSteps.length) {
            stepIndex = 0;
          }
          
          if (stepIndex < 0) {
            cleanupHighlights();
            // Recentrer vers la première fenêtre
            setTimeout(() => {
              const fenetre1 = document.getElementById("demarrageFenetre1");
              if (fenetre1) {
                fenetre1.scrollIntoView({ behavior: "smooth", block: "center" });
              }
            }, 500);
            return;
          }

          // Restaurer les styles de l'élément précédent
          if (previousHighlightedElement && previousElementStyles && previousHighlightedElement.parentNode) {
            previousHighlightedElement.style.transition = "all 0.3s ease";
            Object.keys(previousElementStyles).forEach(key => {
              if (previousElementStyles[key] === '' || previousElementStyles[key] === 'none' || previousElementStyles[key] === 'auto') {
                previousHighlightedElement.style[key] = '';
              } else {
                previousHighlightedElement.style[key] = previousElementStyles[key];
              }
            });
            setTimeout(() => {
              if (previousHighlightedElement && previousHighlightedElement.parentNode) {
                previousHighlightedElement.style.transition = "";
              }
            }, 300);
          }

          currentHighlightStep = stepIndex;
          const step = highlightSteps[stepIndex];
          const element = step.element;

          // Nettoyer le step précédent
          if (currentTooltip && currentTooltip.parentNode) {
            currentTooltip.remove();
          }

          // Scroller vers l'élément
          element.scrollIntoView({ behavior: "smooth", block: "center" });

          setTimeout(() => {
            // Sauvegarder les styles originaux avant d'appliquer le highlight
            const originalStyles = {};
            Object.keys(step.highlightStyle).forEach(key => {
              originalStyles[key] = element.style[key] || window.getComputedStyle(element)[key];
            });

            // Stocker l'élément et ses styles pour la restauration suivante
            previousHighlightedElement = element;
            previousElementStyles = originalStyles;

            // Appliquer le highlight
            element.style.transition = "all 0.3s ease";
            Object.assign(element.style, step.highlightStyle);

            // Déterminer la fonction onNext : si dernière étape, arrêter et remonter à la première fenêtre, sinon étape suivante
            const isLastStep = stepIndex === highlightSteps.length - 1;
            const onNextFunction = isLastStep ? () => {
              cleanupHighlights();
              setTimeout(() => {
                const fenetre1 = document.getElementById("demarrageFenetre1");
                if (fenetre1) {
                  fenetre1.scrollIntoView({ behavior: "smooth", block: "center" });
                }
              }, 500);
            } : () => showStep(stepIndex + 1);

            // Créer le tooltip avec navigation
            currentTooltip = createTooltipWithNavigation(
              step.message,
              stepIndex,
              highlightSteps.length,
              onNextFunction, // onNext
              () => showStep(stepIndex - 1), // onPrevious
              () => cleanupHighlights() // onClose
            );

            positionTooltip(currentTooltip, element);

            // Gérer les événements clavier
            if (!highlightKeyboardListener) {
              highlightKeyboardListener = (e) => {
                if (currentHighlightSequence === 'decodeSequence') {
                  if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    // Si on est à la dernière étape, déclencher la même action que le bouton "Terminer"
                    if (currentHighlightStep === highlightSteps.length - 1) {
                      cleanupHighlights();
                      setTimeout(() => {
                        const fenetre1 = document.getElementById("demarrageFenetre1");
                        if (fenetre1) {
                          fenetre1.scrollIntoView({ behavior: "smooth", block: "center" });
                        }
                      }, 500);
                    } else {
                      showStep(currentHighlightStep + 1);
                    }
                  } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    showStep(currentHighlightStep - 1);
                  }
                }
              };
              document.addEventListener('keydown', highlightKeyboardListener);
            }

            // Pas de timeout automatique - navigation uniquement manuelle
          }, 500);
        }

        // Démarrer avec le premier step
        showStep(0);
      }
    </script>

    <!-- Raccourci clavier global : Ctrl+J pour ouvrir le dossier de téléchargements -->
    <script>
      document.addEventListener("keydown", function (e) {
        // Ctrl+J (ou Cmd+J sur Mac) pour ouvrir le dossier de téléchargements
        if ((e.ctrlKey || e.metaKey) && e.key === "j") {
          e.preventDefault();

          // Essayer d'ouvrir le dossier de téléchargements selon le navigateur
          const userAgent = navigator.userAgent.toLowerCase();

          if (userAgent.includes("chrome") || userAgent.includes("edge")) {
            // Chrome/Edge : ouvrir la page des téléchargements
            window.open("chrome://downloads", "_blank");
          } else if (userAgent.includes("firefox")) {
            // Firefox : ouvrir la page des téléchargements
            window.open("about:downloads", "_blank");
          } else if (userAgent.includes("safari")) {
            // Safari : afficher un message car on ne peut pas ouvrir directement
            alert(
              "Sur Safari, vous pouvez ouvrir le dossier de téléchargements via le menu Édition > Afficher les téléchargements (ou Cmd+Option+L)"
            );
          } else {
            // Autres navigateurs : essayer chrome://downloads ou afficher un message
            try {
              window.open("chrome://downloads", "_blank");
            } catch (err) {
              alert(
                "Pour ouvrir le dossier de téléchargements, utilisez le raccourci de votre navigateur ou accédez-y manuellement depuis le menu."
              );
            }
          }
        }
      });
    </script>
  </body>
</html>
